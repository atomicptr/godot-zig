const std = @import("std");
const godot = @import("godot.zig");
const names = @import("names.zig");
const config = @import("config.zig");

const headerComment = "// This file was automatically generated by godot-zig, please do not edit it.\n";

pub fn createConstantsFile(allocator: std.mem.Allocator, constants: []godot.KeyValuePair) ![]const u8 {
    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    try buffer.appendSlice(headerComment);

    for (constants) |constant| {
        try std.fmt.format(buffer.writer(), "pub const {s} = {s};\n", .{ try names.toZigConstant(allocator, constant.key), constant.value });
    }

    return buffer.toOwnedSlice();
}

pub fn createClassFile(allocator: std.mem.Allocator, class: *const godot.Class) ![]const u8 {
    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    // add header
    try buffer.appendSlice(headerComment);

    try std.fmt.format(
        buffer.writer(),
        \\const godot = @import("{s}");
        \\const api = @import("../api.zig");
        \\const c_api = @import("../c_api.zig");
        \\
        \\
    ,
        .{
            config.imports_file_filename,
        },
    );

    // TODO: is this necessary? We could possibly just use godot.BaseClass instead...
    const has_base_class = class.base_class.len > 0;
    if (has_base_class) {
        try std.fmt.format(
            buffer.writer(),
            \\// base class
            \\const {s} = @import("{s}").{s};
            \\
            \\
        ,
            .{
                class.base_class,
                try names.toZigFilename(allocator, class.base_class),
                class.base_class,
            },
        );
    }

    // add method bindings
    const has_methods = class.methods.len > 0;
    if (has_methods) {
        try buffer.appendSlice("// method bindings\n");
    }

    for (class.methods) |method| {
        if (method.is_virtual) {
            continue;
        }

        try std.fmt.format(
            buffer.writer(),
            "var mbind_{s}: ?*c_api.godot_method_bind = null;\n",
            .{
                method.name,
            },
        );
    }

    // add constructor method bind
    const class_name_snake_case = names.camelCaseToSnakeCase(allocator, class.name);
    try std.fmt.format(
        buffer.writer(),
        "var mbind_{s}_constructor: ?fn () ?*c_api.godot_object = null;\n",
        .{
            class_name_snake_case,
        },
    );

    // add struct
    try std.fmt.format(
        buffer.writer(),
        "\npub const {s} = struct {{\n",
        .{
            class.name,
        },
    );

    try buffer.appendSlice("    const Self = @This();\n");

    if (has_base_class) {
        try std.fmt.format(
            buffer.writer(),
            "    const BaseClass = {s};\n",
            .{
                class.base_class,
            },
        );
    }

    // properties
    try std.fmt.format(buffer.writer(),
        \\
        \\    // Pointers to zero-sized types are also zero-sized,
        \\    // therefore we need to add some data to make it not zero-sized :)
        \\    _data: u8,
        \\
    , .{});

    if (has_base_class) {
        try buffer.appendSlice("    base: *BaseClass,\n");
    }

    // methods
    try std.fmt.format(buffer.writer(),
        \\
        \\    pub fn init() !*Self {{
        \\        if (mbind_{s}_constructor == null) {{
        \\            mbind_{s}_constructor = try api.createConstructor("{s}");
        \\        }}
        \\        return api.createObject(Self, mbind_{s}_constructor.?);
        \\    }}
        \\
        \\    pub fn deinit(self: *Self) void {{
        \\        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
        \\    }}
        \\
    , .{
        class_name_snake_case,
        class_name_snake_case,
        class.name,
        class_name_snake_case,
    });

    for (class.methods) |method| {
        if (method.is_virtual) {
            continue;
        }
        try appendMethod(allocator, &buffer, class.name, &method, has_base_class);
    }

    try buffer.appendSlice("};");

    return buffer.toOwnedSlice();
}

fn appendMethod(
    allocator: std.mem.Allocator,
    buffer: *std.ArrayList(u8),
    classname: []const u8,
    method: *const godot.Method,
    has_base_class: bool,
) !void {
    const method_name = try escapeName(
        allocator,
        try names.snakeCaseToCamelCase(allocator, method.name, false),
        "Fn",
    );
    const return_type = try toZigType(allocator, method.return_type);

    try std.fmt.format(buffer.writer(), "\n    pub fn {s}(self: *const Self", .{method_name});

    for (method.arguments) |arg, i| {
        if (i + 1 <= method.arguments.len) {
            try buffer.appendSlice(", ");
        }

        const arg_type_name = try toZigType(allocator, arg.type_name);

        try buffer.appendSlice(try concatString(allocator, "arg_", arg.name));
        try buffer.appendSlice(": ");

        // if its a godot struct, make the argument a const pointer
        if (std.mem.startsWith(u8, arg_type_name, "godot.")) {
            try buffer.appendSlice("*const ");
        }
        try buffer.appendSlice(arg_type_name);
    }

    try std.fmt.format(buffer.writer(), ") !{s} {{\n", .{return_type});

    if (!has_base_class) {
        try buffer.appendSlice("        _ = self;\n\n");
    }

    try std.fmt.format(buffer.writer(),
        \\        if (mbind_{s} == null) {{
        \\            mbind_{s} = try api.createMethod("{s}", "{s}");
        \\        }}
        \\
        \\
    , .{
        method.name,
        method.name,
        classname,
        method.name,
    });

    try buffer.appendSlice("        var result: ?*anyopaque = null;\n");

    if (method.arguments.len > 0) {
        try std.fmt.format(
            buffer.writer(),
            "        var args: [{d}]?*const anyopaque = []?*const anyopaque {{\n",
            .{method.arguments.len},
        );

        for (method.arguments) |arg| {
            const is_struct = std.mem.startsWith(u8, try toZigType(allocator, arg.type_name), "godot.");
            const arg_name = try concatString(allocator, "arg_", arg.name);
            const escaped_arg = if (is_struct) arg_name else try concatString(allocator, "*", arg_name);
            try std.fmt.format(
                buffer.writer(),
                "            @ptrCast(*const anyopaque, {s}),\n",
                .{escaped_arg},
            );
        }

        try buffer.appendSlice("        };\n\n");
        try buffer.appendSlice("        var cargs: ?*?*const anyopaque = &args[0];\n\n");
    } else {
        try buffer.appendSlice("        var cargs: ?*?*const anyopaque = null;\n\n");
    }

    if (has_base_class) {
        try buffer.appendSlice("        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));\n");
    }

    const base_param = if (has_base_class) "base" else "null";
    try std.fmt.format(
        buffer.writer(),
        "        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_{s}, {s}, cargs, result);\n",
        .{
            method.name,
            base_param,
        },
    );

    if (!std.mem.eql(u8, return_type, "void")) {
        try std.fmt.format(buffer.writer(), "        return @ptrCast(*{s}, @alignCast(@alignOf(&{s}), result)).*;\n", .{
            return_type,
            return_type,
        });
    }

    try buffer.appendSlice("    }\n");
}

fn toZigType(allocator: std.mem.Allocator, name: []const u8) ![]const u8 {
    if (std.mem.startsWith(u8, name, "enum")) {
        return "i32";
    }

    const godot_types = .{ "bool", "i32", "f32", "void" };

    inline for (.{ "bool", "int", "float", "void" }) |type_name, i| {
        if (std.mem.eql(u8, name, type_name)) {
            return godot_types[i];
        }
    } else {
        const prefix = "godot.";
        return try concatString(allocator, prefix, name);
    }
}

fn escapeName(allocator: std.mem.Allocator, name: []const u8, suffix: []const u8) ![]const u8 {
    const escapees = .{
        "var",
        "section",
        "error",
        "align",
        "use",
        "resume",
        "cancel",
        "export",
        "init",
    };

    inline for (escapees) |kw| {
        if (std.mem.eql(u8, name, kw)) {
            return try concatString(
                allocator,
                name,
                suffix,
            );
        }
    }

    return name;
}

fn concatString(allocator: std.mem.Allocator, a: []const u8, b: []const u8) ![]u8 {
    const res = try allocator.alloc(u8, a.len + b.len);
    std.mem.copy(u8, res, a);
    std.mem.copy(u8, res[a.len..], b);
    return res;
}

pub fn createImportsFile(allocator: std.mem.Allocator, fileNames: []const u8) ![]const u8 {
    var buffer = std.ArrayList(u8).init(allocator);
    defer buffer.deinit();

    try buffer.appendSlice(headerComment);

    var files = std.mem.split(u8, fileNames, "|");

    while (files.next()) |fileName| {
        try std.fmt.format(buffer.writer(), "pub usingnamespace @import(\"{s}\");\n", .{fileName});
    }

    return buffer.toOwnedSlice();
}
