// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_add_button: ?*c_api.godot_method_bind = null;
var mbind_add_cancel: ?*c_api.godot_method_bind = null;
var mbind_get_hide_on_ok: ?*c_api.godot_method_bind = null;
var mbind_get_label: ?*c_api.godot_method_bind = null;
var mbind_get_ok: ?*c_api.godot_method_bind = null;
var mbind_get_text: ?*c_api.godot_method_bind = null;
var mbind_has_autowrap: ?*c_api.godot_method_bind = null;
var mbind_register_text_enter: ?*c_api.godot_method_bind = null;
var mbind_remove_button: ?*c_api.godot_method_bind = null;
var mbind_set_autowrap: ?*c_api.godot_method_bind = null;
var mbind_set_hide_on_ok: ?*c_api.godot_method_bind = null;
var mbind_set_text: ?*c_api.godot_method_bind = null;
var mbind_accept_dialog_constructor: ?fn () ?*c_api.godot_object = null;

pub const AcceptDialog = struct {
    const Self = @This();
    pub const BaseClass = godot.WindowDialog;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_accept_dialog_constructor == null) {
            mbind_accept_dialog_constructor = try api.createConstructor("AcceptDialog");
        }
        return api.createObject(Self, mbind_accept_dialog_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addButton(self: *const Self, arg_text: *const godot.String, arg_right: bool, arg_action: *const godot.String) !godot.Button {
        if (mbind_add_button == null) {
            mbind_add_button = try api.createMethod("AcceptDialog", "add_button");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
            @ptrCast(*const anyopaque, *arg_right),
            @ptrCast(*const anyopaque, arg_action),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_button, base, cargs, result);
        return @ptrCast(*godot.Button, @alignCast(@alignOf(&godot.Button), result)).*;
    }

    pub fn addCancel(self: *const Self, arg_name: *const godot.String) !godot.Button {
        if (mbind_add_cancel == null) {
            mbind_add_cancel = try api.createMethod("AcceptDialog", "add_cancel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_cancel, base, cargs, result);
        return @ptrCast(*godot.Button, @alignCast(@alignOf(&godot.Button), result)).*;
    }

    pub fn getHideOnOk(self: *const Self) !bool {
        if (mbind_get_hide_on_ok == null) {
            mbind_get_hide_on_ok = try api.createMethod("AcceptDialog", "get_hide_on_ok");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_hide_on_ok, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getLabel(self: *const Self) !godot.Label {
        if (mbind_get_label == null) {
            mbind_get_label = try api.createMethod("AcceptDialog", "get_label");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_label, base, cargs, result);
        return @ptrCast(*godot.Label, @alignCast(@alignOf(&godot.Label), result)).*;
    }

    pub fn getOk(self: *const Self) !godot.Button {
        if (mbind_get_ok == null) {
            mbind_get_ok = try api.createMethod("AcceptDialog", "get_ok");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ok, base, cargs, result);
        return @ptrCast(*godot.Button, @alignCast(@alignOf(&godot.Button), result)).*;
    }

    pub fn getText(self: *const Self) !godot.String {
        if (mbind_get_text == null) {
            mbind_get_text = try api.createMethod("AcceptDialog", "get_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn hasAutowrap(self: *const Self) !bool {
        if (mbind_has_autowrap == null) {
            mbind_has_autowrap = try api.createMethod("AcceptDialog", "has_autowrap");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_autowrap, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn registerTextEnter(self: *const Self, arg_line_edit: *const godot.Node) !void {
        if (mbind_register_text_enter == null) {
            mbind_register_text_enter = try api.createMethod("AcceptDialog", "register_text_enter");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_line_edit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_register_text_enter, base, cargs, result);
    }

    pub fn removeButton(self: *const Self, arg_button: *const godot.Control) !void {
        if (mbind_remove_button == null) {
            mbind_remove_button = try api.createMethod("AcceptDialog", "remove_button");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_button),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_button, base, cargs, result);
    }

    pub fn setAutowrap(self: *const Self, arg_autowrap: bool) !void {
        if (mbind_set_autowrap == null) {
            mbind_set_autowrap = try api.createMethod("AcceptDialog", "set_autowrap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_autowrap),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_autowrap, base, cargs, result);
    }

    pub fn setHideOnOk(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_hide_on_ok == null) {
            mbind_set_hide_on_ok = try api.createMethod("AcceptDialog", "set_hide_on_ok");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hide_on_ok, base, cargs, result);
    }

    pub fn setText(self: *const Self, arg_text: *const godot.String) !void {
        if (mbind_set_text == null) {
            mbind_set_text = try api.createMethod("AcceptDialog", "set_text");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_text, base, cargs, result);
    }
};