// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const CollisionObject2D = @import("collision_object_2d.zig").CollisionObject2D;

// method bindings
var mbind_get_angular_damp: ?*c_api.godot_method_bind = null;
var mbind_get_audio_bus_name: ?*c_api.godot_method_bind = null;
var mbind_get_gravity: ?*c_api.godot_method_bind = null;
var mbind_get_gravity_distance_scale: ?*c_api.godot_method_bind = null;
var mbind_get_gravity_vector: ?*c_api.godot_method_bind = null;
var mbind_get_linear_damp: ?*c_api.godot_method_bind = null;
var mbind_get_overlapping_areas: ?*c_api.godot_method_bind = null;
var mbind_get_overlapping_bodies: ?*c_api.godot_method_bind = null;
var mbind_get_priority: ?*c_api.godot_method_bind = null;
var mbind_get_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_is_gravity_a_point: ?*c_api.godot_method_bind = null;
var mbind_is_monitorable: ?*c_api.godot_method_bind = null;
var mbind_is_monitoring: ?*c_api.godot_method_bind = null;
var mbind_is_overriding_audio_bus: ?*c_api.godot_method_bind = null;
var mbind_overlaps_area: ?*c_api.godot_method_bind = null;
var mbind_overlaps_body: ?*c_api.godot_method_bind = null;
var mbind_set_angular_damp: ?*c_api.godot_method_bind = null;
var mbind_set_audio_bus_name: ?*c_api.godot_method_bind = null;
var mbind_set_audio_bus_override: ?*c_api.godot_method_bind = null;
var mbind_set_gravity: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_distance_scale: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_is_point: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_vector: ?*c_api.godot_method_bind = null;
var mbind_set_linear_damp: ?*c_api.godot_method_bind = null;
var mbind_set_monitorable: ?*c_api.godot_method_bind = null;
var mbind_set_monitoring: ?*c_api.godot_method_bind = null;
var mbind_set_priority: ?*c_api.godot_method_bind = null;
var mbind_set_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_area_2d_constructor: ?fn () ?*c_api.godot_object = null;

pub const Area2D = struct {
    const Self = @This();
    const BaseClass = CollisionObject2D;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_area_2d_constructor == null) {
            mbind_area_2d_constructor = try api.createConstructor("Area2D");
        }
        return api.createObject(Self, mbind_area_2d_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getAngularDamp(self: *const Self) !f32 {
        if (mbind_get_angular_damp == null) {
            mbind_get_angular_damp = try api.createMethod("Area2D", "get_angular_damp");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_angular_damp, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAudioBusName(self: *const Self) !godot.String {
        if (mbind_get_audio_bus_name == null) {
            mbind_get_audio_bus_name = try api.createMethod("Area2D", "get_audio_bus_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_audio_bus_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getGravity(self: *const Self) !f32 {
        if (mbind_get_gravity == null) {
            mbind_get_gravity = try api.createMethod("Area2D", "get_gravity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getGravityDistanceScale(self: *const Self) !f32 {
        if (mbind_get_gravity_distance_scale == null) {
            mbind_get_gravity_distance_scale = try api.createMethod("Area2D", "get_gravity_distance_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity_distance_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getGravityVector(self: *const Self) !godot.Vector2 {
        if (mbind_get_gravity_vector == null) {
            mbind_get_gravity_vector = try api.createMethod("Area2D", "get_gravity_vector");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity_vector, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getLinearDamp(self: *const Self) !f32 {
        if (mbind_get_linear_damp == null) {
            mbind_get_linear_damp = try api.createMethod("Area2D", "get_linear_damp");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_linear_damp, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getOverlappingAreas(self: *const Self) !godot.Array {
        if (mbind_get_overlapping_areas == null) {
            mbind_get_overlapping_areas = try api.createMethod("Area2D", "get_overlapping_areas");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_overlapping_areas, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getOverlappingBodies(self: *const Self) !godot.Array {
        if (mbind_get_overlapping_bodies == null) {
            mbind_get_overlapping_bodies = try api.createMethod("Area2D", "get_overlapping_bodies");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_overlapping_bodies, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getPriority(self: *const Self) !f32 {
        if (mbind_get_priority == null) {
            mbind_get_priority = try api.createMethod("Area2D", "get_priority");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_priority, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSpaceOverrideMode(self: *const Self) !i32 {
        if (mbind_get_space_override_mode == null) {
            mbind_get_space_override_mode = try api.createMethod("Area2D", "get_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_space_override_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn isGravityAPoint(self: *const Self) !bool {
        if (mbind_is_gravity_a_point == null) {
            mbind_is_gravity_a_point = try api.createMethod("Area2D", "is_gravity_a_point");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_gravity_a_point, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isMonitorable(self: *const Self) !bool {
        if (mbind_is_monitorable == null) {
            mbind_is_monitorable = try api.createMethod("Area2D", "is_monitorable");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_monitorable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isMonitoring(self: *const Self) !bool {
        if (mbind_is_monitoring == null) {
            mbind_is_monitoring = try api.createMethod("Area2D", "is_monitoring");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_monitoring, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOverridingAudioBus(self: *const Self) !bool {
        if (mbind_is_overriding_audio_bus == null) {
            mbind_is_overriding_audio_bus = try api.createMethod("Area2D", "is_overriding_audio_bus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_overriding_audio_bus, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn overlapsArea(self: *const Self, arg_area: *const godot.Node) !bool {
        if (mbind_overlaps_area == null) {
            mbind_overlaps_area = try api.createMethod("Area2D", "overlaps_area");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_overlaps_area, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn overlapsBody(self: *const Self, arg_body: *const godot.Node) !bool {
        if (mbind_overlaps_body == null) {
            mbind_overlaps_body = try api.createMethod("Area2D", "overlaps_body");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_overlaps_body, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setAngularDamp(self: *const Self, arg_angular_damp: f32) !void {
        if (mbind_set_angular_damp == null) {
            mbind_set_angular_damp = try api.createMethod("Area2D", "set_angular_damp");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_angular_damp),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_angular_damp, base, cargs, result);
    }

    pub fn setAudioBusName(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_audio_bus_name == null) {
            mbind_set_audio_bus_name = try api.createMethod("Area2D", "set_audio_bus_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_audio_bus_name, base, cargs, result);
    }

    pub fn setAudioBusOverride(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_audio_bus_override == null) {
            mbind_set_audio_bus_override = try api.createMethod("Area2D", "set_audio_bus_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_audio_bus_override, base, cargs, result);
    }

    pub fn setGravity(self: *const Self, arg_gravity: f32) !void {
        if (mbind_set_gravity == null) {
            mbind_set_gravity = try api.createMethod("Area2D", "set_gravity");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_gravity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity, base, cargs, result);
    }

    pub fn setGravityDistanceScale(self: *const Self, arg_distance_scale: f32) !void {
        if (mbind_set_gravity_distance_scale == null) {
            mbind_set_gravity_distance_scale = try api.createMethod("Area2D", "set_gravity_distance_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_distance_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_distance_scale, base, cargs, result);
    }

    pub fn setGravityIsPoint(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_gravity_is_point == null) {
            mbind_set_gravity_is_point = try api.createMethod("Area2D", "set_gravity_is_point");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_is_point, base, cargs, result);
    }

    pub fn setGravityVector(self: *const Self, arg_vector: *const godot.Vector2) !void {
        if (mbind_set_gravity_vector == null) {
            mbind_set_gravity_vector = try api.createMethod("Area2D", "set_gravity_vector");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_vector),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_vector, base, cargs, result);
    }

    pub fn setLinearDamp(self: *const Self, arg_linear_damp: f32) !void {
        if (mbind_set_linear_damp == null) {
            mbind_set_linear_damp = try api.createMethod("Area2D", "set_linear_damp");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_linear_damp),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_linear_damp, base, cargs, result);
    }

    pub fn setMonitorable(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_monitorable == null) {
            mbind_set_monitorable = try api.createMethod("Area2D", "set_monitorable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_monitorable, base, cargs, result);
    }

    pub fn setMonitoring(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_monitoring == null) {
            mbind_set_monitoring = try api.createMethod("Area2D", "set_monitoring");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_monitoring, base, cargs, result);
    }

    pub fn setPriority(self: *const Self, arg_priority: f32) !void {
        if (mbind_set_priority == null) {
            mbind_set_priority = try api.createMethod("Area2D", "set_priority");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_priority, base, cargs, result);
    }

    pub fn setSpaceOverrideMode(self: *const Self, arg_space_override_mode: i32) !void {
        if (mbind_set_space_override_mode == null) {
            mbind_set_space_override_mode = try api.createMethod("Area2D", "set_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_space_override_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_space_override_mode, base, cargs, result);
    }
};