// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const CollisionObject = @import("collision_object.zig").CollisionObject;

// method bindings
var mbind_get_angular_damp: ?*c_api.godot_method_bind = null;
var mbind_get_audio_bus: ?*c_api.godot_method_bind = null;
var mbind_get_gravity: ?*c_api.godot_method_bind = null;
var mbind_get_gravity_distance_scale: ?*c_api.godot_method_bind = null;
var mbind_get_gravity_vector: ?*c_api.godot_method_bind = null;
var mbind_get_linear_damp: ?*c_api.godot_method_bind = null;
var mbind_get_overlapping_areas: ?*c_api.godot_method_bind = null;
var mbind_get_overlapping_bodies: ?*c_api.godot_method_bind = null;
var mbind_get_priority: ?*c_api.godot_method_bind = null;
var mbind_get_reverb_amount: ?*c_api.godot_method_bind = null;
var mbind_get_reverb_bus: ?*c_api.godot_method_bind = null;
var mbind_get_reverb_uniformity: ?*c_api.godot_method_bind = null;
var mbind_get_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_is_gravity_a_point: ?*c_api.godot_method_bind = null;
var mbind_is_monitorable: ?*c_api.godot_method_bind = null;
var mbind_is_monitoring: ?*c_api.godot_method_bind = null;
var mbind_is_overriding_audio_bus: ?*c_api.godot_method_bind = null;
var mbind_is_using_reverb_bus: ?*c_api.godot_method_bind = null;
var mbind_overlaps_area: ?*c_api.godot_method_bind = null;
var mbind_overlaps_body: ?*c_api.godot_method_bind = null;
var mbind_set_angular_damp: ?*c_api.godot_method_bind = null;
var mbind_set_audio_bus: ?*c_api.godot_method_bind = null;
var mbind_set_audio_bus_override: ?*c_api.godot_method_bind = null;
var mbind_set_gravity: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_distance_scale: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_is_point: ?*c_api.godot_method_bind = null;
var mbind_set_gravity_vector: ?*c_api.godot_method_bind = null;
var mbind_set_linear_damp: ?*c_api.godot_method_bind = null;
var mbind_set_monitorable: ?*c_api.godot_method_bind = null;
var mbind_set_monitoring: ?*c_api.godot_method_bind = null;
var mbind_set_priority: ?*c_api.godot_method_bind = null;
var mbind_set_reverb_amount: ?*c_api.godot_method_bind = null;
var mbind_set_reverb_bus: ?*c_api.godot_method_bind = null;
var mbind_set_reverb_uniformity: ?*c_api.godot_method_bind = null;
var mbind_set_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_set_use_reverb_bus: ?*c_api.godot_method_bind = null;
var mbind_area_constructor: ?fn () ?*c_api.godot_object = null;

pub const Area = struct {
    const Self = @This();
    const BaseClass = CollisionObject;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_area_constructor == null) {
            mbind_area_constructor = try api.createConstructor("Area");
        }
        return api.createObject(Self, mbind_area_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getAngularDamp(self: *const Self) !f32 {
        if (mbind_get_angular_damp == null) {
            mbind_get_angular_damp = try api.createMethod("Area", "get_angular_damp");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_angular_damp, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAudioBus(self: *const Self) !godot.String {
        if (mbind_get_audio_bus == null) {
            mbind_get_audio_bus = try api.createMethod("Area", "get_audio_bus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_audio_bus, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getGravity(self: *const Self) !f32 {
        if (mbind_get_gravity == null) {
            mbind_get_gravity = try api.createMethod("Area", "get_gravity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getGravityDistanceScale(self: *const Self) !f32 {
        if (mbind_get_gravity_distance_scale == null) {
            mbind_get_gravity_distance_scale = try api.createMethod("Area", "get_gravity_distance_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity_distance_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getGravityVector(self: *const Self) !godot.Vector3 {
        if (mbind_get_gravity_vector == null) {
            mbind_get_gravity_vector = try api.createMethod("Area", "get_gravity_vector");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gravity_vector, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getLinearDamp(self: *const Self) !f32 {
        if (mbind_get_linear_damp == null) {
            mbind_get_linear_damp = try api.createMethod("Area", "get_linear_damp");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_linear_damp, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getOverlappingAreas(self: *const Self) !godot.Array {
        if (mbind_get_overlapping_areas == null) {
            mbind_get_overlapping_areas = try api.createMethod("Area", "get_overlapping_areas");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_overlapping_areas, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getOverlappingBodies(self: *const Self) !godot.Array {
        if (mbind_get_overlapping_bodies == null) {
            mbind_get_overlapping_bodies = try api.createMethod("Area", "get_overlapping_bodies");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_overlapping_bodies, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getPriority(self: *const Self) !f32 {
        if (mbind_get_priority == null) {
            mbind_get_priority = try api.createMethod("Area", "get_priority");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_priority, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getReverbAmount(self: *const Self) !f32 {
        if (mbind_get_reverb_amount == null) {
            mbind_get_reverb_amount = try api.createMethod("Area", "get_reverb_amount");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_reverb_amount, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getReverbBus(self: *const Self) !godot.String {
        if (mbind_get_reverb_bus == null) {
            mbind_get_reverb_bus = try api.createMethod("Area", "get_reverb_bus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_reverb_bus, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getReverbUniformity(self: *const Self) !f32 {
        if (mbind_get_reverb_uniformity == null) {
            mbind_get_reverb_uniformity = try api.createMethod("Area", "get_reverb_uniformity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_reverb_uniformity, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSpaceOverrideMode(self: *const Self) !i32 {
        if (mbind_get_space_override_mode == null) {
            mbind_get_space_override_mode = try api.createMethod("Area", "get_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_space_override_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn isGravityAPoint(self: *const Self) !bool {
        if (mbind_is_gravity_a_point == null) {
            mbind_is_gravity_a_point = try api.createMethod("Area", "is_gravity_a_point");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_gravity_a_point, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isMonitorable(self: *const Self) !bool {
        if (mbind_is_monitorable == null) {
            mbind_is_monitorable = try api.createMethod("Area", "is_monitorable");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_monitorable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isMonitoring(self: *const Self) !bool {
        if (mbind_is_monitoring == null) {
            mbind_is_monitoring = try api.createMethod("Area", "is_monitoring");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_monitoring, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOverridingAudioBus(self: *const Self) !bool {
        if (mbind_is_overriding_audio_bus == null) {
            mbind_is_overriding_audio_bus = try api.createMethod("Area", "is_overriding_audio_bus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_overriding_audio_bus, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingReverbBus(self: *const Self) !bool {
        if (mbind_is_using_reverb_bus == null) {
            mbind_is_using_reverb_bus = try api.createMethod("Area", "is_using_reverb_bus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_reverb_bus, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn overlapsArea(self: *const Self, arg_area: *const godot.Node) !bool {
        if (mbind_overlaps_area == null) {
            mbind_overlaps_area = try api.createMethod("Area", "overlaps_area");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_overlaps_area, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn overlapsBody(self: *const Self, arg_body: *const godot.Node) !bool {
        if (mbind_overlaps_body == null) {
            mbind_overlaps_body = try api.createMethod("Area", "overlaps_body");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_overlaps_body, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setAngularDamp(self: *const Self, arg_angular_damp: f32) !void {
        if (mbind_set_angular_damp == null) {
            mbind_set_angular_damp = try api.createMethod("Area", "set_angular_damp");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_angular_damp),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_angular_damp, base, cargs, result);
    }

    pub fn setAudioBus(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_audio_bus == null) {
            mbind_set_audio_bus = try api.createMethod("Area", "set_audio_bus");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_audio_bus, base, cargs, result);
    }

    pub fn setAudioBusOverride(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_audio_bus_override == null) {
            mbind_set_audio_bus_override = try api.createMethod("Area", "set_audio_bus_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_audio_bus_override, base, cargs, result);
    }

    pub fn setGravity(self: *const Self, arg_gravity: f32) !void {
        if (mbind_set_gravity == null) {
            mbind_set_gravity = try api.createMethod("Area", "set_gravity");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_gravity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity, base, cargs, result);
    }

    pub fn setGravityDistanceScale(self: *const Self, arg_distance_scale: f32) !void {
        if (mbind_set_gravity_distance_scale == null) {
            mbind_set_gravity_distance_scale = try api.createMethod("Area", "set_gravity_distance_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_distance_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_distance_scale, base, cargs, result);
    }

    pub fn setGravityIsPoint(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_gravity_is_point == null) {
            mbind_set_gravity_is_point = try api.createMethod("Area", "set_gravity_is_point");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_is_point, base, cargs, result);
    }

    pub fn setGravityVector(self: *const Self, arg_vector: *const godot.Vector3) !void {
        if (mbind_set_gravity_vector == null) {
            mbind_set_gravity_vector = try api.createMethod("Area", "set_gravity_vector");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_vector),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gravity_vector, base, cargs, result);
    }

    pub fn setLinearDamp(self: *const Self, arg_linear_damp: f32) !void {
        if (mbind_set_linear_damp == null) {
            mbind_set_linear_damp = try api.createMethod("Area", "set_linear_damp");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_linear_damp),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_linear_damp, base, cargs, result);
    }

    pub fn setMonitorable(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_monitorable == null) {
            mbind_set_monitorable = try api.createMethod("Area", "set_monitorable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_monitorable, base, cargs, result);
    }

    pub fn setMonitoring(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_monitoring == null) {
            mbind_set_monitoring = try api.createMethod("Area", "set_monitoring");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_monitoring, base, cargs, result);
    }

    pub fn setPriority(self: *const Self, arg_priority: f32) !void {
        if (mbind_set_priority == null) {
            mbind_set_priority = try api.createMethod("Area", "set_priority");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_priority, base, cargs, result);
    }

    pub fn setReverbAmount(self: *const Self, arg_amount: f32) !void {
        if (mbind_set_reverb_amount == null) {
            mbind_set_reverb_amount = try api.createMethod("Area", "set_reverb_amount");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_reverb_amount, base, cargs, result);
    }

    pub fn setReverbBus(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_reverb_bus == null) {
            mbind_set_reverb_bus = try api.createMethod("Area", "set_reverb_bus");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_reverb_bus, base, cargs, result);
    }

    pub fn setReverbUniformity(self: *const Self, arg_amount: f32) !void {
        if (mbind_set_reverb_uniformity == null) {
            mbind_set_reverb_uniformity = try api.createMethod("Area", "set_reverb_uniformity");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_reverb_uniformity, base, cargs, result);
    }

    pub fn setSpaceOverrideMode(self: *const Self, arg_enable: i32) !void {
        if (mbind_set_space_override_mode == null) {
            mbind_set_space_override_mode = try api.createMethod("Area", "set_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_space_override_mode, base, cargs, result);
    }

    pub fn setUseReverbBus(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_reverb_bus == null) {
            mbind_set_use_reverb_bus = try api.createMethod("Area", "set_use_reverb_bus");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_reverb_bus, base, cargs, result);
    }
};