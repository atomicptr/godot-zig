// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node = @import("node.zig").Node;

// method bindings
var mbind_edit_node: ?*c_api.godot_method_bind = null;
var mbind_edit_resource: ?*c_api.godot_method_bind = null;
var mbind_edit_script: ?*c_api.godot_method_bind = null;
var mbind_get_base_control: ?*c_api.godot_method_bind = null;
var mbind_get_current_path: ?*c_api.godot_method_bind = null;
var mbind_get_edited_scene_root: ?*c_api.godot_method_bind = null;
var mbind_get_editor_scale: ?*c_api.godot_method_bind = null;
var mbind_get_editor_settings: ?*c_api.godot_method_bind = null;
var mbind_get_editor_viewport: ?*c_api.godot_method_bind = null;
var mbind_get_file_system_dock: ?*c_api.godot_method_bind = null;
var mbind_get_inspector: ?*c_api.godot_method_bind = null;
var mbind_get_open_scenes: ?*c_api.godot_method_bind = null;
var mbind_get_playing_scene: ?*c_api.godot_method_bind = null;
var mbind_get_resource_filesystem: ?*c_api.godot_method_bind = null;
var mbind_get_resource_previewer: ?*c_api.godot_method_bind = null;
var mbind_get_script_editor: ?*c_api.godot_method_bind = null;
var mbind_get_selected_path: ?*c_api.godot_method_bind = null;
var mbind_get_selection: ?*c_api.godot_method_bind = null;
var mbind_inspect_object: ?*c_api.godot_method_bind = null;
var mbind_is_distraction_free_mode_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_playing_scene: ?*c_api.godot_method_bind = null;
var mbind_is_plugin_enabled: ?*c_api.godot_method_bind = null;
var mbind_make_mesh_previews: ?*c_api.godot_method_bind = null;
var mbind_open_scene_from_path: ?*c_api.godot_method_bind = null;
var mbind_play_current_scene: ?*c_api.godot_method_bind = null;
var mbind_play_custom_scene: ?*c_api.godot_method_bind = null;
var mbind_play_main_scene: ?*c_api.godot_method_bind = null;
var mbind_reload_scene_from_path: ?*c_api.godot_method_bind = null;
var mbind_save_scene: ?*c_api.godot_method_bind = null;
var mbind_save_scene_as: ?*c_api.godot_method_bind = null;
var mbind_select_file: ?*c_api.godot_method_bind = null;
var mbind_set_distraction_free_mode: ?*c_api.godot_method_bind = null;
var mbind_set_main_screen_editor: ?*c_api.godot_method_bind = null;
var mbind_set_plugin_enabled: ?*c_api.godot_method_bind = null;
var mbind_stop_playing_scene: ?*c_api.godot_method_bind = null;
var mbind_editor_interface_constructor: ?fn () ?*c_api.godot_object = null;

pub const EditorInterface = struct {
    const Self = @This();
    const BaseClass = Node;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_editor_interface_constructor == null) {
            mbind_editor_interface_constructor = try api.createConstructor("EditorInterface");
        }
        return api.createObject(Self, mbind_editor_interface_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn editNode(self: *const Self, arg_node: *const godot.Node) !void {
        if (mbind_edit_node == null) {
            mbind_edit_node = try api.createMethod("EditorInterface", "edit_node");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_edit_node, base, cargs, result);
    }

    pub fn editResource(self: *const Self, arg_resource: *const godot.Resource) !void {
        if (mbind_edit_resource == null) {
            mbind_edit_resource = try api.createMethod("EditorInterface", "edit_resource");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_resource),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_edit_resource, base, cargs, result);
    }

    pub fn editScript(self: *const Self, arg_script: *const godot.Script, arg_line: i32, arg_column: i32, arg_grab_focus: bool) !void {
        if (mbind_edit_script == null) {
            mbind_edit_script = try api.createMethod("EditorInterface", "edit_script");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_script),
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_column),
            @ptrCast(*const anyopaque, *arg_grab_focus),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_edit_script, base, cargs, result);
    }

    pub fn getBaseControl(self: *const Self) !godot.Control {
        if (mbind_get_base_control == null) {
            mbind_get_base_control = try api.createMethod("EditorInterface", "get_base_control");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_base_control, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn getCurrentPath(self: *const Self) !godot.String {
        if (mbind_get_current_path == null) {
            mbind_get_current_path = try api.createMethod("EditorInterface", "get_current_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getEditedSceneRoot(self: *const Self) !godot.Node {
        if (mbind_get_edited_scene_root == null) {
            mbind_get_edited_scene_root = try api.createMethod("EditorInterface", "get_edited_scene_root");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_edited_scene_root, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getEditorScale(self: *const Self) !f32 {
        if (mbind_get_editor_scale == null) {
            mbind_get_editor_scale = try api.createMethod("EditorInterface", "get_editor_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_editor_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEditorSettings(self: *const Self) !godot.EditorSettings {
        if (mbind_get_editor_settings == null) {
            mbind_get_editor_settings = try api.createMethod("EditorInterface", "get_editor_settings");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_editor_settings, base, cargs, result);
        return @ptrCast(*godot.EditorSettings, @alignCast(@alignOf(&godot.EditorSettings), result)).*;
    }

    pub fn getEditorViewport(self: *const Self) !godot.Control {
        if (mbind_get_editor_viewport == null) {
            mbind_get_editor_viewport = try api.createMethod("EditorInterface", "get_editor_viewport");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_editor_viewport, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn getFileSystemDock(self: *const Self) !godot.FileSystemDock {
        if (mbind_get_file_system_dock == null) {
            mbind_get_file_system_dock = try api.createMethod("EditorInterface", "get_file_system_dock");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_file_system_dock, base, cargs, result);
        return @ptrCast(*godot.FileSystemDock, @alignCast(@alignOf(&godot.FileSystemDock), result)).*;
    }

    pub fn getInspector(self: *const Self) !godot.EditorInspector {
        if (mbind_get_inspector == null) {
            mbind_get_inspector = try api.createMethod("EditorInterface", "get_inspector");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_inspector, base, cargs, result);
        return @ptrCast(*godot.EditorInspector, @alignCast(@alignOf(&godot.EditorInspector), result)).*;
    }

    pub fn getOpenScenes(self: *const Self) !godot.Array {
        if (mbind_get_open_scenes == null) {
            mbind_get_open_scenes = try api.createMethod("EditorInterface", "get_open_scenes");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_open_scenes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getPlayingScene(self: *const Self) !godot.String {
        if (mbind_get_playing_scene == null) {
            mbind_get_playing_scene = try api.createMethod("EditorInterface", "get_playing_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_playing_scene, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getResourceFilesystem(self: *const Self) !godot.EditorFileSystem {
        if (mbind_get_resource_filesystem == null) {
            mbind_get_resource_filesystem = try api.createMethod("EditorInterface", "get_resource_filesystem");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_resource_filesystem, base, cargs, result);
        return @ptrCast(*godot.EditorFileSystem, @alignCast(@alignOf(&godot.EditorFileSystem), result)).*;
    }

    pub fn getResourcePreviewer(self: *const Self) !godot.EditorResourcePreview {
        if (mbind_get_resource_previewer == null) {
            mbind_get_resource_previewer = try api.createMethod("EditorInterface", "get_resource_previewer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_resource_previewer, base, cargs, result);
        return @ptrCast(*godot.EditorResourcePreview, @alignCast(@alignOf(&godot.EditorResourcePreview), result)).*;
    }

    pub fn getScriptEditor(self: *const Self) !godot.ScriptEditor {
        if (mbind_get_script_editor == null) {
            mbind_get_script_editor = try api.createMethod("EditorInterface", "get_script_editor");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_script_editor, base, cargs, result);
        return @ptrCast(*godot.ScriptEditor, @alignCast(@alignOf(&godot.ScriptEditor), result)).*;
    }

    pub fn getSelectedPath(self: *const Self) !godot.String {
        if (mbind_get_selected_path == null) {
            mbind_get_selected_path = try api.createMethod("EditorInterface", "get_selected_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selected_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getSelection(self: *const Self) !godot.EditorSelection {
        if (mbind_get_selection == null) {
            mbind_get_selection = try api.createMethod("EditorInterface", "get_selection");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection, base, cargs, result);
        return @ptrCast(*godot.EditorSelection, @alignCast(@alignOf(&godot.EditorSelection), result)).*;
    }

    pub fn inspectObject(self: *const Self, arg_object: *const godot.Object, arg_for_property: *const godot.String, arg_inspector_only: bool) !void {
        if (mbind_inspect_object == null) {
            mbind_inspect_object = try api.createMethod("EditorInterface", "inspect_object");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_for_property),
            @ptrCast(*const anyopaque, *arg_inspector_only),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_inspect_object, base, cargs, result);
    }

    pub fn isDistractionFreeModeEnabled(self: *const Self) !bool {
        if (mbind_is_distraction_free_mode_enabled == null) {
            mbind_is_distraction_free_mode_enabled = try api.createMethod("EditorInterface", "is_distraction_free_mode_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_distraction_free_mode_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPlayingScene(self: *const Self) !bool {
        if (mbind_is_playing_scene == null) {
            mbind_is_playing_scene = try api.createMethod("EditorInterface", "is_playing_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_playing_scene, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPluginEnabled(self: *const Self, arg_plugin: *const godot.String) !bool {
        if (mbind_is_plugin_enabled == null) {
            mbind_is_plugin_enabled = try api.createMethod("EditorInterface", "is_plugin_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_plugin_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn makeMeshPreviews(self: *const Self, arg_meshes: *const godot.Array, arg_preview_size: i32) !godot.Array {
        if (mbind_make_mesh_previews == null) {
            mbind_make_mesh_previews = try api.createMethod("EditorInterface", "make_mesh_previews");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_meshes),
            @ptrCast(*const anyopaque, *arg_preview_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_mesh_previews, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn openSceneFromPath(self: *const Self, arg_scene_filepath: *const godot.String) !void {
        if (mbind_open_scene_from_path == null) {
            mbind_open_scene_from_path = try api.createMethod("EditorInterface", "open_scene_from_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene_filepath),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_scene_from_path, base, cargs, result);
    }

    pub fn playCurrentScene(self: *const Self) !void {
        if (mbind_play_current_scene == null) {
            mbind_play_current_scene = try api.createMethod("EditorInterface", "play_current_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_play_current_scene, base, cargs, result);
    }

    pub fn playCustomScene(self: *const Self, arg_scene_filepath: *const godot.String) !void {
        if (mbind_play_custom_scene == null) {
            mbind_play_custom_scene = try api.createMethod("EditorInterface", "play_custom_scene");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene_filepath),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_play_custom_scene, base, cargs, result);
    }

    pub fn playMainScene(self: *const Self) !void {
        if (mbind_play_main_scene == null) {
            mbind_play_main_scene = try api.createMethod("EditorInterface", "play_main_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_play_main_scene, base, cargs, result);
    }

    pub fn reloadSceneFromPath(self: *const Self, arg_scene_filepath: *const godot.String) !void {
        if (mbind_reload_scene_from_path == null) {
            mbind_reload_scene_from_path = try api.createMethod("EditorInterface", "reload_scene_from_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene_filepath),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reload_scene_from_path, base, cargs, result);
    }

    pub fn saveScene(self: *const Self) !i32 {
        if (mbind_save_scene == null) {
            mbind_save_scene = try api.createMethod("EditorInterface", "save_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_save_scene, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn saveSceneAs(self: *const Self, arg_path: *const godot.String, arg_with_preview: bool) !void {
        if (mbind_save_scene_as == null) {
            mbind_save_scene_as = try api.createMethod("EditorInterface", "save_scene_as");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_with_preview),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_save_scene_as, base, cargs, result);
    }

    pub fn selectFile(self: *const Self, arg_file: *const godot.String) !void {
        if (mbind_select_file == null) {
            mbind_select_file = try api.createMethod("EditorInterface", "select_file");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_file),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_select_file, base, cargs, result);
    }

    pub fn setDistractionFreeMode(self: *const Self, arg_enter: bool) !void {
        if (mbind_set_distraction_free_mode == null) {
            mbind_set_distraction_free_mode = try api.createMethod("EditorInterface", "set_distraction_free_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_distraction_free_mode, base, cargs, result);
    }

    pub fn setMainScreenEditor(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_main_screen_editor == null) {
            mbind_set_main_screen_editor = try api.createMethod("EditorInterface", "set_main_screen_editor");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_main_screen_editor, base, cargs, result);
    }

    pub fn setPluginEnabled(self: *const Self, arg_plugin: *const godot.String, arg_enabled: bool) !void {
        if (mbind_set_plugin_enabled == null) {
            mbind_set_plugin_enabled = try api.createMethod("EditorInterface", "set_plugin_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_plugin_enabled, base, cargs, result);
    }

    pub fn stopPlayingScene(self: *const Self) !void {
        if (mbind_stop_playing_scene == null) {
            mbind_stop_playing_scene = try api.createMethod("EditorInterface", "stop_playing_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_stop_playing_scene, base, cargs, result);
    }
};