// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_build_box_planes: ?*c_api.godot_method_bind = null;
var mbind_build_capsule_planes: ?*c_api.godot_method_bind = null;
var mbind_build_cylinder_planes: ?*c_api.godot_method_bind = null;
var mbind_clip_polygon: ?*c_api.godot_method_bind = null;
var mbind_clip_polygons_2d: ?*c_api.godot_method_bind = null;
var mbind_clip_polyline_with_polygon_2d: ?*c_api.godot_method_bind = null;
var mbind_convex_hull_2d: ?*c_api.godot_method_bind = null;
var mbind_exclude_polygons_2d: ?*c_api.godot_method_bind = null;
var mbind_get_closest_point_to_segment: ?*c_api.godot_method_bind = null;
var mbind_get_closest_point_to_segment_2d: ?*c_api.godot_method_bind = null;
var mbind_get_closest_point_to_segment_uncapped: ?*c_api.godot_method_bind = null;
var mbind_get_closest_point_to_segment_uncapped_2d: ?*c_api.godot_method_bind = null;
var mbind_get_closest_points_between_segments: ?*c_api.godot_method_bind = null;
var mbind_get_closest_points_between_segments_2d: ?*c_api.godot_method_bind = null;
var mbind_get_uv84_normal_bit: ?*c_api.godot_method_bind = null;
var mbind_intersect_polygons_2d: ?*c_api.godot_method_bind = null;
var mbind_intersect_polyline_with_polygon_2d: ?*c_api.godot_method_bind = null;
var mbind_is_point_in_circle: ?*c_api.godot_method_bind = null;
var mbind_is_point_in_polygon: ?*c_api.godot_method_bind = null;
var mbind_is_polygon_clockwise: ?*c_api.godot_method_bind = null;
var mbind_line_intersects_line_2d: ?*c_api.godot_method_bind = null;
var mbind_make_atlas: ?*c_api.godot_method_bind = null;
var mbind_merge_polygons_2d: ?*c_api.godot_method_bind = null;
var mbind_offset_polygon_2d: ?*c_api.godot_method_bind = null;
var mbind_offset_polyline_2d: ?*c_api.godot_method_bind = null;
var mbind_point_is_inside_triangle: ?*c_api.godot_method_bind = null;
var mbind_ray_intersects_triangle: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_circle: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_convex: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_cylinder: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_segment_2d: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_sphere: ?*c_api.godot_method_bind = null;
var mbind_segment_intersects_triangle: ?*c_api.godot_method_bind = null;
var mbind_triangulate_delaunay_2d: ?*c_api.godot_method_bind = null;
var mbind_triangulate_polygon: ?*c_api.godot_method_bind = null;
var mbind__geometry_constructor: ?fn () ?*c_api.godot_object = null;

pub const _Geometry = struct {
    const Self = @This();
    pub const BaseClass = godot.Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind__geometry_constructor == null) {
            mbind__geometry_constructor = try api.createConstructor("_Geometry");
        }
        return api.createObject(Self, mbind__geometry_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn buildBoxPlanes(self: *const Self, arg_extents: *const godot.Vector3) !godot.Array {
        if (mbind_build_box_planes == null) {
            mbind_build_box_planes = try api.createMethod("_Geometry", "build_box_planes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_extents),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_build_box_planes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn buildCapsulePlanes(self: *const Self, arg_radius: f32, arg_height: f32, arg_sides: i32, arg_lats: i32, arg_axis: i32) !godot.Array {
        if (mbind_build_capsule_planes == null) {
            mbind_build_capsule_planes = try api.createMethod("_Geometry", "build_capsule_planes");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_sides),
            @ptrCast(*const anyopaque, *arg_lats),
            @ptrCast(*const anyopaque, *arg_axis),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_build_capsule_planes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn buildCylinderPlanes(self: *const Self, arg_radius: f32, arg_height: f32, arg_sides: i32, arg_axis: i32) !godot.Array {
        if (mbind_build_cylinder_planes == null) {
            mbind_build_cylinder_planes = try api.createMethod("_Geometry", "build_cylinder_planes");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_sides),
            @ptrCast(*const anyopaque, *arg_axis),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_build_cylinder_planes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn clipPolygon(self: *const Self, arg_points: *const godot.PoolVector3Array, arg_plane: *const godot.Plane) !godot.PoolVector3Array {
        if (mbind_clip_polygon == null) {
            mbind_clip_polygon = try api.createMethod("_Geometry", "clip_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_plane),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clip_polygon, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn clipPolygons2d(self: *const Self, arg_polygon_a: *const godot.PoolVector2Array, arg_polygon_b: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_clip_polygons_2d == null) {
            mbind_clip_polygons_2d = try api.createMethod("_Geometry", "clip_polygons_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon_a),
            @ptrCast(*const anyopaque, arg_polygon_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clip_polygons_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn clipPolylineWithPolygon2d(self: *const Self, arg_polyline: *const godot.PoolVector2Array, arg_polygon: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_clip_polyline_with_polygon_2d == null) {
            mbind_clip_polyline_with_polygon_2d = try api.createMethod("_Geometry", "clip_polyline_with_polygon_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polyline),
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clip_polyline_with_polygon_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn convexHull2d(self: *const Self, arg_points: *const godot.PoolVector2Array) !godot.PoolVector2Array {
        if (mbind_convex_hull_2d == null) {
            mbind_convex_hull_2d = try api.createMethod("_Geometry", "convex_hull_2d");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_convex_hull_2d, base, cargs, result);
        return @ptrCast(*godot.PoolVector2Array, @alignCast(@alignOf(&godot.PoolVector2Array), result)).*;
    }

    pub fn excludePolygons2d(self: *const Self, arg_polygon_a: *const godot.PoolVector2Array, arg_polygon_b: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_exclude_polygons_2d == null) {
            mbind_exclude_polygons_2d = try api.createMethod("_Geometry", "exclude_polygons_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon_a),
            @ptrCast(*const anyopaque, arg_polygon_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_exclude_polygons_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getClosestPointToSegment(self: *const Self, arg_point: *const godot.Vector3, arg_s1: *const godot.Vector3, arg_s2: *const godot.Vector3) !godot.Vector3 {
        if (mbind_get_closest_point_to_segment == null) {
            mbind_get_closest_point_to_segment = try api.createMethod("_Geometry", "get_closest_point_to_segment");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_s1),
            @ptrCast(*const anyopaque, arg_s2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_point_to_segment, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getClosestPointToSegment2d(self: *const Self, arg_point: *const godot.Vector2, arg_s1: *const godot.Vector2, arg_s2: *const godot.Vector2) !godot.Vector2 {
        if (mbind_get_closest_point_to_segment_2d == null) {
            mbind_get_closest_point_to_segment_2d = try api.createMethod("_Geometry", "get_closest_point_to_segment_2d");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_s1),
            @ptrCast(*const anyopaque, arg_s2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_point_to_segment_2d, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getClosestPointToSegmentUncapped(self: *const Self, arg_point: *const godot.Vector3, arg_s1: *const godot.Vector3, arg_s2: *const godot.Vector3) !godot.Vector3 {
        if (mbind_get_closest_point_to_segment_uncapped == null) {
            mbind_get_closest_point_to_segment_uncapped = try api.createMethod("_Geometry", "get_closest_point_to_segment_uncapped");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_s1),
            @ptrCast(*const anyopaque, arg_s2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_point_to_segment_uncapped, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getClosestPointToSegmentUncapped2d(self: *const Self, arg_point: *const godot.Vector2, arg_s1: *const godot.Vector2, arg_s2: *const godot.Vector2) !godot.Vector2 {
        if (mbind_get_closest_point_to_segment_uncapped_2d == null) {
            mbind_get_closest_point_to_segment_uncapped_2d = try api.createMethod("_Geometry", "get_closest_point_to_segment_uncapped_2d");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_s1),
            @ptrCast(*const anyopaque, arg_s2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_point_to_segment_uncapped_2d, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getClosestPointsBetweenSegments(self: *const Self, arg_p1: *const godot.Vector3, arg_p2: *const godot.Vector3, arg_q1: *const godot.Vector3, arg_q2: *const godot.Vector3) !godot.PoolVector3Array {
        if (mbind_get_closest_points_between_segments == null) {
            mbind_get_closest_points_between_segments = try api.createMethod("_Geometry", "get_closest_points_between_segments");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_p1),
            @ptrCast(*const anyopaque, arg_p2),
            @ptrCast(*const anyopaque, arg_q1),
            @ptrCast(*const anyopaque, arg_q2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_points_between_segments, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn getClosestPointsBetweenSegments2d(self: *const Self, arg_p1: *const godot.Vector2, arg_q1: *const godot.Vector2, arg_p2: *const godot.Vector2, arg_q2: *const godot.Vector2) !godot.PoolVector2Array {
        if (mbind_get_closest_points_between_segments_2d == null) {
            mbind_get_closest_points_between_segments_2d = try api.createMethod("_Geometry", "get_closest_points_between_segments_2d");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_p1),
            @ptrCast(*const anyopaque, arg_q1),
            @ptrCast(*const anyopaque, arg_p2),
            @ptrCast(*const anyopaque, arg_q2),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_closest_points_between_segments_2d, base, cargs, result);
        return @ptrCast(*godot.PoolVector2Array, @alignCast(@alignOf(&godot.PoolVector2Array), result)).*;
    }

    pub fn getUv84NormalBit(self: *const Self, arg_normal: *const godot.Vector3) !i32 {
        if (mbind_get_uv84_normal_bit == null) {
            mbind_get_uv84_normal_bit = try api.createMethod("_Geometry", "get_uv84_normal_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_normal),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv84_normal_bit, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn intersectPolygons2d(self: *const Self, arg_polygon_a: *const godot.PoolVector2Array, arg_polygon_b: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_intersect_polygons_2d == null) {
            mbind_intersect_polygons_2d = try api.createMethod("_Geometry", "intersect_polygons_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon_a),
            @ptrCast(*const anyopaque, arg_polygon_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_intersect_polygons_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn intersectPolylineWithPolygon2d(self: *const Self, arg_polyline: *const godot.PoolVector2Array, arg_polygon: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_intersect_polyline_with_polygon_2d == null) {
            mbind_intersect_polyline_with_polygon_2d = try api.createMethod("_Geometry", "intersect_polyline_with_polygon_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polyline),
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_intersect_polyline_with_polygon_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn isPointInCircle(self: *const Self, arg_point: *const godot.Vector2, arg_circle_position: *const godot.Vector2, arg_circle_radius: f32) !bool {
        if (mbind_is_point_in_circle == null) {
            mbind_is_point_in_circle = try api.createMethod("_Geometry", "is_point_in_circle");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_circle_position),
            @ptrCast(*const anyopaque, *arg_circle_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_point_in_circle, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPointInPolygon(self: *const Self, arg_point: *const godot.Vector2, arg_polygon: *const godot.PoolVector2Array) !bool {
        if (mbind_is_point_in_polygon == null) {
            mbind_is_point_in_polygon = try api.createMethod("_Geometry", "is_point_in_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_point_in_polygon, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPolygonClockwise(self: *const Self, arg_polygon: *const godot.PoolVector2Array) !bool {
        if (mbind_is_polygon_clockwise == null) {
            mbind_is_polygon_clockwise = try api.createMethod("_Geometry", "is_polygon_clockwise");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_polygon_clockwise, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn lineIntersectsLine2d(self: *const Self, arg_from_a: *const godot.Vector2, arg_dir_a: *const godot.Vector2, arg_from_b: *const godot.Vector2, arg_dir_b: *const godot.Vector2) !godot.Variant {
        if (mbind_line_intersects_line_2d == null) {
            mbind_line_intersects_line_2d = try api.createMethod("_Geometry", "line_intersects_line_2d");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from_a),
            @ptrCast(*const anyopaque, arg_dir_a),
            @ptrCast(*const anyopaque, arg_from_b),
            @ptrCast(*const anyopaque, arg_dir_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_line_intersects_line_2d, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn makeAtlas(self: *const Self, arg_sizes: *const godot.PoolVector2Array) !godot.Dictionary {
        if (mbind_make_atlas == null) {
            mbind_make_atlas = try api.createMethod("_Geometry", "make_atlas");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_sizes),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_atlas, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn mergePolygons2d(self: *const Self, arg_polygon_a: *const godot.PoolVector2Array, arg_polygon_b: *const godot.PoolVector2Array) !godot.Array {
        if (mbind_merge_polygons_2d == null) {
            mbind_merge_polygons_2d = try api.createMethod("_Geometry", "merge_polygons_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon_a),
            @ptrCast(*const anyopaque, arg_polygon_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_merge_polygons_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn offsetPolygon2d(self: *const Self, arg_polygon: *const godot.PoolVector2Array, arg_delta: f32, arg_join_type: i32) !godot.Array {
        if (mbind_offset_polygon_2d == null) {
            mbind_offset_polygon_2d = try api.createMethod("_Geometry", "offset_polygon_2d");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon),
            @ptrCast(*const anyopaque, *arg_delta),
            @ptrCast(*const anyopaque, *arg_join_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_offset_polygon_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn offsetPolyline2d(self: *const Self, arg_polyline: *const godot.PoolVector2Array, arg_delta: f32, arg_join_type: i32, arg_end_type: i32) !godot.Array {
        if (mbind_offset_polyline_2d == null) {
            mbind_offset_polyline_2d = try api.createMethod("_Geometry", "offset_polyline_2d");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polyline),
            @ptrCast(*const anyopaque, *arg_delta),
            @ptrCast(*const anyopaque, *arg_join_type),
            @ptrCast(*const anyopaque, *arg_end_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_offset_polyline_2d, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn pointIsInsideTriangle(self: *const Self, arg_point: *const godot.Vector2, arg_a: *const godot.Vector2, arg_b: *const godot.Vector2, arg_c: *const godot.Vector2) !bool {
        if (mbind_point_is_inside_triangle == null) {
            mbind_point_is_inside_triangle = try api.createMethod("_Geometry", "point_is_inside_triangle");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_point),
            @ptrCast(*const anyopaque, arg_a),
            @ptrCast(*const anyopaque, arg_b),
            @ptrCast(*const anyopaque, arg_c),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_point_is_inside_triangle, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn rayIntersectsTriangle(self: *const Self, arg_from: *const godot.Vector3, arg_dir: *const godot.Vector3, arg_a: *const godot.Vector3, arg_b: *const godot.Vector3, arg_c: *const godot.Vector3) !godot.Variant {
        if (mbind_ray_intersects_triangle == null) {
            mbind_ray_intersects_triangle = try api.createMethod("_Geometry", "ray_intersects_triangle");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_dir),
            @ptrCast(*const anyopaque, arg_a),
            @ptrCast(*const anyopaque, arg_b),
            @ptrCast(*const anyopaque, arg_c),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_ray_intersects_triangle, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn segmentIntersectsCircle(self: *const Self, arg_segment_from: *const godot.Vector2, arg_segment_to: *const godot.Vector2, arg_circle_position: *const godot.Vector2, arg_circle_radius: f32) !f32 {
        if (mbind_segment_intersects_circle == null) {
            mbind_segment_intersects_circle = try api.createMethod("_Geometry", "segment_intersects_circle");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_segment_from),
            @ptrCast(*const anyopaque, arg_segment_to),
            @ptrCast(*const anyopaque, arg_circle_position),
            @ptrCast(*const anyopaque, *arg_circle_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_circle, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn segmentIntersectsConvex(self: *const Self, arg_from: *const godot.Vector3, arg_to: *const godot.Vector3, arg_planes: *const godot.Array) !godot.PoolVector3Array {
        if (mbind_segment_intersects_convex == null) {
            mbind_segment_intersects_convex = try api.createMethod("_Geometry", "segment_intersects_convex");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_planes),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_convex, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn segmentIntersectsCylinder(self: *const Self, arg_from: *const godot.Vector3, arg_to: *const godot.Vector3, arg_height: f32, arg_radius: f32) !godot.PoolVector3Array {
        if (mbind_segment_intersects_cylinder == null) {
            mbind_segment_intersects_cylinder = try api.createMethod("_Geometry", "segment_intersects_cylinder");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_cylinder, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn segmentIntersectsSegment2d(self: *const Self, arg_from_a: *const godot.Vector2, arg_to_a: *const godot.Vector2, arg_from_b: *const godot.Vector2, arg_to_b: *const godot.Vector2) !godot.Variant {
        if (mbind_segment_intersects_segment_2d == null) {
            mbind_segment_intersects_segment_2d = try api.createMethod("_Geometry", "segment_intersects_segment_2d");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from_a),
            @ptrCast(*const anyopaque, arg_to_a),
            @ptrCast(*const anyopaque, arg_from_b),
            @ptrCast(*const anyopaque, arg_to_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_segment_2d, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn segmentIntersectsSphere(self: *const Self, arg_from: *const godot.Vector3, arg_to: *const godot.Vector3, arg_sphere_position: *const godot.Vector3, arg_sphere_radius: f32) !godot.PoolVector3Array {
        if (mbind_segment_intersects_sphere == null) {
            mbind_segment_intersects_sphere = try api.createMethod("_Geometry", "segment_intersects_sphere");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_sphere_position),
            @ptrCast(*const anyopaque, *arg_sphere_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_sphere, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn segmentIntersectsTriangle(self: *const Self, arg_from: *const godot.Vector3, arg_to: *const godot.Vector3, arg_a: *const godot.Vector3, arg_b: *const godot.Vector3, arg_c: *const godot.Vector3) !godot.Variant {
        if (mbind_segment_intersects_triangle == null) {
            mbind_segment_intersects_triangle = try api.createMethod("_Geometry", "segment_intersects_triangle");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_a),
            @ptrCast(*const anyopaque, arg_b),
            @ptrCast(*const anyopaque, arg_c),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_intersects_triangle, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn triangulateDelaunay2d(self: *const Self, arg_points: *const godot.PoolVector2Array) !godot.PoolIntArray {
        if (mbind_triangulate_delaunay_2d == null) {
            mbind_triangulate_delaunay_2d = try api.createMethod("_Geometry", "triangulate_delaunay_2d");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_triangulate_delaunay_2d, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn triangulatePolygon(self: *const Self, arg_polygon: *const godot.PoolVector2Array) !godot.PoolIntArray {
        if (mbind_triangulate_polygon == null) {
            mbind_triangulate_polygon = try api.createMethod("_Geometry", "triangulate_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_triangulate_polygon, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }
};