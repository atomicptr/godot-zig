// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_draw_arc: ?*c_api.godot_method_bind = null;
var mbind_draw_char: ?*c_api.godot_method_bind = null;
var mbind_draw_circle: ?*c_api.godot_method_bind = null;
var mbind_draw_colored_polygon: ?*c_api.godot_method_bind = null;
var mbind_draw_line: ?*c_api.godot_method_bind = null;
var mbind_draw_mesh: ?*c_api.godot_method_bind = null;
var mbind_draw_multiline: ?*c_api.godot_method_bind = null;
var mbind_draw_multiline_colors: ?*c_api.godot_method_bind = null;
var mbind_draw_multimesh: ?*c_api.godot_method_bind = null;
var mbind_draw_polygon: ?*c_api.godot_method_bind = null;
var mbind_draw_polyline: ?*c_api.godot_method_bind = null;
var mbind_draw_polyline_colors: ?*c_api.godot_method_bind = null;
var mbind_draw_primitive: ?*c_api.godot_method_bind = null;
var mbind_draw_rect: ?*c_api.godot_method_bind = null;
var mbind_draw_set_transform: ?*c_api.godot_method_bind = null;
var mbind_draw_set_transform_matrix: ?*c_api.godot_method_bind = null;
var mbind_draw_string: ?*c_api.godot_method_bind = null;
var mbind_draw_style_box: ?*c_api.godot_method_bind = null;
var mbind_draw_texture: ?*c_api.godot_method_bind = null;
var mbind_draw_texture_rect: ?*c_api.godot_method_bind = null;
var mbind_draw_texture_rect_region: ?*c_api.godot_method_bind = null;
var mbind_force_update_transform: ?*c_api.godot_method_bind = null;
var mbind_get_canvas: ?*c_api.godot_method_bind = null;
var mbind_get_canvas_item: ?*c_api.godot_method_bind = null;
var mbind_get_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_get_global_mouse_position: ?*c_api.godot_method_bind = null;
var mbind_get_global_transform: ?*c_api.godot_method_bind = null;
var mbind_get_global_transform_with_canvas: ?*c_api.godot_method_bind = null;
var mbind_get_light_mask: ?*c_api.godot_method_bind = null;
var mbind_get_local_mouse_position: ?*c_api.godot_method_bind = null;
var mbind_get_material: ?*c_api.godot_method_bind = null;
var mbind_get_modulate: ?*c_api.godot_method_bind = null;
var mbind_get_self_modulate: ?*c_api.godot_method_bind = null;
var mbind_get_transform: ?*c_api.godot_method_bind = null;
var mbind_get_use_parent_material: ?*c_api.godot_method_bind = null;
var mbind_get_viewport_rect: ?*c_api.godot_method_bind = null;
var mbind_get_viewport_transform: ?*c_api.godot_method_bind = null;
var mbind_get_world_2d: ?*c_api.godot_method_bind = null;
var mbind_hide: ?*c_api.godot_method_bind = null;
var mbind_is_draw_behind_parent_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_local_transform_notification_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_set_as_toplevel: ?*c_api.godot_method_bind = null;
var mbind_is_transform_notification_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_visible: ?*c_api.godot_method_bind = null;
var mbind_is_visible_in_tree: ?*c_api.godot_method_bind = null;
var mbind_make_canvas_position_local: ?*c_api.godot_method_bind = null;
var mbind_make_input_local: ?*c_api.godot_method_bind = null;
var mbind_set_as_toplevel: ?*c_api.godot_method_bind = null;
var mbind_set_draw_behind_parent: ?*c_api.godot_method_bind = null;
var mbind_set_light_mask: ?*c_api.godot_method_bind = null;
var mbind_set_material: ?*c_api.godot_method_bind = null;
var mbind_set_modulate: ?*c_api.godot_method_bind = null;
var mbind_set_notify_local_transform: ?*c_api.godot_method_bind = null;
var mbind_set_notify_transform: ?*c_api.godot_method_bind = null;
var mbind_set_self_modulate: ?*c_api.godot_method_bind = null;
var mbind_set_use_parent_material: ?*c_api.godot_method_bind = null;
var mbind_set_visible: ?*c_api.godot_method_bind = null;
var mbind_show: ?*c_api.godot_method_bind = null;
var mbind_update: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_constructor: ?fn () ?*c_api.godot_object = null;

pub const CanvasItem = struct {
    const Self = @This();
    pub const BaseClass = godot.Node;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_canvas_item_constructor == null) {
            mbind_canvas_item_constructor = try api.createConstructor("CanvasItem");
        }
        return api.createObject(Self, mbind_canvas_item_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn drawArc(self: *const Self, arg_center: *const godot.Vector2, arg_radius: f32, arg_start_angle: f32, arg_end_angle: f32, arg_point_count: i32, arg_color: *const godot.Color, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_arc == null) {
            mbind_draw_arc = try api.createMethod("CanvasItem", "draw_arc");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_center),
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, *arg_start_angle),
            @ptrCast(*const anyopaque, *arg_end_angle),
            @ptrCast(*const anyopaque, *arg_point_count),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_arc, base, cargs, result);
    }

    pub fn drawChar(self: *const Self, arg_font: *const godot.Font, arg_position: *const godot.Vector2, arg_char: *const godot.String, arg_next: *const godot.String, arg_modulate: *const godot.Color) !f32 {
        if (mbind_draw_char == null) {
            mbind_draw_char = try api.createMethod("CanvasItem", "draw_char");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_font),
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_char),
            @ptrCast(*const anyopaque, arg_next),
            @ptrCast(*const anyopaque, arg_modulate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_char, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn drawCircle(self: *const Self, arg_position: *const godot.Vector2, arg_radius: f32, arg_color: *const godot.Color) !void {
        if (mbind_draw_circle == null) {
            mbind_draw_circle = try api.createMethod("CanvasItem", "draw_circle");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_circle, base, cargs, result);
    }

    pub fn drawColoredPolygon(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_color: *const godot.Color, arg_uvs: *const godot.PoolVector2Array, arg_texture: *const godot.Texture, arg_normal_map: *const godot.Texture, arg_antialiased: bool) !void {
        if (mbind_draw_colored_polygon == null) {
            mbind_draw_colored_polygon = try api.createMethod("CanvasItem", "draw_colored_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_colored_polygon, base, cargs, result);
    }

    pub fn drawLine(self: *const Self, arg_from: *const godot.Vector2, arg_to: *const godot.Vector2, arg_color: *const godot.Color, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_line == null) {
            mbind_draw_line = try api.createMethod("CanvasItem", "draw_line");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_line, base, cargs, result);
    }

    pub fn drawMesh(self: *const Self, arg_mesh: *const godot.Mesh, arg_texture: *const godot.Texture, arg_normal_map: *const godot.Texture, arg_transform: *const godot.Transform2D, arg_modulate: *const godot.Color) !void {
        if (mbind_draw_mesh == null) {
            mbind_draw_mesh = try api.createMethod("CanvasItem", "draw_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, arg_modulate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_mesh, base, cargs, result);
    }

    pub fn drawMultiline(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_color: *const godot.Color, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_multiline == null) {
            mbind_draw_multiline = try api.createMethod("CanvasItem", "draw_multiline");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_multiline, base, cargs, result);
    }

    pub fn drawMultilineColors(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_multiline_colors == null) {
            mbind_draw_multiline_colors = try api.createMethod("CanvasItem", "draw_multiline_colors");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_multiline_colors, base, cargs, result);
    }

    pub fn drawMultimesh(self: *const Self, arg_multimesh: *const godot.MultiMesh, arg_texture: *const godot.Texture, arg_normal_map: *const godot.Texture) !void {
        if (mbind_draw_multimesh == null) {
            mbind_draw_multimesh = try api.createMethod("CanvasItem", "draw_multimesh");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_multimesh, base, cargs, result);
    }

    pub fn drawPolygon(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_uvs: *const godot.PoolVector2Array, arg_texture: *const godot.Texture, arg_normal_map: *const godot.Texture, arg_antialiased: bool) !void {
        if (mbind_draw_polygon == null) {
            mbind_draw_polygon = try api.createMethod("CanvasItem", "draw_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_polygon, base, cargs, result);
    }

    pub fn drawPolyline(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_color: *const godot.Color, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_polyline == null) {
            mbind_draw_polyline = try api.createMethod("CanvasItem", "draw_polyline");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_polyline, base, cargs, result);
    }

    pub fn drawPolylineColors(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_polyline_colors == null) {
            mbind_draw_polyline_colors = try api.createMethod("CanvasItem", "draw_polyline_colors");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_polyline_colors, base, cargs, result);
    }

    pub fn drawPrimitive(self: *const Self, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_uvs: *const godot.PoolVector2Array, arg_texture: *const godot.Texture, arg_width: f32, arg_normal_map: *const godot.Texture) !void {
        if (mbind_draw_primitive == null) {
            mbind_draw_primitive = try api.createMethod("CanvasItem", "draw_primitive");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_primitive, base, cargs, result);
    }

    pub fn drawRect(self: *const Self, arg_rect: *const godot.Rect2, arg_color: *const godot.Color, arg_filled: bool, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_draw_rect == null) {
            mbind_draw_rect = try api.createMethod("CanvasItem", "draw_rect");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_filled),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_rect, base, cargs, result);
    }

    pub fn drawSetTransform(self: *const Self, arg_position: *const godot.Vector2, arg_rotation: f32, arg_scale: *const godot.Vector2) !void {
        if (mbind_draw_set_transform == null) {
            mbind_draw_set_transform = try api.createMethod("CanvasItem", "draw_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_rotation),
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_set_transform, base, cargs, result);
    }

    pub fn drawSetTransformMatrix(self: *const Self, arg_xform: *const godot.Transform2D) !void {
        if (mbind_draw_set_transform_matrix == null) {
            mbind_draw_set_transform_matrix = try api.createMethod("CanvasItem", "draw_set_transform_matrix");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_xform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_set_transform_matrix, base, cargs, result);
    }

    pub fn drawString(self: *const Self, arg_font: *const godot.Font, arg_position: *const godot.Vector2, arg_text: *const godot.String, arg_modulate: *const godot.Color, arg_clip_w: i32) !void {
        if (mbind_draw_string == null) {
            mbind_draw_string = try api.createMethod("CanvasItem", "draw_string");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_font),
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_text),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, *arg_clip_w),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_string, base, cargs, result);
    }

    pub fn drawStyleBox(self: *const Self, arg_style_box: *const godot.StyleBox, arg_rect: *const godot.Rect2) !void {
        if (mbind_draw_style_box == null) {
            mbind_draw_style_box = try api.createMethod("CanvasItem", "draw_style_box");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_style_box),
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_style_box, base, cargs, result);
    }

    pub fn drawTexture(self: *const Self, arg_texture: *const godot.Texture, arg_position: *const godot.Vector2, arg_modulate: *const godot.Color, arg_normal_map: *const godot.Texture) !void {
        if (mbind_draw_texture == null) {
            mbind_draw_texture = try api.createMethod("CanvasItem", "draw_texture");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_texture, base, cargs, result);
    }

    pub fn drawTextureRect(self: *const Self, arg_texture: *const godot.Texture, arg_rect: *const godot.Rect2, arg_tile: bool, arg_modulate: *const godot.Color, arg_transpose: bool, arg_normal_map: *const godot.Texture) !void {
        if (mbind_draw_texture_rect == null) {
            mbind_draw_texture_rect = try api.createMethod("CanvasItem", "draw_texture_rect");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, *arg_tile),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, *arg_transpose),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_texture_rect, base, cargs, result);
    }

    pub fn drawTextureRectRegion(self: *const Self, arg_texture: *const godot.Texture, arg_rect: *const godot.Rect2, arg_src_rect: *const godot.Rect2, arg_modulate: *const godot.Color, arg_transpose: bool, arg_normal_map: *const godot.Texture, arg_clip_uv: bool) !void {
        if (mbind_draw_texture_rect_region == null) {
            mbind_draw_texture_rect_region = try api.createMethod("CanvasItem", "draw_texture_rect_region");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, *arg_transpose),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_clip_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_texture_rect_region, base, cargs, result);
    }

    pub fn forceUpdateTransform(self: *const Self) !void {
        if (mbind_force_update_transform == null) {
            mbind_force_update_transform = try api.createMethod("CanvasItem", "force_update_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_force_update_transform, base, cargs, result);
    }

    pub fn getCanvas(self: *const Self) !godot.RID {
        if (mbind_get_canvas == null) {
            mbind_get_canvas = try api.createMethod("CanvasItem", "get_canvas");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_canvas, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getCanvasItem(self: *const Self) !godot.RID {
        if (mbind_get_canvas_item == null) {
            mbind_get_canvas_item = try api.createMethod("CanvasItem", "get_canvas_item");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_canvas_item, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getCanvasTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_canvas_transform == null) {
            mbind_get_canvas_transform = try api.createMethod("CanvasItem", "get_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_canvas_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getGlobalMousePosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_global_mouse_position == null) {
            mbind_get_global_mouse_position = try api.createMethod("CanvasItem", "get_global_mouse_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_mouse_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getGlobalTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_global_transform == null) {
            mbind_get_global_transform = try api.createMethod("CanvasItem", "get_global_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getGlobalTransformWithCanvas(self: *const Self) !godot.Transform2D {
        if (mbind_get_global_transform_with_canvas == null) {
            mbind_get_global_transform_with_canvas = try api.createMethod("CanvasItem", "get_global_transform_with_canvas");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_transform_with_canvas, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getLightMask(self: *const Self) !i32 {
        if (mbind_get_light_mask == null) {
            mbind_get_light_mask = try api.createMethod("CanvasItem", "get_light_mask");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_light_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLocalMousePosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_local_mouse_position == null) {
            mbind_get_local_mouse_position = try api.createMethod("CanvasItem", "get_local_mouse_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_local_mouse_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getMaterial(self: *const Self) !godot.Material {
        if (mbind_get_material == null) {
            mbind_get_material = try api.createMethod("CanvasItem", "get_material");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_material, base, cargs, result);
        return @ptrCast(*godot.Material, @alignCast(@alignOf(&godot.Material), result)).*;
    }

    pub fn getModulate(self: *const Self) !godot.Color {
        if (mbind_get_modulate == null) {
            mbind_get_modulate = try api.createMethod("CanvasItem", "get_modulate");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_modulate, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getSelfModulate(self: *const Self) !godot.Color {
        if (mbind_get_self_modulate == null) {
            mbind_get_self_modulate = try api.createMethod("CanvasItem", "get_self_modulate");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_self_modulate, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_transform == null) {
            mbind_get_transform = try api.createMethod("CanvasItem", "get_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getUseParentMaterial(self: *const Self) !bool {
        if (mbind_get_use_parent_material == null) {
            mbind_get_use_parent_material = try api.createMethod("CanvasItem", "get_use_parent_material");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_use_parent_material, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getViewportRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_viewport_rect == null) {
            mbind_get_viewport_rect = try api.createMethod("CanvasItem", "get_viewport_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_viewport_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getViewportTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_viewport_transform == null) {
            mbind_get_viewport_transform = try api.createMethod("CanvasItem", "get_viewport_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_viewport_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getWorld2d(self: *const Self) !godot.World2D {
        if (mbind_get_world_2d == null) {
            mbind_get_world_2d = try api.createMethod("CanvasItem", "get_world_2d");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_world_2d, base, cargs, result);
        return @ptrCast(*godot.World2D, @alignCast(@alignOf(&godot.World2D), result)).*;
    }

    pub fn hide(self: *const Self) !void {
        if (mbind_hide == null) {
            mbind_hide = try api.createMethod("CanvasItem", "hide");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hide, base, cargs, result);
    }

    pub fn isDrawBehindParentEnabled(self: *const Self) !bool {
        if (mbind_is_draw_behind_parent_enabled == null) {
            mbind_is_draw_behind_parent_enabled = try api.createMethod("CanvasItem", "is_draw_behind_parent_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_draw_behind_parent_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLocalTransformNotificationEnabled(self: *const Self) !bool {
        if (mbind_is_local_transform_notification_enabled == null) {
            mbind_is_local_transform_notification_enabled = try api.createMethod("CanvasItem", "is_local_transform_notification_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_local_transform_notification_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSetAsToplevel(self: *const Self) !bool {
        if (mbind_is_set_as_toplevel == null) {
            mbind_is_set_as_toplevel = try api.createMethod("CanvasItem", "is_set_as_toplevel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_set_as_toplevel, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isTransformNotificationEnabled(self: *const Self) !bool {
        if (mbind_is_transform_notification_enabled == null) {
            mbind_is_transform_notification_enabled = try api.createMethod("CanvasItem", "is_transform_notification_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_transform_notification_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVisible(self: *const Self) !bool {
        if (mbind_is_visible == null) {
            mbind_is_visible = try api.createMethod("CanvasItem", "is_visible");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_visible, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVisibleInTree(self: *const Self) !bool {
        if (mbind_is_visible_in_tree == null) {
            mbind_is_visible_in_tree = try api.createMethod("CanvasItem", "is_visible_in_tree");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_visible_in_tree, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn makeCanvasPositionLocal(self: *const Self, arg_screen_point: *const godot.Vector2) !godot.Vector2 {
        if (mbind_make_canvas_position_local == null) {
            mbind_make_canvas_position_local = try api.createMethod("CanvasItem", "make_canvas_position_local");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_screen_point),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_canvas_position_local, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn makeInputLocal(self: *const Self, arg_event: *const godot.InputEvent) !godot.InputEvent {
        if (mbind_make_input_local == null) {
            mbind_make_input_local = try api.createMethod("CanvasItem", "make_input_local");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_event),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_input_local, base, cargs, result);
        return @ptrCast(*godot.InputEvent, @alignCast(@alignOf(&godot.InputEvent), result)).*;
    }

    pub fn setAsToplevel(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_as_toplevel == null) {
            mbind_set_as_toplevel = try api.createMethod("CanvasItem", "set_as_toplevel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_as_toplevel, base, cargs, result);
    }

    pub fn setDrawBehindParent(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_draw_behind_parent == null) {
            mbind_set_draw_behind_parent = try api.createMethod("CanvasItem", "set_draw_behind_parent");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_draw_behind_parent, base, cargs, result);
    }

    pub fn setLightMask(self: *const Self, arg_light_mask: i32) !void {
        if (mbind_set_light_mask == null) {
            mbind_set_light_mask = try api.createMethod("CanvasItem", "set_light_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_light_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_light_mask, base, cargs, result);
    }

    pub fn setMaterial(self: *const Self, arg_material: *const godot.Material) !void {
        if (mbind_set_material == null) {
            mbind_set_material = try api.createMethod("CanvasItem", "set_material");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_material, base, cargs, result);
    }

    pub fn setModulate(self: *const Self, arg_modulate: *const godot.Color) !void {
        if (mbind_set_modulate == null) {
            mbind_set_modulate = try api.createMethod("CanvasItem", "set_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_modulate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_modulate, base, cargs, result);
    }

    pub fn setNotifyLocalTransform(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_notify_local_transform == null) {
            mbind_set_notify_local_transform = try api.createMethod("CanvasItem", "set_notify_local_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_notify_local_transform, base, cargs, result);
    }

    pub fn setNotifyTransform(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_notify_transform == null) {
            mbind_set_notify_transform = try api.createMethod("CanvasItem", "set_notify_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_notify_transform, base, cargs, result);
    }

    pub fn setSelfModulate(self: *const Self, arg_self_modulate: *const godot.Color) !void {
        if (mbind_set_self_modulate == null) {
            mbind_set_self_modulate = try api.createMethod("CanvasItem", "set_self_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_self_modulate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_self_modulate, base, cargs, result);
    }

    pub fn setUseParentMaterial(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_parent_material == null) {
            mbind_set_use_parent_material = try api.createMethod("CanvasItem", "set_use_parent_material");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_parent_material, base, cargs, result);
    }

    pub fn setVisible(self: *const Self, arg_visible: bool) !void {
        if (mbind_set_visible == null) {
            mbind_set_visible = try api.createMethod("CanvasItem", "set_visible");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_visible),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_visible, base, cargs, result);
    }

    pub fn show(self: *const Self) !void {
        if (mbind_show == null) {
            mbind_show = try api.createMethod("CanvasItem", "show");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_show, base, cargs, result);
    }

    pub fn update(self: *const Self) !void {
        if (mbind_update == null) {
            mbind_update = try api.createMethod("CanvasItem", "update");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update, base, cargs, result);
    }
};