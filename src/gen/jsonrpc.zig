// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Object = @import("object.zig").Object;

// method bindings
var mbind_make_notification: ?*c_api.godot_method_bind = null;
var mbind_make_request: ?*c_api.godot_method_bind = null;
var mbind_make_response: ?*c_api.godot_method_bind = null;
var mbind_make_response_error: ?*c_api.godot_method_bind = null;
var mbind_process_action: ?*c_api.godot_method_bind = null;
var mbind_process_string: ?*c_api.godot_method_bind = null;
var mbind_set_scope: ?*c_api.godot_method_bind = null;
var mbind_jsonrpc_constructor: ?fn () ?*c_api.godot_object = null;

pub const JSONRPC = struct {
    const Self = @This();
    const BaseClass = Object;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_jsonrpc_constructor == null) {
            mbind_jsonrpc_constructor = try api.createConstructor("JSONRPC");
        }
        return api.createObject(Self, mbind_jsonrpc_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn makeNotification(self: *const Self, arg_method: *const godot.String, arg_params: *const godot.Variant) !godot.Dictionary {
        if (mbind_make_notification == null) {
            mbind_make_notification = try api.createMethod("JSONRPC", "make_notification");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_params),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_notification, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn makeRequest(self: *const Self, arg_method: *const godot.String, arg_params: *const godot.Variant, arg_id: *const godot.Variant) !godot.Dictionary {
        if (mbind_make_request == null) {
            mbind_make_request = try api.createMethod("JSONRPC", "make_request");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_params),
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_request, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn makeResponse(self: *const Self, arg_result: *const godot.Variant, arg_id: *const godot.Variant) !godot.Dictionary {
        if (mbind_make_response == null) {
            mbind_make_response = try api.createMethod("JSONRPC", "make_response");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_result),
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_response, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn makeResponseError(self: *const Self, arg_code: i32, arg_message: *const godot.String, arg_id: *const godot.Variant) !godot.Dictionary {
        if (mbind_make_response_error == null) {
            mbind_make_response_error = try api.createMethod("JSONRPC", "make_response_error");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_code),
            @ptrCast(*const anyopaque, arg_message),
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_response_error, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn processAction(self: *const Self, arg_action: *const godot.Variant, arg_recurse: bool) !godot.Variant {
        if (mbind_process_action == null) {
            mbind_process_action = try api.createMethod("JSONRPC", "process_action");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
            @ptrCast(*const anyopaque, *arg_recurse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_process_action, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn processString(self: *const Self, arg_action: *const godot.String) !godot.String {
        if (mbind_process_string == null) {
            mbind_process_string = try api.createMethod("JSONRPC", "process_string");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_process_string, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn setScope(self: *const Self, arg_scope: *const godot.String, arg_target: *const godot.Object) !void {
        if (mbind_set_scope == null) {
            mbind_set_scope = try api.createMethod("JSONRPC", "set_scope");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scope),
            @ptrCast(*const anyopaque, arg_target),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_scope, base, cargs, result);
    }
};