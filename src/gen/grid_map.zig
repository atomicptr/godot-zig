// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Spatial = @import("spatial.zig").Spatial;

// method bindings
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_clear_baked_meshes: ?*c_api.godot_method_bind = null;
var mbind_get_bake_mesh_instance: ?*c_api.godot_method_bind = null;
var mbind_get_bake_meshes: ?*c_api.godot_method_bind = null;
var mbind_get_cell_item: ?*c_api.godot_method_bind = null;
var mbind_get_cell_item_orientation: ?*c_api.godot_method_bind = null;
var mbind_get_cell_scale: ?*c_api.godot_method_bind = null;
var mbind_get_cell_size: ?*c_api.godot_method_bind = null;
var mbind_get_center_x: ?*c_api.godot_method_bind = null;
var mbind_get_center_y: ?*c_api.godot_method_bind = null;
var mbind_get_center_z: ?*c_api.godot_method_bind = null;
var mbind_get_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_get_collision_layer_bit: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_get_mesh_library: ?*c_api.godot_method_bind = null;
var mbind_get_meshes: ?*c_api.godot_method_bind = null;
var mbind_get_octant_size: ?*c_api.godot_method_bind = null;
var mbind_get_use_in_baked_light: ?*c_api.godot_method_bind = null;
var mbind_get_used_cells: ?*c_api.godot_method_bind = null;
var mbind_make_baked_meshes: ?*c_api.godot_method_bind = null;
var mbind_map_to_world: ?*c_api.godot_method_bind = null;
var mbind_resource_changed: ?*c_api.godot_method_bind = null;
var mbind_set_cell_item: ?*c_api.godot_method_bind = null;
var mbind_set_cell_scale: ?*c_api.godot_method_bind = null;
var mbind_set_cell_size: ?*c_api.godot_method_bind = null;
var mbind_set_center_x: ?*c_api.godot_method_bind = null;
var mbind_set_center_y: ?*c_api.godot_method_bind = null;
var mbind_set_center_z: ?*c_api.godot_method_bind = null;
var mbind_set_clip: ?*c_api.godot_method_bind = null;
var mbind_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_set_collision_layer_bit: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_set_mesh_library: ?*c_api.godot_method_bind = null;
var mbind_set_octant_size: ?*c_api.godot_method_bind = null;
var mbind_set_use_in_baked_light: ?*c_api.godot_method_bind = null;
var mbind_world_to_map: ?*c_api.godot_method_bind = null;
var mbind_grid_map_constructor: ?fn () ?*c_api.godot_object = null;

pub const GridMap = struct {
    const Self = @This();
    const BaseClass = Spatial;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_grid_map_constructor == null) {
            mbind_grid_map_constructor = try api.createConstructor("GridMap");
        }
        return api.createObject(Self, mbind_grid_map_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("GridMap", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn clearBakedMeshes(self: *const Self) !void {
        if (mbind_clear_baked_meshes == null) {
            mbind_clear_baked_meshes = try api.createMethod("GridMap", "clear_baked_meshes");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_baked_meshes, base, cargs, result);
    }

    pub fn getBakeMeshInstance(self: *const Self, arg_idx: i32) !godot.RID {
        if (mbind_get_bake_mesh_instance == null) {
            mbind_get_bake_mesh_instance = try api.createMethod("GridMap", "get_bake_mesh_instance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bake_mesh_instance, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getBakeMeshes(self: *const Self) !godot.Array {
        if (mbind_get_bake_meshes == null) {
            mbind_get_bake_meshes = try api.createMethod("GridMap", "get_bake_meshes");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bake_meshes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getCellItem(self: *const Self, arg_x: i32, arg_y: i32, arg_z: i32) !i32 {
        if (mbind_get_cell_item == null) {
            mbind_get_cell_item = try api.createMethod("GridMap", "get_cell_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, *arg_z),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_item, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCellItemOrientation(self: *const Self, arg_x: i32, arg_y: i32, arg_z: i32) !i32 {
        if (mbind_get_cell_item_orientation == null) {
            mbind_get_cell_item_orientation = try api.createMethod("GridMap", "get_cell_item_orientation");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, *arg_z),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_item_orientation, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCellScale(self: *const Self) !f32 {
        if (mbind_get_cell_scale == null) {
            mbind_get_cell_scale = try api.createMethod("GridMap", "get_cell_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCellSize(self: *const Self) !godot.Vector3 {
        if (mbind_get_cell_size == null) {
            mbind_get_cell_size = try api.createMethod("GridMap", "get_cell_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_size, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getCenterX(self: *const Self) !bool {
        if (mbind_get_center_x == null) {
            mbind_get_center_x = try api.createMethod("GridMap", "get_center_x");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_center_x, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCenterY(self: *const Self) !bool {
        if (mbind_get_center_y == null) {
            mbind_get_center_y = try api.createMethod("GridMap", "get_center_y");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_center_y, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCenterZ(self: *const Self) !bool {
        if (mbind_get_center_z == null) {
            mbind_get_center_z = try api.createMethod("GridMap", "get_center_z");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_center_z, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionLayer(self: *const Self) !i32 {
        if (mbind_get_collision_layer == null) {
            mbind_get_collision_layer = try api.createMethod("GridMap", "get_collision_layer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_layer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCollisionLayerBit(self: *const Self, arg_bit: i32) !bool {
        if (mbind_get_collision_layer_bit == null) {
            mbind_get_collision_layer_bit = try api.createMethod("GridMap", "get_collision_layer_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_layer_bit, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionMask(self: *const Self) !i32 {
        if (mbind_get_collision_mask == null) {
            mbind_get_collision_mask = try api.createMethod("GridMap", "get_collision_mask");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCollisionMaskBit(self: *const Self, arg_bit: i32) !bool {
        if (mbind_get_collision_mask_bit == null) {
            mbind_get_collision_mask_bit = try api.createMethod("GridMap", "get_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask_bit, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getMeshLibrary(self: *const Self) !godot.MeshLibrary {
        if (mbind_get_mesh_library == null) {
            mbind_get_mesh_library = try api.createMethod("GridMap", "get_mesh_library");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_mesh_library, base, cargs, result);
        return @ptrCast(*godot.MeshLibrary, @alignCast(@alignOf(&godot.MeshLibrary), result)).*;
    }

    pub fn getMeshes(self: *const Self) !godot.Array {
        if (mbind_get_meshes == null) {
            mbind_get_meshes = try api.createMethod("GridMap", "get_meshes");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_meshes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getOctantSize(self: *const Self) !i32 {
        if (mbind_get_octant_size == null) {
            mbind_get_octant_size = try api.createMethod("GridMap", "get_octant_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_octant_size, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getUseInBakedLight(self: *const Self) !bool {
        if (mbind_get_use_in_baked_light == null) {
            mbind_get_use_in_baked_light = try api.createMethod("GridMap", "get_use_in_baked_light");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_use_in_baked_light, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getUsedCells(self: *const Self) !godot.Array {
        if (mbind_get_used_cells == null) {
            mbind_get_used_cells = try api.createMethod("GridMap", "get_used_cells");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_used_cells, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn makeBakedMeshes(self: *const Self, arg_gen_lightmap_uv: bool, arg_lightmap_uv_texel_size: f32) !void {
        if (mbind_make_baked_meshes == null) {
            mbind_make_baked_meshes = try api.createMethod("GridMap", "make_baked_meshes");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_gen_lightmap_uv),
            @ptrCast(*const anyopaque, *arg_lightmap_uv_texel_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_baked_meshes, base, cargs, result);
    }

    pub fn mapToWorld(self: *const Self, arg_x: i32, arg_y: i32, arg_z: i32) !godot.Vector3 {
        if (mbind_map_to_world == null) {
            mbind_map_to_world = try api.createMethod("GridMap", "map_to_world");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, *arg_z),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_map_to_world, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn resourceChanged(self: *const Self, arg_resource: *const godot.Resource) !void {
        if (mbind_resource_changed == null) {
            mbind_resource_changed = try api.createMethod("GridMap", "resource_changed");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_resource),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_resource_changed, base, cargs, result);
    }

    pub fn setCellItem(self: *const Self, arg_x: i32, arg_y: i32, arg_z: i32, arg_item: i32, arg_orientation: i32) !void {
        if (mbind_set_cell_item == null) {
            mbind_set_cell_item = try api.createMethod("GridMap", "set_cell_item");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, *arg_z),
            @ptrCast(*const anyopaque, *arg_item),
            @ptrCast(*const anyopaque, *arg_orientation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_item, base, cargs, result);
    }

    pub fn setCellScale(self: *const Self, arg_scale: f32) !void {
        if (mbind_set_cell_scale == null) {
            mbind_set_cell_scale = try api.createMethod("GridMap", "set_cell_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_scale, base, cargs, result);
    }

    pub fn setCellSize(self: *const Self, arg_size: *const godot.Vector3) !void {
        if (mbind_set_cell_size == null) {
            mbind_set_cell_size = try api.createMethod("GridMap", "set_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_size, base, cargs, result);
    }

    pub fn setCenterX(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_center_x == null) {
            mbind_set_center_x = try api.createMethod("GridMap", "set_center_x");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_center_x, base, cargs, result);
    }

    pub fn setCenterY(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_center_y == null) {
            mbind_set_center_y = try api.createMethod("GridMap", "set_center_y");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_center_y, base, cargs, result);
    }

    pub fn setCenterZ(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_center_z == null) {
            mbind_set_center_z = try api.createMethod("GridMap", "set_center_z");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_center_z, base, cargs, result);
    }

    pub fn setClip(self: *const Self, arg_enabled: bool, arg_clipabove: bool, arg_floor: i32, arg_axis: i32) !void {
        if (mbind_set_clip == null) {
            mbind_set_clip = try api.createMethod("GridMap", "set_clip");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
            @ptrCast(*const anyopaque, *arg_clipabove),
            @ptrCast(*const anyopaque, *arg_floor),
            @ptrCast(*const anyopaque, *arg_axis),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clip, base, cargs, result);
    }

    pub fn setCollisionLayer(self: *const Self, arg_layer: i32) !void {
        if (mbind_set_collision_layer == null) {
            mbind_set_collision_layer = try api.createMethod("GridMap", "set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_layer, base, cargs, result);
    }

    pub fn setCollisionLayerBit(self: *const Self, arg_bit: i32, arg_value: bool) !void {
        if (mbind_set_collision_layer_bit == null) {
            mbind_set_collision_layer_bit = try api.createMethod("GridMap", "set_collision_layer_bit");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_layer_bit, base, cargs, result);
    }

    pub fn setCollisionMask(self: *const Self, arg_mask: i32) !void {
        if (mbind_set_collision_mask == null) {
            mbind_set_collision_mask = try api.createMethod("GridMap", "set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask, base, cargs, result);
    }

    pub fn setCollisionMaskBit(self: *const Self, arg_bit: i32, arg_value: bool) !void {
        if (mbind_set_collision_mask_bit == null) {
            mbind_set_collision_mask_bit = try api.createMethod("GridMap", "set_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask_bit, base, cargs, result);
    }

    pub fn setMeshLibrary(self: *const Self, arg_mesh_library: *const godot.MeshLibrary) !void {
        if (mbind_set_mesh_library == null) {
            mbind_set_mesh_library = try api.createMethod("GridMap", "set_mesh_library");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh_library),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_mesh_library, base, cargs, result);
    }

    pub fn setOctantSize(self: *const Self, arg_size: i32) !void {
        if (mbind_set_octant_size == null) {
            mbind_set_octant_size = try api.createMethod("GridMap", "set_octant_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_octant_size, base, cargs, result);
    }

    pub fn setUseInBakedLight(self: *const Self, arg_use_in_baked_light: bool) !void {
        if (mbind_set_use_in_baked_light == null) {
            mbind_set_use_in_baked_light = try api.createMethod("GridMap", "set_use_in_baked_light");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_in_baked_light),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_in_baked_light, base, cargs, result);
    }

    pub fn worldToMap(self: *const Self, arg_pos: *const godot.Vector3) !godot.Vector3 {
        if (mbind_world_to_map == null) {
            mbind_world_to_map = try api.createMethod("GridMap", "world_to_map");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_pos),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_world_to_map, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }
};