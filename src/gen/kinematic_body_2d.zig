// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const PhysicsBody2D = @import("physics_body_2d.zig").PhysicsBody2D;

// method bindings
var mbind_get_floor_angle: ?*c_api.godot_method_bind = null;
var mbind_get_floor_normal: ?*c_api.godot_method_bind = null;
var mbind_get_floor_velocity: ?*c_api.godot_method_bind = null;
var mbind_get_last_slide_collision: ?*c_api.godot_method_bind = null;
var mbind_get_safe_margin: ?*c_api.godot_method_bind = null;
var mbind_get_slide_collision: ?*c_api.godot_method_bind = null;
var mbind_get_slide_count: ?*c_api.godot_method_bind = null;
var mbind_is_on_ceiling: ?*c_api.godot_method_bind = null;
var mbind_is_on_floor: ?*c_api.godot_method_bind = null;
var mbind_is_on_wall: ?*c_api.godot_method_bind = null;
var mbind_is_sync_to_physics_enabled: ?*c_api.godot_method_bind = null;
var mbind_move_and_collide: ?*c_api.godot_method_bind = null;
var mbind_move_and_slide: ?*c_api.godot_method_bind = null;
var mbind_move_and_slide_with_snap: ?*c_api.godot_method_bind = null;
var mbind_set_safe_margin: ?*c_api.godot_method_bind = null;
var mbind_set_sync_to_physics: ?*c_api.godot_method_bind = null;
var mbind_test_move: ?*c_api.godot_method_bind = null;
var mbind_kinematic_body_2d_constructor: ?fn () ?*c_api.godot_object = null;

pub const KinematicBody2D = struct {
    const Self = @This();
    const BaseClass = PhysicsBody2D;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_kinematic_body_2d_constructor == null) {
            mbind_kinematic_body_2d_constructor = try api.createConstructor("KinematicBody2D");
        }
        return api.createObject(Self, mbind_kinematic_body_2d_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getFloorAngle(self: *const Self, arg_up_direction: *const godot.Vector2) !f32 {
        if (mbind_get_floor_angle == null) {
            mbind_get_floor_angle = try api.createMethod("KinematicBody2D", "get_floor_angle");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_up_direction),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_floor_angle, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getFloorNormal(self: *const Self) !godot.Vector2 {
        if (mbind_get_floor_normal == null) {
            mbind_get_floor_normal = try api.createMethod("KinematicBody2D", "get_floor_normal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_floor_normal, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getFloorVelocity(self: *const Self) !godot.Vector2 {
        if (mbind_get_floor_velocity == null) {
            mbind_get_floor_velocity = try api.createMethod("KinematicBody2D", "get_floor_velocity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_floor_velocity, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getLastSlideCollision(self: *const Self) !godot.KinematicCollision2D {
        if (mbind_get_last_slide_collision == null) {
            mbind_get_last_slide_collision = try api.createMethod("KinematicBody2D", "get_last_slide_collision");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_last_slide_collision, base, cargs, result);
        return @ptrCast(*godot.KinematicCollision2D, @alignCast(@alignOf(&godot.KinematicCollision2D), result)).*;
    }

    pub fn getSafeMargin(self: *const Self) !f32 {
        if (mbind_get_safe_margin == null) {
            mbind_get_safe_margin = try api.createMethod("KinematicBody2D", "get_safe_margin");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_safe_margin, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSlideCollision(self: *const Self, arg_slide_idx: i32) !godot.KinematicCollision2D {
        if (mbind_get_slide_collision == null) {
            mbind_get_slide_collision = try api.createMethod("KinematicBody2D", "get_slide_collision");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_slide_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_slide_collision, base, cargs, result);
        return @ptrCast(*godot.KinematicCollision2D, @alignCast(@alignOf(&godot.KinematicCollision2D), result)).*;
    }

    pub fn getSlideCount(self: *const Self) !i32 {
        if (mbind_get_slide_count == null) {
            mbind_get_slide_count = try api.createMethod("KinematicBody2D", "get_slide_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_slide_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn isOnCeiling(self: *const Self) !bool {
        if (mbind_is_on_ceiling == null) {
            mbind_is_on_ceiling = try api.createMethod("KinematicBody2D", "is_on_ceiling");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_on_ceiling, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOnFloor(self: *const Self) !bool {
        if (mbind_is_on_floor == null) {
            mbind_is_on_floor = try api.createMethod("KinematicBody2D", "is_on_floor");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_on_floor, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOnWall(self: *const Self) !bool {
        if (mbind_is_on_wall == null) {
            mbind_is_on_wall = try api.createMethod("KinematicBody2D", "is_on_wall");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_on_wall, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSyncToPhysicsEnabled(self: *const Self) !bool {
        if (mbind_is_sync_to_physics_enabled == null) {
            mbind_is_sync_to_physics_enabled = try api.createMethod("KinematicBody2D", "is_sync_to_physics_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_sync_to_physics_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn moveAndCollide(self: *const Self, arg_rel_vec: *const godot.Vector2, arg_infinite_inertia: bool, arg_exclude_raycast_shapes: bool, arg_test_only: bool) !godot.KinematicCollision2D {
        if (mbind_move_and_collide == null) {
            mbind_move_and_collide = try api.createMethod("KinematicBody2D", "move_and_collide");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rel_vec),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
            @ptrCast(*const anyopaque, *arg_exclude_raycast_shapes),
            @ptrCast(*const anyopaque, *arg_test_only),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_and_collide, base, cargs, result);
        return @ptrCast(*godot.KinematicCollision2D, @alignCast(@alignOf(&godot.KinematicCollision2D), result)).*;
    }

    pub fn moveAndSlide(self: *const Self, arg_linear_velocity: *const godot.Vector2, arg_up_direction: *const godot.Vector2, arg_stop_on_slope: bool, arg_max_slides: i32, arg_floor_max_angle: f32, arg_infinite_inertia: bool) !godot.Vector2 {
        if (mbind_move_and_slide == null) {
            mbind_move_and_slide = try api.createMethod("KinematicBody2D", "move_and_slide");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_linear_velocity),
            @ptrCast(*const anyopaque, arg_up_direction),
            @ptrCast(*const anyopaque, *arg_stop_on_slope),
            @ptrCast(*const anyopaque, *arg_max_slides),
            @ptrCast(*const anyopaque, *arg_floor_max_angle),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_and_slide, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn moveAndSlideWithSnap(self: *const Self, arg_linear_velocity: *const godot.Vector2, arg_snap: *const godot.Vector2, arg_up_direction: *const godot.Vector2, arg_stop_on_slope: bool, arg_max_slides: i32, arg_floor_max_angle: f32, arg_infinite_inertia: bool) !godot.Vector2 {
        if (mbind_move_and_slide_with_snap == null) {
            mbind_move_and_slide_with_snap = try api.createMethod("KinematicBody2D", "move_and_slide_with_snap");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_linear_velocity),
            @ptrCast(*const anyopaque, arg_snap),
            @ptrCast(*const anyopaque, arg_up_direction),
            @ptrCast(*const anyopaque, *arg_stop_on_slope),
            @ptrCast(*const anyopaque, *arg_max_slides),
            @ptrCast(*const anyopaque, *arg_floor_max_angle),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_and_slide_with_snap, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn setSafeMargin(self: *const Self, arg_pixels: f32) !void {
        if (mbind_set_safe_margin == null) {
            mbind_set_safe_margin = try api.createMethod("KinematicBody2D", "set_safe_margin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_pixels),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_safe_margin, base, cargs, result);
    }

    pub fn setSyncToPhysics(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_sync_to_physics == null) {
            mbind_set_sync_to_physics = try api.createMethod("KinematicBody2D", "set_sync_to_physics");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_sync_to_physics, base, cargs, result);
    }

    pub fn testMove(self: *const Self, arg_from: *const godot.Transform2D, arg_rel_vec: *const godot.Vector2, arg_infinite_inertia: bool) !bool {
        if (mbind_test_move == null) {
            mbind_test_move = try api.createMethod("KinematicBody2D", "test_move");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_rel_vec),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_test_move, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }
};