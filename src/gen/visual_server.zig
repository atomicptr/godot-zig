// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_black_bars_set_images: ?*c_api.godot_method_bind = null;
var mbind_black_bars_set_margins: ?*c_api.godot_method_bind = null;
var mbind_camera_create: ?*c_api.godot_method_bind = null;
var mbind_camera_set_cull_mask: ?*c_api.godot_method_bind = null;
var mbind_camera_set_environment: ?*c_api.godot_method_bind = null;
var mbind_camera_set_frustum: ?*c_api.godot_method_bind = null;
var mbind_camera_set_orthogonal: ?*c_api.godot_method_bind = null;
var mbind_camera_set_perspective: ?*c_api.godot_method_bind = null;
var mbind_camera_set_transform: ?*c_api.godot_method_bind = null;
var mbind_camera_set_use_vertical_aspect: ?*c_api.godot_method_bind = null;
var mbind_canvas_create: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_circle: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_clip_ignore: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_line: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_mesh: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_multimesh: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_nine_patch: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_particles: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_polygon: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_polyline: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_primitive: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_rect: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_set_transform: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_texture_rect: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_texture_rect_region: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_add_triangle_array: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_clear: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_create: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_clip: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_copy_to_backbuffer: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_custom_rect: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_distance_field_mode: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_draw_behind_parent: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_draw_index: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_light_mask: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_material: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_modulate: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_parent: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_self_modulate: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_sort_children_by_y: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_transform: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_use_parent_material: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_visible: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_z_as_relative_to_parent: ?*c_api.godot_method_bind = null;
var mbind_canvas_item_set_z_index: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_attach_to_canvas: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_create: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_attach_to_canvas: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_create: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_set_enabled: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_set_light_mask: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_set_polygon: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_occluder_set_transform: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_color: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_enabled: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_energy: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_height: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_item_cull_mask: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_item_shadow_cull_mask: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_layer_range: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_mode: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_scale: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_buffer_size: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_color: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_enabled: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_filter: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_gradient_length: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_shadow_smooth: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_texture: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_texture_offset: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_transform: ?*c_api.godot_method_bind = null;
var mbind_canvas_light_set_z_range: ?*c_api.godot_method_bind = null;
var mbind_canvas_occluder_polygon_create: ?*c_api.godot_method_bind = null;
var mbind_canvas_occluder_polygon_set_cull_mode: ?*c_api.godot_method_bind = null;
var mbind_canvas_occluder_polygon_set_shape: ?*c_api.godot_method_bind = null;
var mbind_canvas_occluder_polygon_set_shape_as_lines: ?*c_api.godot_method_bind = null;
var mbind_canvas_set_item_mirroring: ?*c_api.godot_method_bind = null;
var mbind_canvas_set_modulate: ?*c_api.godot_method_bind = null;
var mbind_directional_light_create: ?*c_api.godot_method_bind = null;
var mbind_draw: ?*c_api.godot_method_bind = null;
var mbind_environment_create: ?*c_api.godot_method_bind = null;
var mbind_environment_set_adjustment: ?*c_api.godot_method_bind = null;
var mbind_environment_set_ambient_light: ?*c_api.godot_method_bind = null;
var mbind_environment_set_background: ?*c_api.godot_method_bind = null;
var mbind_environment_set_bg_color: ?*c_api.godot_method_bind = null;
var mbind_environment_set_bg_energy: ?*c_api.godot_method_bind = null;
var mbind_environment_set_canvas_max_layer: ?*c_api.godot_method_bind = null;
var mbind_environment_set_dof_blur_far: ?*c_api.godot_method_bind = null;
var mbind_environment_set_dof_blur_near: ?*c_api.godot_method_bind = null;
var mbind_environment_set_fog: ?*c_api.godot_method_bind = null;
var mbind_environment_set_fog_depth: ?*c_api.godot_method_bind = null;
var mbind_environment_set_fog_height: ?*c_api.godot_method_bind = null;
var mbind_environment_set_glow: ?*c_api.godot_method_bind = null;
var mbind_environment_set_sky: ?*c_api.godot_method_bind = null;
var mbind_environment_set_sky_custom_fov: ?*c_api.godot_method_bind = null;
var mbind_environment_set_sky_orientation: ?*c_api.godot_method_bind = null;
var mbind_environment_set_ssao: ?*c_api.godot_method_bind = null;
var mbind_environment_set_ssr: ?*c_api.godot_method_bind = null;
var mbind_environment_set_tonemap: ?*c_api.godot_method_bind = null;
var mbind_finish: ?*c_api.godot_method_bind = null;
var mbind_force_draw: ?*c_api.godot_method_bind = null;
var mbind_force_sync: ?*c_api.godot_method_bind = null;
var mbind_free_rid: ?*c_api.godot_method_bind = null;
var mbind_get_render_info: ?*c_api.godot_method_bind = null;
var mbind_get_test_cube: ?*c_api.godot_method_bind = null;
var mbind_get_test_texture: ?*c_api.godot_method_bind = null;
var mbind_get_video_adapter_name: ?*c_api.godot_method_bind = null;
var mbind_get_video_adapter_vendor: ?*c_api.godot_method_bind = null;
var mbind_get_white_texture: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_create: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_bias: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_bounds: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_cell_size: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_dynamic_data: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_dynamic_range: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_energy: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_normal_bias: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_propagation: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_get_to_cell_xform: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_is_compressed: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_is_interior: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_bias: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_bounds: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_cell_size: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_compress: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_dynamic_data: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_dynamic_range: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_energy: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_interior: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_normal_bias: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_propagation: ?*c_api.godot_method_bind = null;
var mbind_gi_probe_set_to_cell_xform: ?*c_api.godot_method_bind = null;
var mbind_has_changed: ?*c_api.godot_method_bind = null;
var mbind_has_feature: ?*c_api.godot_method_bind = null;
var mbind_has_os_feature: ?*c_api.godot_method_bind = null;
var mbind_immediate_begin: ?*c_api.godot_method_bind = null;
var mbind_immediate_clear: ?*c_api.godot_method_bind = null;
var mbind_immediate_color: ?*c_api.godot_method_bind = null;
var mbind_immediate_create: ?*c_api.godot_method_bind = null;
var mbind_immediate_end: ?*c_api.godot_method_bind = null;
var mbind_immediate_get_material: ?*c_api.godot_method_bind = null;
var mbind_immediate_normal: ?*c_api.godot_method_bind = null;
var mbind_immediate_set_material: ?*c_api.godot_method_bind = null;
var mbind_immediate_tangent: ?*c_api.godot_method_bind = null;
var mbind_immediate_uv: ?*c_api.godot_method_bind = null;
var mbind_immediate_uv2: ?*c_api.godot_method_bind = null;
var mbind_immediate_vertex: ?*c_api.godot_method_bind = null;
var mbind_immediate_vertex_2d: ?*c_api.godot_method_bind = null;
var mbind_init: ?*c_api.godot_method_bind = null;
var mbind_instance_attach_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_instance_attach_skeleton: ?*c_api.godot_method_bind = null;
var mbind_instance_create: ?*c_api.godot_method_bind = null;
var mbind_instance_create2: ?*c_api.godot_method_bind = null;
var mbind_instance_geometry_set_as_instance_lod: ?*c_api.godot_method_bind = null;
var mbind_instance_geometry_set_cast_shadows_setting: ?*c_api.godot_method_bind = null;
var mbind_instance_geometry_set_draw_range: ?*c_api.godot_method_bind = null;
var mbind_instance_geometry_set_flag: ?*c_api.godot_method_bind = null;
var mbind_instance_geometry_set_material_override: ?*c_api.godot_method_bind = null;
var mbind_instance_set_base: ?*c_api.godot_method_bind = null;
var mbind_instance_set_blend_shape_weight: ?*c_api.godot_method_bind = null;
var mbind_instance_set_custom_aabb: ?*c_api.godot_method_bind = null;
var mbind_instance_set_exterior: ?*c_api.godot_method_bind = null;
var mbind_instance_set_extra_visibility_margin: ?*c_api.godot_method_bind = null;
var mbind_instance_set_layer_mask: ?*c_api.godot_method_bind = null;
var mbind_instance_set_scenario: ?*c_api.godot_method_bind = null;
var mbind_instance_set_surface_material: ?*c_api.godot_method_bind = null;
var mbind_instance_set_transform: ?*c_api.godot_method_bind = null;
var mbind_instance_set_use_lightmap: ?*c_api.godot_method_bind = null;
var mbind_instance_set_visible: ?*c_api.godot_method_bind = null;
var mbind_instances_cull_aabb: ?*c_api.godot_method_bind = null;
var mbind_instances_cull_convex: ?*c_api.godot_method_bind = null;
var mbind_instances_cull_ray: ?*c_api.godot_method_bind = null;
var mbind_is_render_loop_enabled: ?*c_api.godot_method_bind = null;
var mbind_light_directional_set_blend_splits: ?*c_api.godot_method_bind = null;
var mbind_light_directional_set_shadow_depth_range_mode: ?*c_api.godot_method_bind = null;
var mbind_light_directional_set_shadow_mode: ?*c_api.godot_method_bind = null;
var mbind_light_omni_set_shadow_detail: ?*c_api.godot_method_bind = null;
var mbind_light_omni_set_shadow_mode: ?*c_api.godot_method_bind = null;
var mbind_light_set_bake_mode: ?*c_api.godot_method_bind = null;
var mbind_light_set_color: ?*c_api.godot_method_bind = null;
var mbind_light_set_cull_mask: ?*c_api.godot_method_bind = null;
var mbind_light_set_negative: ?*c_api.godot_method_bind = null;
var mbind_light_set_param: ?*c_api.godot_method_bind = null;
var mbind_light_set_projector: ?*c_api.godot_method_bind = null;
var mbind_light_set_reverse_cull_face_mode: ?*c_api.godot_method_bind = null;
var mbind_light_set_shadow: ?*c_api.godot_method_bind = null;
var mbind_light_set_shadow_color: ?*c_api.godot_method_bind = null;
var mbind_light_set_use_gi: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_create: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_get_bounds: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_get_energy: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_get_octree: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_get_octree_cell_subdiv: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_get_octree_cell_transform: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_is_interior: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_bounds: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_energy: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_interior: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_octree: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_octree_cell_subdiv: ?*c_api.godot_method_bind = null;
var mbind_lightmap_capture_set_octree_cell_transform: ?*c_api.godot_method_bind = null;
var mbind_make_sphere_mesh: ?*c_api.godot_method_bind = null;
var mbind_material_create: ?*c_api.godot_method_bind = null;
var mbind_material_get_param: ?*c_api.godot_method_bind = null;
var mbind_material_get_param_default: ?*c_api.godot_method_bind = null;
var mbind_material_get_shader: ?*c_api.godot_method_bind = null;
var mbind_material_set_line_width: ?*c_api.godot_method_bind = null;
var mbind_material_set_next_pass: ?*c_api.godot_method_bind = null;
var mbind_material_set_param: ?*c_api.godot_method_bind = null;
var mbind_material_set_render_priority: ?*c_api.godot_method_bind = null;
var mbind_material_set_shader: ?*c_api.godot_method_bind = null;
var mbind_mesh_add_surface_from_arrays: ?*c_api.godot_method_bind = null;
var mbind_mesh_clear: ?*c_api.godot_method_bind = null;
var mbind_mesh_create: ?*c_api.godot_method_bind = null;
var mbind_mesh_get_blend_shape_count: ?*c_api.godot_method_bind = null;
var mbind_mesh_get_blend_shape_mode: ?*c_api.godot_method_bind = null;
var mbind_mesh_get_custom_aabb: ?*c_api.godot_method_bind = null;
var mbind_mesh_get_surface_count: ?*c_api.godot_method_bind = null;
var mbind_mesh_remove_surface: ?*c_api.godot_method_bind = null;
var mbind_mesh_set_blend_shape_count: ?*c_api.godot_method_bind = null;
var mbind_mesh_set_blend_shape_mode: ?*c_api.godot_method_bind = null;
var mbind_mesh_set_custom_aabb: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_aabb: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_array: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_array_index_len: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_array_len: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_arrays: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_blend_shape_arrays: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_format: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_format_offset: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_format_stride: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_index_array: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_material: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_primitive_type: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_get_skeleton_aabb: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_set_material: ?*c_api.godot_method_bind = null;
var mbind_mesh_surface_update_region: ?*c_api.godot_method_bind = null;
var mbind_multimesh_allocate: ?*c_api.godot_method_bind = null;
var mbind_multimesh_create: ?*c_api.godot_method_bind = null;
var mbind_multimesh_get_aabb: ?*c_api.godot_method_bind = null;
var mbind_multimesh_get_instance_count: ?*c_api.godot_method_bind = null;
var mbind_multimesh_get_mesh: ?*c_api.godot_method_bind = null;
var mbind_multimesh_get_visible_instances: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_get_color: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_get_custom_data: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_get_transform: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_get_transform_2d: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_set_color: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_set_custom_data: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_set_transform: ?*c_api.godot_method_bind = null;
var mbind_multimesh_instance_set_transform_2d: ?*c_api.godot_method_bind = null;
var mbind_multimesh_set_as_bulk_array: ?*c_api.godot_method_bind = null;
var mbind_multimesh_set_mesh: ?*c_api.godot_method_bind = null;
var mbind_multimesh_set_visible_instances: ?*c_api.godot_method_bind = null;
var mbind_omni_light_create: ?*c_api.godot_method_bind = null;
var mbind_particles_create: ?*c_api.godot_method_bind = null;
var mbind_particles_get_current_aabb: ?*c_api.godot_method_bind = null;
var mbind_particles_get_emitting: ?*c_api.godot_method_bind = null;
var mbind_particles_is_inactive: ?*c_api.godot_method_bind = null;
var mbind_particles_request_process: ?*c_api.godot_method_bind = null;
var mbind_particles_restart: ?*c_api.godot_method_bind = null;
var mbind_particles_set_amount: ?*c_api.godot_method_bind = null;
var mbind_particles_set_custom_aabb: ?*c_api.godot_method_bind = null;
var mbind_particles_set_draw_order: ?*c_api.godot_method_bind = null;
var mbind_particles_set_draw_pass_mesh: ?*c_api.godot_method_bind = null;
var mbind_particles_set_draw_passes: ?*c_api.godot_method_bind = null;
var mbind_particles_set_emission_transform: ?*c_api.godot_method_bind = null;
var mbind_particles_set_emitting: ?*c_api.godot_method_bind = null;
var mbind_particles_set_explosiveness_ratio: ?*c_api.godot_method_bind = null;
var mbind_particles_set_fixed_fps: ?*c_api.godot_method_bind = null;
var mbind_particles_set_fractional_delta: ?*c_api.godot_method_bind = null;
var mbind_particles_set_lifetime: ?*c_api.godot_method_bind = null;
var mbind_particles_set_one_shot: ?*c_api.godot_method_bind = null;
var mbind_particles_set_pre_process_time: ?*c_api.godot_method_bind = null;
var mbind_particles_set_process_material: ?*c_api.godot_method_bind = null;
var mbind_particles_set_randomness_ratio: ?*c_api.godot_method_bind = null;
var mbind_particles_set_speed_scale: ?*c_api.godot_method_bind = null;
var mbind_particles_set_use_local_coordinates: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_create: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_as_interior: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_cull_mask: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_enable_box_projection: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_enable_shadows: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_extents: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_intensity: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_interior_ambient: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_interior_ambient_energy: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_interior_ambient_probe_contribution: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_max_distance: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_origin_offset: ?*c_api.godot_method_bind = null;
var mbind_reflection_probe_set_update_mode: ?*c_api.godot_method_bind = null;
var mbind_request_frame_drawn_callback: ?*c_api.godot_method_bind = null;
var mbind_scenario_create: ?*c_api.godot_method_bind = null;
var mbind_scenario_set_debug: ?*c_api.godot_method_bind = null;
var mbind_scenario_set_environment: ?*c_api.godot_method_bind = null;
var mbind_scenario_set_fallback_environment: ?*c_api.godot_method_bind = null;
var mbind_scenario_set_reflection_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_set_boot_image: ?*c_api.godot_method_bind = null;
var mbind_set_debug_generate_wireframes: ?*c_api.godot_method_bind = null;
var mbind_set_default_clear_color: ?*c_api.godot_method_bind = null;
var mbind_set_render_loop_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_shader_time_scale: ?*c_api.godot_method_bind = null;
var mbind_set_use_occlusion_culling: ?*c_api.godot_method_bind = null;
var mbind_shader_create: ?*c_api.godot_method_bind = null;
var mbind_shader_get_code: ?*c_api.godot_method_bind = null;
var mbind_shader_get_default_texture_param: ?*c_api.godot_method_bind = null;
var mbind_shader_get_param_list: ?*c_api.godot_method_bind = null;
var mbind_shader_set_code: ?*c_api.godot_method_bind = null;
var mbind_shader_set_default_texture_param: ?*c_api.godot_method_bind = null;
var mbind_skeleton_allocate: ?*c_api.godot_method_bind = null;
var mbind_skeleton_bone_get_transform: ?*c_api.godot_method_bind = null;
var mbind_skeleton_bone_get_transform_2d: ?*c_api.godot_method_bind = null;
var mbind_skeleton_bone_set_transform: ?*c_api.godot_method_bind = null;
var mbind_skeleton_bone_set_transform_2d: ?*c_api.godot_method_bind = null;
var mbind_skeleton_create: ?*c_api.godot_method_bind = null;
var mbind_skeleton_get_bone_count: ?*c_api.godot_method_bind = null;
var mbind_sky_create: ?*c_api.godot_method_bind = null;
var mbind_sky_set_texture: ?*c_api.godot_method_bind = null;
var mbind_spot_light_create: ?*c_api.godot_method_bind = null;
var mbind_sync: ?*c_api.godot_method_bind = null;
var mbind_texture_allocate: ?*c_api.godot_method_bind = null;
var mbind_texture_bind: ?*c_api.godot_method_bind = null;
var mbind_texture_create: ?*c_api.godot_method_bind = null;
var mbind_texture_create_from_image: ?*c_api.godot_method_bind = null;
var mbind_texture_debug_usage: ?*c_api.godot_method_bind = null;
var mbind_texture_get_data: ?*c_api.godot_method_bind = null;
var mbind_texture_get_depth: ?*c_api.godot_method_bind = null;
var mbind_texture_get_flags: ?*c_api.godot_method_bind = null;
var mbind_texture_get_format: ?*c_api.godot_method_bind = null;
var mbind_texture_get_height: ?*c_api.godot_method_bind = null;
var mbind_texture_get_path: ?*c_api.godot_method_bind = null;
var mbind_texture_get_texid: ?*c_api.godot_method_bind = null;
var mbind_texture_get_type: ?*c_api.godot_method_bind = null;
var mbind_texture_get_width: ?*c_api.godot_method_bind = null;
var mbind_texture_set_data: ?*c_api.godot_method_bind = null;
var mbind_texture_set_data_partial: ?*c_api.godot_method_bind = null;
var mbind_texture_set_flags: ?*c_api.godot_method_bind = null;
var mbind_texture_set_path: ?*c_api.godot_method_bind = null;
var mbind_texture_set_shrink_all_x2_on_set_data: ?*c_api.godot_method_bind = null;
var mbind_texture_set_size_override: ?*c_api.godot_method_bind = null;
var mbind_textures_keep_original: ?*c_api.godot_method_bind = null;
var mbind_viewport_attach_camera: ?*c_api.godot_method_bind = null;
var mbind_viewport_attach_canvas: ?*c_api.godot_method_bind = null;
var mbind_viewport_attach_to_screen: ?*c_api.godot_method_bind = null;
var mbind_viewport_create: ?*c_api.godot_method_bind = null;
var mbind_viewport_detach: ?*c_api.godot_method_bind = null;
var mbind_viewport_get_render_info: ?*c_api.godot_method_bind = null;
var mbind_viewport_get_texture: ?*c_api.godot_method_bind = null;
var mbind_viewport_remove_canvas: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_active: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_canvas_stacking: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_clear_mode: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_debug_draw: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_disable_3d: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_disable_environment: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_global_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_hdr: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_hide_canvas: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_hide_scenario: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_msaa: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_parent_viewport: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_render_direct_to_screen: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_scenario: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_shadow_atlas_quadrant_subdivision: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_shadow_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_sharpen_intensity: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_size: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_transparent_background: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_update_mode: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_usage: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_use_arvr: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_use_debanding: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_use_fxaa: ?*c_api.godot_method_bind = null;
var mbind_viewport_set_vflip: ?*c_api.godot_method_bind = null;
var mbind_visual_server_constructor: ?fn () ?*c_api.godot_object = null;

pub const VisualServer = struct {
    const Self = @This();
    pub const BaseClass = godot.Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_visual_server_constructor == null) {
            mbind_visual_server_constructor = try api.createConstructor("VisualServer");
        }
        return api.createObject(Self, mbind_visual_server_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn blackBarsSetImages(self: *const Self, arg_left: *const godot.RID, arg_top: *const godot.RID, arg_right: *const godot.RID, arg_bottom: *const godot.RID) !void {
        if (mbind_black_bars_set_images == null) {
            mbind_black_bars_set_images = try api.createMethod("VisualServer", "black_bars_set_images");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_left),
            @ptrCast(*const anyopaque, arg_top),
            @ptrCast(*const anyopaque, arg_right),
            @ptrCast(*const anyopaque, arg_bottom),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_black_bars_set_images, base, cargs, result);
    }

    pub fn blackBarsSetMargins(self: *const Self, arg_left: i32, arg_top: i32, arg_right: i32, arg_bottom: i32) !void {
        if (mbind_black_bars_set_margins == null) {
            mbind_black_bars_set_margins = try api.createMethod("VisualServer", "black_bars_set_margins");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_left),
            @ptrCast(*const anyopaque, *arg_top),
            @ptrCast(*const anyopaque, *arg_right),
            @ptrCast(*const anyopaque, *arg_bottom),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_black_bars_set_margins, base, cargs, result);
    }

    pub fn cameraCreate(self: *const Self) !godot.RID {
        if (mbind_camera_create == null) {
            mbind_camera_create = try api.createMethod("VisualServer", "camera_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn cameraSetCullMask(self: *const Self, arg_camera: *const godot.RID, arg_layers: i32) !void {
        if (mbind_camera_set_cull_mask == null) {
            mbind_camera_set_cull_mask = try api.createMethod("VisualServer", "camera_set_cull_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, *arg_layers),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_cull_mask, base, cargs, result);
    }

    pub fn cameraSetEnvironment(self: *const Self, arg_camera: *const godot.RID, arg_env: *const godot.RID) !void {
        if (mbind_camera_set_environment == null) {
            mbind_camera_set_environment = try api.createMethod("VisualServer", "camera_set_environment");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, arg_env),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_environment, base, cargs, result);
    }

    pub fn cameraSetFrustum(self: *const Self, arg_camera: *const godot.RID, arg_size: f32, arg_offset: *const godot.Vector2, arg_z_near: f32, arg_z_far: f32) !void {
        if (mbind_camera_set_frustum == null) {
            mbind_camera_set_frustum = try api.createMethod("VisualServer", "camera_set_frustum");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, *arg_size),
            @ptrCast(*const anyopaque, arg_offset),
            @ptrCast(*const anyopaque, *arg_z_near),
            @ptrCast(*const anyopaque, *arg_z_far),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_frustum, base, cargs, result);
    }

    pub fn cameraSetOrthogonal(self: *const Self, arg_camera: *const godot.RID, arg_size: f32, arg_z_near: f32, arg_z_far: f32) !void {
        if (mbind_camera_set_orthogonal == null) {
            mbind_camera_set_orthogonal = try api.createMethod("VisualServer", "camera_set_orthogonal");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, *arg_size),
            @ptrCast(*const anyopaque, *arg_z_near),
            @ptrCast(*const anyopaque, *arg_z_far),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_orthogonal, base, cargs, result);
    }

    pub fn cameraSetPerspective(self: *const Self, arg_camera: *const godot.RID, arg_fovy_degrees: f32, arg_z_near: f32, arg_z_far: f32) !void {
        if (mbind_camera_set_perspective == null) {
            mbind_camera_set_perspective = try api.createMethod("VisualServer", "camera_set_perspective");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, *arg_fovy_degrees),
            @ptrCast(*const anyopaque, *arg_z_near),
            @ptrCast(*const anyopaque, *arg_z_far),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_perspective, base, cargs, result);
    }

    pub fn cameraSetTransform(self: *const Self, arg_camera: *const godot.RID, arg_transform: *const godot.Transform) !void {
        if (mbind_camera_set_transform == null) {
            mbind_camera_set_transform = try api.createMethod("VisualServer", "camera_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_transform, base, cargs, result);
    }

    pub fn cameraSetUseVerticalAspect(self: *const Self, arg_camera: *const godot.RID, arg_enable: bool) !void {
        if (mbind_camera_set_use_vertical_aspect == null) {
            mbind_camera_set_use_vertical_aspect = try api.createMethod("VisualServer", "camera_set_use_vertical_aspect");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_camera),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_camera_set_use_vertical_aspect, base, cargs, result);
    }

    pub fn canvasCreate(self: *const Self) !godot.RID {
        if (mbind_canvas_create == null) {
            mbind_canvas_create = try api.createMethod("VisualServer", "canvas_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn canvasItemAddCircle(self: *const Self, arg_item: *const godot.RID, arg_pos: *const godot.Vector2, arg_radius: f32, arg_color: *const godot.Color) !void {
        if (mbind_canvas_item_add_circle == null) {
            mbind_canvas_item_add_circle = try api.createMethod("VisualServer", "canvas_item_add_circle");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_pos),
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_circle, base, cargs, result);
    }

    pub fn canvasItemAddClipIgnore(self: *const Self, arg_item: *const godot.RID, arg_ignore: bool) !void {
        if (mbind_canvas_item_add_clip_ignore == null) {
            mbind_canvas_item_add_clip_ignore = try api.createMethod("VisualServer", "canvas_item_add_clip_ignore");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_ignore),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_clip_ignore, base, cargs, result);
    }

    pub fn canvasItemAddLine(self: *const Self, arg_item: *const godot.RID, arg_from: *const godot.Vector2, arg_to: *const godot.Vector2, arg_color: *const godot.Color, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_canvas_item_add_line == null) {
            mbind_canvas_item_add_line = try api.createMethod("VisualServer", "canvas_item_add_line");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_line, base, cargs, result);
    }

    pub fn canvasItemAddMesh(self: *const Self, arg_item: *const godot.RID, arg_mesh: *const godot.RID, arg_transform: *const godot.Transform2D, arg_modulate: *const godot.Color, arg_texture: *const godot.RID, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_mesh == null) {
            mbind_canvas_item_add_mesh = try api.createMethod("VisualServer", "canvas_item_add_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_mesh, base, cargs, result);
    }

    pub fn canvasItemAddMultimesh(self: *const Self, arg_item: *const godot.RID, arg_mesh: *const godot.RID, arg_texture: *const godot.RID, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_multimesh == null) {
            mbind_canvas_item_add_multimesh = try api.createMethod("VisualServer", "canvas_item_add_multimesh");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_multimesh, base, cargs, result);
    }

    pub fn canvasItemAddNinePatch(self: *const Self, arg_item: *const godot.RID, arg_rect: *const godot.Rect2, arg_source: *const godot.Rect2, arg_texture: *const godot.RID, arg_topleft: *const godot.Vector2, arg_bottomright: *const godot.Vector2, arg_x_axis_mode: i32, arg_y_axis_mode: i32, arg_draw_center: bool, arg_modulate: *const godot.Color, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_nine_patch == null) {
            mbind_canvas_item_add_nine_patch = try api.createMethod("VisualServer", "canvas_item_add_nine_patch");
        }

        var result: ?*anyopaque = null;
        var args: [11]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_source),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_topleft),
            @ptrCast(*const anyopaque, arg_bottomright),
            @ptrCast(*const anyopaque, *arg_x_axis_mode),
            @ptrCast(*const anyopaque, *arg_y_axis_mode),
            @ptrCast(*const anyopaque, *arg_draw_center),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_nine_patch, base, cargs, result);
    }

    pub fn canvasItemAddParticles(self: *const Self, arg_item: *const godot.RID, arg_particles: *const godot.RID, arg_texture: *const godot.RID, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_particles == null) {
            mbind_canvas_item_add_particles = try api.createMethod("VisualServer", "canvas_item_add_particles");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_particles, base, cargs, result);
    }

    pub fn canvasItemAddPolygon(self: *const Self, arg_item: *const godot.RID, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_uvs: *const godot.PoolVector2Array, arg_texture: *const godot.RID, arg_normal_map: *const godot.RID, arg_antialiased: bool) !void {
        if (mbind_canvas_item_add_polygon == null) {
            mbind_canvas_item_add_polygon = try api.createMethod("VisualServer", "canvas_item_add_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_polygon, base, cargs, result);
    }

    pub fn canvasItemAddPolyline(self: *const Self, arg_item: *const godot.RID, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_width: f32, arg_antialiased: bool) !void {
        if (mbind_canvas_item_add_polyline == null) {
            mbind_canvas_item_add_polyline = try api.createMethod("VisualServer", "canvas_item_add_polyline");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_polyline, base, cargs, result);
    }

    pub fn canvasItemAddPrimitive(self: *const Self, arg_item: *const godot.RID, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_uvs: *const godot.PoolVector2Array, arg_texture: *const godot.RID, arg_width: f32, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_primitive == null) {
            mbind_canvas_item_add_primitive = try api.createMethod("VisualServer", "canvas_item_add_primitive");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_primitive, base, cargs, result);
    }

    pub fn canvasItemAddRect(self: *const Self, arg_item: *const godot.RID, arg_rect: *const godot.Rect2, arg_color: *const godot.Color) !void {
        if (mbind_canvas_item_add_rect == null) {
            mbind_canvas_item_add_rect = try api.createMethod("VisualServer", "canvas_item_add_rect");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_rect, base, cargs, result);
    }

    pub fn canvasItemAddSetTransform(self: *const Self, arg_item: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_canvas_item_add_set_transform == null) {
            mbind_canvas_item_add_set_transform = try api.createMethod("VisualServer", "canvas_item_add_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_set_transform, base, cargs, result);
    }

    pub fn canvasItemAddTextureRect(self: *const Self, arg_item: *const godot.RID, arg_rect: *const godot.Rect2, arg_texture: *const godot.RID, arg_tile: bool, arg_modulate: *const godot.Color, arg_transpose: bool, arg_normal_map: *const godot.RID) !void {
        if (mbind_canvas_item_add_texture_rect == null) {
            mbind_canvas_item_add_texture_rect = try api.createMethod("VisualServer", "canvas_item_add_texture_rect");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_tile),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, *arg_transpose),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_texture_rect, base, cargs, result);
    }

    pub fn canvasItemAddTextureRectRegion(self: *const Self, arg_item: *const godot.RID, arg_rect: *const godot.Rect2, arg_texture: *const godot.RID, arg_src_rect: *const godot.Rect2, arg_modulate: *const godot.Color, arg_transpose: bool, arg_normal_map: *const godot.RID, arg_clip_uv: bool) !void {
        if (mbind_canvas_item_add_texture_rect_region == null) {
            mbind_canvas_item_add_texture_rect_region = try api.createMethod("VisualServer", "canvas_item_add_texture_rect_region");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_modulate),
            @ptrCast(*const anyopaque, *arg_transpose),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_clip_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_texture_rect_region, base, cargs, result);
    }

    pub fn canvasItemAddTriangleArray(self: *const Self, arg_item: *const godot.RID, arg_indices: *const godot.PoolIntArray, arg_points: *const godot.PoolVector2Array, arg_colors: *const godot.PoolColorArray, arg_uvs: *const godot.PoolVector2Array, arg_bones: *const godot.PoolIntArray, arg_weights: *const godot.PoolRealArray, arg_texture: *const godot.RID, arg_count: i32, arg_normal_map: *const godot.RID, arg_antialiased: bool, arg_antialiasing_use_indices: bool) !void {
        if (mbind_canvas_item_add_triangle_array == null) {
            mbind_canvas_item_add_triangle_array = try api.createMethod("VisualServer", "canvas_item_add_triangle_array");
        }

        var result: ?*anyopaque = null;
        var args: [12]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_indices),
            @ptrCast(*const anyopaque, arg_points),
            @ptrCast(*const anyopaque, arg_colors),
            @ptrCast(*const anyopaque, arg_uvs),
            @ptrCast(*const anyopaque, arg_bones),
            @ptrCast(*const anyopaque, arg_weights),
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_count),
            @ptrCast(*const anyopaque, arg_normal_map),
            @ptrCast(*const anyopaque, *arg_antialiased),
            @ptrCast(*const anyopaque, *arg_antialiasing_use_indices),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_add_triangle_array, base, cargs, result);
    }

    pub fn canvasItemClear(self: *const Self, arg_item: *const godot.RID) !void {
        if (mbind_canvas_item_clear == null) {
            mbind_canvas_item_clear = try api.createMethod("VisualServer", "canvas_item_clear");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_clear, base, cargs, result);
    }

    pub fn canvasItemCreate(self: *const Self) !godot.RID {
        if (mbind_canvas_item_create == null) {
            mbind_canvas_item_create = try api.createMethod("VisualServer", "canvas_item_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn canvasItemSetClip(self: *const Self, arg_item: *const godot.RID, arg_clip: bool) !void {
        if (mbind_canvas_item_set_clip == null) {
            mbind_canvas_item_set_clip = try api.createMethod("VisualServer", "canvas_item_set_clip");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_clip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_clip, base, cargs, result);
    }

    pub fn canvasItemSetCopyToBackbuffer(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool, arg_rect: *const godot.Rect2) !void {
        if (mbind_canvas_item_set_copy_to_backbuffer == null) {
            mbind_canvas_item_set_copy_to_backbuffer = try api.createMethod("VisualServer", "canvas_item_set_copy_to_backbuffer");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_copy_to_backbuffer, base, cargs, result);
    }

    pub fn canvasItemSetCustomRect(self: *const Self, arg_item: *const godot.RID, arg_use_custom_rect: bool, arg_rect: *const godot.Rect2) !void {
        if (mbind_canvas_item_set_custom_rect == null) {
            mbind_canvas_item_set_custom_rect = try api.createMethod("VisualServer", "canvas_item_set_custom_rect");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_use_custom_rect),
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_custom_rect, base, cargs, result);
    }

    pub fn canvasItemSetDistanceFieldMode(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_item_set_distance_field_mode == null) {
            mbind_canvas_item_set_distance_field_mode = try api.createMethod("VisualServer", "canvas_item_set_distance_field_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_distance_field_mode, base, cargs, result);
    }

    pub fn canvasItemSetDrawBehindParent(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_item_set_draw_behind_parent == null) {
            mbind_canvas_item_set_draw_behind_parent = try api.createMethod("VisualServer", "canvas_item_set_draw_behind_parent");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_draw_behind_parent, base, cargs, result);
    }

    pub fn canvasItemSetDrawIndex(self: *const Self, arg_item: *const godot.RID, arg_index: i32) !void {
        if (mbind_canvas_item_set_draw_index == null) {
            mbind_canvas_item_set_draw_index = try api.createMethod("VisualServer", "canvas_item_set_draw_index");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_draw_index, base, cargs, result);
    }

    pub fn canvasItemSetLightMask(self: *const Self, arg_item: *const godot.RID, arg_mask: i32) !void {
        if (mbind_canvas_item_set_light_mask == null) {
            mbind_canvas_item_set_light_mask = try api.createMethod("VisualServer", "canvas_item_set_light_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_light_mask, base, cargs, result);
    }

    pub fn canvasItemSetMaterial(self: *const Self, arg_item: *const godot.RID, arg_material: *const godot.RID) !void {
        if (mbind_canvas_item_set_material == null) {
            mbind_canvas_item_set_material = try api.createMethod("VisualServer", "canvas_item_set_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_material, base, cargs, result);
    }

    pub fn canvasItemSetModulate(self: *const Self, arg_item: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_canvas_item_set_modulate == null) {
            mbind_canvas_item_set_modulate = try api.createMethod("VisualServer", "canvas_item_set_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_modulate, base, cargs, result);
    }

    pub fn canvasItemSetParent(self: *const Self, arg_item: *const godot.RID, arg_parent: *const godot.RID) !void {
        if (mbind_canvas_item_set_parent == null) {
            mbind_canvas_item_set_parent = try api.createMethod("VisualServer", "canvas_item_set_parent");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_parent),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_parent, base, cargs, result);
    }

    pub fn canvasItemSetSelfModulate(self: *const Self, arg_item: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_canvas_item_set_self_modulate == null) {
            mbind_canvas_item_set_self_modulate = try api.createMethod("VisualServer", "canvas_item_set_self_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_self_modulate, base, cargs, result);
    }

    pub fn canvasItemSetSortChildrenByY(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_item_set_sort_children_by_y == null) {
            mbind_canvas_item_set_sort_children_by_y = try api.createMethod("VisualServer", "canvas_item_set_sort_children_by_y");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_sort_children_by_y, base, cargs, result);
    }

    pub fn canvasItemSetTransform(self: *const Self, arg_item: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_canvas_item_set_transform == null) {
            mbind_canvas_item_set_transform = try api.createMethod("VisualServer", "canvas_item_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_transform, base, cargs, result);
    }

    pub fn canvasItemSetUseParentMaterial(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_item_set_use_parent_material == null) {
            mbind_canvas_item_set_use_parent_material = try api.createMethod("VisualServer", "canvas_item_set_use_parent_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_use_parent_material, base, cargs, result);
    }

    pub fn canvasItemSetVisible(self: *const Self, arg_item: *const godot.RID, arg_visible: bool) !void {
        if (mbind_canvas_item_set_visible == null) {
            mbind_canvas_item_set_visible = try api.createMethod("VisualServer", "canvas_item_set_visible");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_visible),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_visible, base, cargs, result);
    }

    pub fn canvasItemSetZAsRelativeToParent(self: *const Self, arg_item: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_item_set_z_as_relative_to_parent == null) {
            mbind_canvas_item_set_z_as_relative_to_parent = try api.createMethod("VisualServer", "canvas_item_set_z_as_relative_to_parent");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_z_as_relative_to_parent, base, cargs, result);
    }

    pub fn canvasItemSetZIndex(self: *const Self, arg_item: *const godot.RID, arg_z_index: i32) !void {
        if (mbind_canvas_item_set_z_index == null) {
            mbind_canvas_item_set_z_index = try api.createMethod("VisualServer", "canvas_item_set_z_index");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, *arg_z_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_item_set_z_index, base, cargs, result);
    }

    pub fn canvasLightAttachToCanvas(self: *const Self, arg_light: *const godot.RID, arg_canvas: *const godot.RID) !void {
        if (mbind_canvas_light_attach_to_canvas == null) {
            mbind_canvas_light_attach_to_canvas = try api.createMethod("VisualServer", "canvas_light_attach_to_canvas");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_canvas),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_attach_to_canvas, base, cargs, result);
    }

    pub fn canvasLightCreate(self: *const Self) !godot.RID {
        if (mbind_canvas_light_create == null) {
            mbind_canvas_light_create = try api.createMethod("VisualServer", "canvas_light_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn canvasLightOccluderAttachToCanvas(self: *const Self, arg_occluder: *const godot.RID, arg_canvas: *const godot.RID) !void {
        if (mbind_canvas_light_occluder_attach_to_canvas == null) {
            mbind_canvas_light_occluder_attach_to_canvas = try api.createMethod("VisualServer", "canvas_light_occluder_attach_to_canvas");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder),
            @ptrCast(*const anyopaque, arg_canvas),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_attach_to_canvas, base, cargs, result);
    }

    pub fn canvasLightOccluderCreate(self: *const Self) !godot.RID {
        if (mbind_canvas_light_occluder_create == null) {
            mbind_canvas_light_occluder_create = try api.createMethod("VisualServer", "canvas_light_occluder_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn canvasLightOccluderSetEnabled(self: *const Self, arg_occluder: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_light_occluder_set_enabled == null) {
            mbind_canvas_light_occluder_set_enabled = try api.createMethod("VisualServer", "canvas_light_occluder_set_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_set_enabled, base, cargs, result);
    }

    pub fn canvasLightOccluderSetLightMask(self: *const Self, arg_occluder: *const godot.RID, arg_mask: i32) !void {
        if (mbind_canvas_light_occluder_set_light_mask == null) {
            mbind_canvas_light_occluder_set_light_mask = try api.createMethod("VisualServer", "canvas_light_occluder_set_light_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_set_light_mask, base, cargs, result);
    }

    pub fn canvasLightOccluderSetPolygon(self: *const Self, arg_occluder: *const godot.RID, arg_polygon: *const godot.RID) !void {
        if (mbind_canvas_light_occluder_set_polygon == null) {
            mbind_canvas_light_occluder_set_polygon = try api.createMethod("VisualServer", "canvas_light_occluder_set_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder),
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_set_polygon, base, cargs, result);
    }

    pub fn canvasLightOccluderSetTransform(self: *const Self, arg_occluder: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_canvas_light_occluder_set_transform == null) {
            mbind_canvas_light_occluder_set_transform = try api.createMethod("VisualServer", "canvas_light_occluder_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_occluder_set_transform, base, cargs, result);
    }

    pub fn canvasLightSetColor(self: *const Self, arg_light: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_canvas_light_set_color == null) {
            mbind_canvas_light_set_color = try api.createMethod("VisualServer", "canvas_light_set_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_color, base, cargs, result);
    }

    pub fn canvasLightSetEnabled(self: *const Self, arg_light: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_light_set_enabled == null) {
            mbind_canvas_light_set_enabled = try api.createMethod("VisualServer", "canvas_light_set_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_enabled, base, cargs, result);
    }

    pub fn canvasLightSetEnergy(self: *const Self, arg_light: *const godot.RID, arg_energy: f32) !void {
        if (mbind_canvas_light_set_energy == null) {
            mbind_canvas_light_set_energy = try api.createMethod("VisualServer", "canvas_light_set_energy");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_energy, base, cargs, result);
    }

    pub fn canvasLightSetHeight(self: *const Self, arg_light: *const godot.RID, arg_height: f32) !void {
        if (mbind_canvas_light_set_height == null) {
            mbind_canvas_light_set_height = try api.createMethod("VisualServer", "canvas_light_set_height");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_height),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_height, base, cargs, result);
    }

    pub fn canvasLightSetItemCullMask(self: *const Self, arg_light: *const godot.RID, arg_mask: i32) !void {
        if (mbind_canvas_light_set_item_cull_mask == null) {
            mbind_canvas_light_set_item_cull_mask = try api.createMethod("VisualServer", "canvas_light_set_item_cull_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_item_cull_mask, base, cargs, result);
    }

    pub fn canvasLightSetItemShadowCullMask(self: *const Self, arg_light: *const godot.RID, arg_mask: i32) !void {
        if (mbind_canvas_light_set_item_shadow_cull_mask == null) {
            mbind_canvas_light_set_item_shadow_cull_mask = try api.createMethod("VisualServer", "canvas_light_set_item_shadow_cull_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_item_shadow_cull_mask, base, cargs, result);
    }

    pub fn canvasLightSetLayerRange(self: *const Self, arg_light: *const godot.RID, arg_min_layer: i32, arg_max_layer: i32) !void {
        if (mbind_canvas_light_set_layer_range == null) {
            mbind_canvas_light_set_layer_range = try api.createMethod("VisualServer", "canvas_light_set_layer_range");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_min_layer),
            @ptrCast(*const anyopaque, *arg_max_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_layer_range, base, cargs, result);
    }

    pub fn canvasLightSetMode(self: *const Self, arg_light: *const godot.RID, arg_mode: i32) !void {
        if (mbind_canvas_light_set_mode == null) {
            mbind_canvas_light_set_mode = try api.createMethod("VisualServer", "canvas_light_set_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_mode, base, cargs, result);
    }

    pub fn canvasLightSetScale(self: *const Self, arg_light: *const godot.RID, arg_scale: f32) !void {
        if (mbind_canvas_light_set_scale == null) {
            mbind_canvas_light_set_scale = try api.createMethod("VisualServer", "canvas_light_set_scale");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_scale, base, cargs, result);
    }

    pub fn canvasLightSetShadowBufferSize(self: *const Self, arg_light: *const godot.RID, arg_size: i32) !void {
        if (mbind_canvas_light_set_shadow_buffer_size == null) {
            mbind_canvas_light_set_shadow_buffer_size = try api.createMethod("VisualServer", "canvas_light_set_shadow_buffer_size");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_buffer_size, base, cargs, result);
    }

    pub fn canvasLightSetShadowColor(self: *const Self, arg_light: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_canvas_light_set_shadow_color == null) {
            mbind_canvas_light_set_shadow_color = try api.createMethod("VisualServer", "canvas_light_set_shadow_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_color, base, cargs, result);
    }

    pub fn canvasLightSetShadowEnabled(self: *const Self, arg_light: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_canvas_light_set_shadow_enabled == null) {
            mbind_canvas_light_set_shadow_enabled = try api.createMethod("VisualServer", "canvas_light_set_shadow_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_enabled, base, cargs, result);
    }

    pub fn canvasLightSetShadowFilter(self: *const Self, arg_light: *const godot.RID, arg_filter: i32) !void {
        if (mbind_canvas_light_set_shadow_filter == null) {
            mbind_canvas_light_set_shadow_filter = try api.createMethod("VisualServer", "canvas_light_set_shadow_filter");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_filter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_filter, base, cargs, result);
    }

    pub fn canvasLightSetShadowGradientLength(self: *const Self, arg_light: *const godot.RID, arg_length: f32) !void {
        if (mbind_canvas_light_set_shadow_gradient_length == null) {
            mbind_canvas_light_set_shadow_gradient_length = try api.createMethod("VisualServer", "canvas_light_set_shadow_gradient_length");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_length),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_gradient_length, base, cargs, result);
    }

    pub fn canvasLightSetShadowSmooth(self: *const Self, arg_light: *const godot.RID, arg_smooth: f32) !void {
        if (mbind_canvas_light_set_shadow_smooth == null) {
            mbind_canvas_light_set_shadow_smooth = try api.createMethod("VisualServer", "canvas_light_set_shadow_smooth");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_smooth),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_shadow_smooth, base, cargs, result);
    }

    pub fn canvasLightSetTexture(self: *const Self, arg_light: *const godot.RID, arg_texture: *const godot.RID) !void {
        if (mbind_canvas_light_set_texture == null) {
            mbind_canvas_light_set_texture = try api.createMethod("VisualServer", "canvas_light_set_texture");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_texture, base, cargs, result);
    }

    pub fn canvasLightSetTextureOffset(self: *const Self, arg_light: *const godot.RID, arg_offset: *const godot.Vector2) !void {
        if (mbind_canvas_light_set_texture_offset == null) {
            mbind_canvas_light_set_texture_offset = try api.createMethod("VisualServer", "canvas_light_set_texture_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_texture_offset, base, cargs, result);
    }

    pub fn canvasLightSetTransform(self: *const Self, arg_light: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_canvas_light_set_transform == null) {
            mbind_canvas_light_set_transform = try api.createMethod("VisualServer", "canvas_light_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_transform, base, cargs, result);
    }

    pub fn canvasLightSetZRange(self: *const Self, arg_light: *const godot.RID, arg_min_z: i32, arg_max_z: i32) !void {
        if (mbind_canvas_light_set_z_range == null) {
            mbind_canvas_light_set_z_range = try api.createMethod("VisualServer", "canvas_light_set_z_range");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_min_z),
            @ptrCast(*const anyopaque, *arg_max_z),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_light_set_z_range, base, cargs, result);
    }

    pub fn canvasOccluderPolygonCreate(self: *const Self) !godot.RID {
        if (mbind_canvas_occluder_polygon_create == null) {
            mbind_canvas_occluder_polygon_create = try api.createMethod("VisualServer", "canvas_occluder_polygon_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_occluder_polygon_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn canvasOccluderPolygonSetCullMode(self: *const Self, arg_occluder_polygon: *const godot.RID, arg_mode: i32) !void {
        if (mbind_canvas_occluder_polygon_set_cull_mode == null) {
            mbind_canvas_occluder_polygon_set_cull_mode = try api.createMethod("VisualServer", "canvas_occluder_polygon_set_cull_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder_polygon),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_occluder_polygon_set_cull_mode, base, cargs, result);
    }

    pub fn canvasOccluderPolygonSetShape(self: *const Self, arg_occluder_polygon: *const godot.RID, arg_shape: *const godot.PoolVector2Array, arg_closed: bool) !void {
        if (mbind_canvas_occluder_polygon_set_shape == null) {
            mbind_canvas_occluder_polygon_set_shape = try api.createMethod("VisualServer", "canvas_occluder_polygon_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder_polygon),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, *arg_closed),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_occluder_polygon_set_shape, base, cargs, result);
    }

    pub fn canvasOccluderPolygonSetShapeAsLines(self: *const Self, arg_occluder_polygon: *const godot.RID, arg_shape: *const godot.PoolVector2Array) !void {
        if (mbind_canvas_occluder_polygon_set_shape_as_lines == null) {
            mbind_canvas_occluder_polygon_set_shape_as_lines = try api.createMethod("VisualServer", "canvas_occluder_polygon_set_shape_as_lines");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_occluder_polygon),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_occluder_polygon_set_shape_as_lines, base, cargs, result);
    }

    pub fn canvasSetItemMirroring(self: *const Self, arg_canvas: *const godot.RID, arg_item: *const godot.RID, arg_mirroring: *const godot.Vector2) !void {
        if (mbind_canvas_set_item_mirroring == null) {
            mbind_canvas_set_item_mirroring = try api.createMethod("VisualServer", "canvas_set_item_mirroring");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_canvas),
            @ptrCast(*const anyopaque, arg_item),
            @ptrCast(*const anyopaque, arg_mirroring),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_set_item_mirroring, base, cargs, result);
    }

    pub fn canvasSetModulate(self: *const Self, arg_canvas: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_canvas_set_modulate == null) {
            mbind_canvas_set_modulate = try api.createMethod("VisualServer", "canvas_set_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_canvas),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_canvas_set_modulate, base, cargs, result);
    }

    pub fn directionalLightCreate(self: *const Self) !godot.RID {
        if (mbind_directional_light_create == null) {
            mbind_directional_light_create = try api.createMethod("VisualServer", "directional_light_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_directional_light_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn draw(self: *const Self, arg_swap_buffers: bool, arg_frame_step: f32) !void {
        if (mbind_draw == null) {
            mbind_draw = try api.createMethod("VisualServer", "draw");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_swap_buffers),
            @ptrCast(*const anyopaque, *arg_frame_step),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw, base, cargs, result);
    }

    pub fn environmentCreate(self: *const Self) !godot.RID {
        if (mbind_environment_create == null) {
            mbind_environment_create = try api.createMethod("VisualServer", "environment_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn environmentSetAdjustment(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_brightness: f32, arg_contrast: f32, arg_saturation: f32, arg_ramp: *const godot.RID) !void {
        if (mbind_environment_set_adjustment == null) {
            mbind_environment_set_adjustment = try api.createMethod("VisualServer", "environment_set_adjustment");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_brightness),
            @ptrCast(*const anyopaque, *arg_contrast),
            @ptrCast(*const anyopaque, *arg_saturation),
            @ptrCast(*const anyopaque, arg_ramp),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_adjustment, base, cargs, result);
    }

    pub fn environmentSetAmbientLight(self: *const Self, arg_env: *const godot.RID, arg_color: *const godot.Color, arg_energy: f32, arg_sky_contibution: f32) !void {
        if (mbind_environment_set_ambient_light == null) {
            mbind_environment_set_ambient_light = try api.createMethod("VisualServer", "environment_set_ambient_light");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_energy),
            @ptrCast(*const anyopaque, *arg_sky_contibution),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_ambient_light, base, cargs, result);
    }

    pub fn environmentSetBackground(self: *const Self, arg_env: *const godot.RID, arg_bg: i32) !void {
        if (mbind_environment_set_background == null) {
            mbind_environment_set_background = try api.createMethod("VisualServer", "environment_set_background");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_bg),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_background, base, cargs, result);
    }

    pub fn environmentSetBgColor(self: *const Self, arg_env: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_environment_set_bg_color == null) {
            mbind_environment_set_bg_color = try api.createMethod("VisualServer", "environment_set_bg_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_bg_color, base, cargs, result);
    }

    pub fn environmentSetBgEnergy(self: *const Self, arg_env: *const godot.RID, arg_energy: f32) !void {
        if (mbind_environment_set_bg_energy == null) {
            mbind_environment_set_bg_energy = try api.createMethod("VisualServer", "environment_set_bg_energy");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_bg_energy, base, cargs, result);
    }

    pub fn environmentSetCanvasMaxLayer(self: *const Self, arg_env: *const godot.RID, arg_max_layer: i32) !void {
        if (mbind_environment_set_canvas_max_layer == null) {
            mbind_environment_set_canvas_max_layer = try api.createMethod("VisualServer", "environment_set_canvas_max_layer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_max_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_canvas_max_layer, base, cargs, result);
    }

    pub fn environmentSetDofBlurFar(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_distance: f32, arg_transition: f32, arg_far_amount: f32, arg_quality: i32) !void {
        if (mbind_environment_set_dof_blur_far == null) {
            mbind_environment_set_dof_blur_far = try api.createMethod("VisualServer", "environment_set_dof_blur_far");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_distance),
            @ptrCast(*const anyopaque, *arg_transition),
            @ptrCast(*const anyopaque, *arg_far_amount),
            @ptrCast(*const anyopaque, *arg_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_dof_blur_far, base, cargs, result);
    }

    pub fn environmentSetDofBlurNear(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_distance: f32, arg_transition: f32, arg_far_amount: f32, arg_quality: i32) !void {
        if (mbind_environment_set_dof_blur_near == null) {
            mbind_environment_set_dof_blur_near = try api.createMethod("VisualServer", "environment_set_dof_blur_near");
        }

        var result: ?*anyopaque = null;
        var args: [6]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_distance),
            @ptrCast(*const anyopaque, *arg_transition),
            @ptrCast(*const anyopaque, *arg_far_amount),
            @ptrCast(*const anyopaque, *arg_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_dof_blur_near, base, cargs, result);
    }

    pub fn environmentSetFog(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_color: *const godot.Color, arg_sun_color: *const godot.Color, arg_sun_amount: f32) !void {
        if (mbind_environment_set_fog == null) {
            mbind_environment_set_fog = try api.createMethod("VisualServer", "environment_set_fog");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, arg_sun_color),
            @ptrCast(*const anyopaque, *arg_sun_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_fog, base, cargs, result);
    }

    pub fn environmentSetFogDepth(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_depth_begin: f32, arg_depth_end: f32, arg_depth_curve: f32, arg_transmit: bool, arg_transmit_curve: f32) !void {
        if (mbind_environment_set_fog_depth == null) {
            mbind_environment_set_fog_depth = try api.createMethod("VisualServer", "environment_set_fog_depth");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_depth_begin),
            @ptrCast(*const anyopaque, *arg_depth_end),
            @ptrCast(*const anyopaque, *arg_depth_curve),
            @ptrCast(*const anyopaque, *arg_transmit),
            @ptrCast(*const anyopaque, *arg_transmit_curve),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_fog_depth, base, cargs, result);
    }

    pub fn environmentSetFogHeight(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_min_height: f32, arg_max_height: f32, arg_height_curve: f32) !void {
        if (mbind_environment_set_fog_height == null) {
            mbind_environment_set_fog_height = try api.createMethod("VisualServer", "environment_set_fog_height");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_min_height),
            @ptrCast(*const anyopaque, *arg_max_height),
            @ptrCast(*const anyopaque, *arg_height_curve),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_fog_height, base, cargs, result);
    }

    pub fn environmentSetGlow(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_level_flags: i32, arg_intensity: f32, arg_strength: f32, arg_bloom_threshold: f32, arg_blend_mode: i32, arg_hdr_bleed_threshold: f32, arg_hdr_bleed_scale: f32, arg_hdr_luminance_cap: f32, arg_bicubic_upscale: bool, arg_high_quality: bool) !void {
        if (mbind_environment_set_glow == null) {
            mbind_environment_set_glow = try api.createMethod("VisualServer", "environment_set_glow");
        }

        var result: ?*anyopaque = null;
        var args: [12]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_level_flags),
            @ptrCast(*const anyopaque, *arg_intensity),
            @ptrCast(*const anyopaque, *arg_strength),
            @ptrCast(*const anyopaque, *arg_bloom_threshold),
            @ptrCast(*const anyopaque, *arg_blend_mode),
            @ptrCast(*const anyopaque, *arg_hdr_bleed_threshold),
            @ptrCast(*const anyopaque, *arg_hdr_bleed_scale),
            @ptrCast(*const anyopaque, *arg_hdr_luminance_cap),
            @ptrCast(*const anyopaque, *arg_bicubic_upscale),
            @ptrCast(*const anyopaque, *arg_high_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_glow, base, cargs, result);
    }

    pub fn environmentSetSky(self: *const Self, arg_env: *const godot.RID, arg_sky: *const godot.RID) !void {
        if (mbind_environment_set_sky == null) {
            mbind_environment_set_sky = try api.createMethod("VisualServer", "environment_set_sky");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, arg_sky),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_sky, base, cargs, result);
    }

    pub fn environmentSetSkyCustomFov(self: *const Self, arg_env: *const godot.RID, arg_scale: f32) !void {
        if (mbind_environment_set_sky_custom_fov == null) {
            mbind_environment_set_sky_custom_fov = try api.createMethod("VisualServer", "environment_set_sky_custom_fov");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_sky_custom_fov, base, cargs, result);
    }

    pub fn environmentSetSkyOrientation(self: *const Self, arg_env: *const godot.RID, arg_orientation: *const godot.Basis) !void {
        if (mbind_environment_set_sky_orientation == null) {
            mbind_environment_set_sky_orientation = try api.createMethod("VisualServer", "environment_set_sky_orientation");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, arg_orientation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_sky_orientation, base, cargs, result);
    }

    pub fn environmentSetSsao(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_radius: f32, arg_intensity: f32, arg_radius2: f32, arg_intensity2: f32, arg_bias: f32, arg_light_affect: f32, arg_ao_channel_affect: f32, arg_color: *const godot.Color, arg_quality: i32, arg_blur: i32, arg_bilateral_sharpness: f32) !void {
        if (mbind_environment_set_ssao == null) {
            mbind_environment_set_ssao = try api.createMethod("VisualServer", "environment_set_ssao");
        }

        var result: ?*anyopaque = null;
        var args: [13]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_radius),
            @ptrCast(*const anyopaque, *arg_intensity),
            @ptrCast(*const anyopaque, *arg_radius2),
            @ptrCast(*const anyopaque, *arg_intensity2),
            @ptrCast(*const anyopaque, *arg_bias),
            @ptrCast(*const anyopaque, *arg_light_affect),
            @ptrCast(*const anyopaque, *arg_ao_channel_affect),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_quality),
            @ptrCast(*const anyopaque, *arg_blur),
            @ptrCast(*const anyopaque, *arg_bilateral_sharpness),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_ssao, base, cargs, result);
    }

    pub fn environmentSetSsr(self: *const Self, arg_env: *const godot.RID, arg_enable: bool, arg_max_steps: i32, arg_fade_in: f32, arg_fade_out: f32, arg_depth_tolerance: f32, arg_roughness: bool) !void {
        if (mbind_environment_set_ssr == null) {
            mbind_environment_set_ssr = try api.createMethod("VisualServer", "environment_set_ssr");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_max_steps),
            @ptrCast(*const anyopaque, *arg_fade_in),
            @ptrCast(*const anyopaque, *arg_fade_out),
            @ptrCast(*const anyopaque, *arg_depth_tolerance),
            @ptrCast(*const anyopaque, *arg_roughness),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_ssr, base, cargs, result);
    }

    pub fn environmentSetTonemap(self: *const Self, arg_env: *const godot.RID, arg_tone_mapper: i32, arg_exposure: f32, arg_white: f32, arg_auto_exposure: bool, arg_min_luminance: f32, arg_max_luminance: f32, arg_auto_exp_speed: f32, arg_auto_exp_grey: f32) !void {
        if (mbind_environment_set_tonemap == null) {
            mbind_environment_set_tonemap = try api.createMethod("VisualServer", "environment_set_tonemap");
        }

        var result: ?*anyopaque = null;
        var args: [9]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_env),
            @ptrCast(*const anyopaque, *arg_tone_mapper),
            @ptrCast(*const anyopaque, *arg_exposure),
            @ptrCast(*const anyopaque, *arg_white),
            @ptrCast(*const anyopaque, *arg_auto_exposure),
            @ptrCast(*const anyopaque, *arg_min_luminance),
            @ptrCast(*const anyopaque, *arg_max_luminance),
            @ptrCast(*const anyopaque, *arg_auto_exp_speed),
            @ptrCast(*const anyopaque, *arg_auto_exp_grey),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_environment_set_tonemap, base, cargs, result);
    }

    pub fn finish(self: *const Self) !void {
        if (mbind_finish == null) {
            mbind_finish = try api.createMethod("VisualServer", "finish");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_finish, base, cargs, result);
    }

    pub fn forceDraw(self: *const Self, arg_swap_buffers: bool, arg_frame_step: f32) !void {
        if (mbind_force_draw == null) {
            mbind_force_draw = try api.createMethod("VisualServer", "force_draw");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_swap_buffers),
            @ptrCast(*const anyopaque, *arg_frame_step),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_force_draw, base, cargs, result);
    }

    pub fn forceSync(self: *const Self) !void {
        if (mbind_force_sync == null) {
            mbind_force_sync = try api.createMethod("VisualServer", "force_sync");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_force_sync, base, cargs, result);
    }

    pub fn freeRid(self: *const Self, arg_rid: *const godot.RID) !void {
        if (mbind_free_rid == null) {
            mbind_free_rid = try api.createMethod("VisualServer", "free_rid");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rid),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_free_rid, base, cargs, result);
    }

    pub fn getRenderInfo(self: *const Self, arg_info: i32) !i32 {
        if (mbind_get_render_info == null) {
            mbind_get_render_info = try api.createMethod("VisualServer", "get_render_info");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_info),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_render_info, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTestCube(self: *const Self) !godot.RID {
        if (mbind_get_test_cube == null) {
            mbind_get_test_cube = try api.createMethod("VisualServer", "get_test_cube");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_test_cube, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getTestTexture(self: *const Self) !godot.RID {
        if (mbind_get_test_texture == null) {
            mbind_get_test_texture = try api.createMethod("VisualServer", "get_test_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_test_texture, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getVideoAdapterName(self: *const Self) !godot.String {
        if (mbind_get_video_adapter_name == null) {
            mbind_get_video_adapter_name = try api.createMethod("VisualServer", "get_video_adapter_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_video_adapter_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVideoAdapterVendor(self: *const Self) !godot.String {
        if (mbind_get_video_adapter_vendor == null) {
            mbind_get_video_adapter_vendor = try api.createMethod("VisualServer", "get_video_adapter_vendor");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_video_adapter_vendor, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getWhiteTexture(self: *const Self) !godot.RID {
        if (mbind_get_white_texture == null) {
            mbind_get_white_texture = try api.createMethod("VisualServer", "get_white_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_white_texture, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn giProbeCreate(self: *const Self) !godot.RID {
        if (mbind_gi_probe_create == null) {
            mbind_gi_probe_create = try api.createMethod("VisualServer", "gi_probe_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn giProbeGetBias(self: *const Self, arg_probe: *const godot.RID) !f32 {
        if (mbind_gi_probe_get_bias == null) {
            mbind_gi_probe_get_bias = try api.createMethod("VisualServer", "gi_probe_get_bias");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_bias, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn giProbeGetBounds(self: *const Self, arg_probe: *const godot.RID) !godot.AABB {
        if (mbind_gi_probe_get_bounds == null) {
            mbind_gi_probe_get_bounds = try api.createMethod("VisualServer", "gi_probe_get_bounds");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_bounds, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn giProbeGetCellSize(self: *const Self, arg_probe: *const godot.RID) !f32 {
        if (mbind_gi_probe_get_cell_size == null) {
            mbind_gi_probe_get_cell_size = try api.createMethod("VisualServer", "gi_probe_get_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_cell_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn giProbeGetDynamicData(self: *const Self, arg_probe: *const godot.RID) !godot.PoolIntArray {
        if (mbind_gi_probe_get_dynamic_data == null) {
            mbind_gi_probe_get_dynamic_data = try api.createMethod("VisualServer", "gi_probe_get_dynamic_data");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_dynamic_data, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn giProbeGetDynamicRange(self: *const Self, arg_probe: *const godot.RID) !i32 {
        if (mbind_gi_probe_get_dynamic_range == null) {
            mbind_gi_probe_get_dynamic_range = try api.createMethod("VisualServer", "gi_probe_get_dynamic_range");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_dynamic_range, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn giProbeGetEnergy(self: *const Self, arg_probe: *const godot.RID) !f32 {
        if (mbind_gi_probe_get_energy == null) {
            mbind_gi_probe_get_energy = try api.createMethod("VisualServer", "gi_probe_get_energy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_energy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn giProbeGetNormalBias(self: *const Self, arg_probe: *const godot.RID) !f32 {
        if (mbind_gi_probe_get_normal_bias == null) {
            mbind_gi_probe_get_normal_bias = try api.createMethod("VisualServer", "gi_probe_get_normal_bias");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_normal_bias, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn giProbeGetPropagation(self: *const Self, arg_probe: *const godot.RID) !f32 {
        if (mbind_gi_probe_get_propagation == null) {
            mbind_gi_probe_get_propagation = try api.createMethod("VisualServer", "gi_probe_get_propagation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_propagation, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn giProbeGetToCellXform(self: *const Self, arg_probe: *const godot.RID) !godot.Transform {
        if (mbind_gi_probe_get_to_cell_xform == null) {
            mbind_gi_probe_get_to_cell_xform = try api.createMethod("VisualServer", "gi_probe_get_to_cell_xform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_get_to_cell_xform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn giProbeIsCompressed(self: *const Self, arg_probe: *const godot.RID) !bool {
        if (mbind_gi_probe_is_compressed == null) {
            mbind_gi_probe_is_compressed = try api.createMethod("VisualServer", "gi_probe_is_compressed");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_is_compressed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn giProbeIsInterior(self: *const Self, arg_probe: *const godot.RID) !bool {
        if (mbind_gi_probe_is_interior == null) {
            mbind_gi_probe_is_interior = try api.createMethod("VisualServer", "gi_probe_is_interior");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_is_interior, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn giProbeSetBias(self: *const Self, arg_probe: *const godot.RID, arg_bias: f32) !void {
        if (mbind_gi_probe_set_bias == null) {
            mbind_gi_probe_set_bias = try api.createMethod("VisualServer", "gi_probe_set_bias");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_bias),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_bias, base, cargs, result);
    }

    pub fn giProbeSetBounds(self: *const Self, arg_probe: *const godot.RID, arg_bounds: *const godot.AABB) !void {
        if (mbind_gi_probe_set_bounds == null) {
            mbind_gi_probe_set_bounds = try api.createMethod("VisualServer", "gi_probe_set_bounds");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_bounds),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_bounds, base, cargs, result);
    }

    pub fn giProbeSetCellSize(self: *const Self, arg_probe: *const godot.RID, arg_range: f32) !void {
        if (mbind_gi_probe_set_cell_size == null) {
            mbind_gi_probe_set_cell_size = try api.createMethod("VisualServer", "gi_probe_set_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_range),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_cell_size, base, cargs, result);
    }

    pub fn giProbeSetCompress(self: *const Self, arg_probe: *const godot.RID, arg_enable: bool) !void {
        if (mbind_gi_probe_set_compress == null) {
            mbind_gi_probe_set_compress = try api.createMethod("VisualServer", "gi_probe_set_compress");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_compress, base, cargs, result);
    }

    pub fn giProbeSetDynamicData(self: *const Self, arg_probe: *const godot.RID, arg_data: *const godot.PoolIntArray) !void {
        if (mbind_gi_probe_set_dynamic_data == null) {
            mbind_gi_probe_set_dynamic_data = try api.createMethod("VisualServer", "gi_probe_set_dynamic_data");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_dynamic_data, base, cargs, result);
    }

    pub fn giProbeSetDynamicRange(self: *const Self, arg_probe: *const godot.RID, arg_range: i32) !void {
        if (mbind_gi_probe_set_dynamic_range == null) {
            mbind_gi_probe_set_dynamic_range = try api.createMethod("VisualServer", "gi_probe_set_dynamic_range");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_range),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_dynamic_range, base, cargs, result);
    }

    pub fn giProbeSetEnergy(self: *const Self, arg_probe: *const godot.RID, arg_energy: f32) !void {
        if (mbind_gi_probe_set_energy == null) {
            mbind_gi_probe_set_energy = try api.createMethod("VisualServer", "gi_probe_set_energy");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_energy, base, cargs, result);
    }

    pub fn giProbeSetInterior(self: *const Self, arg_probe: *const godot.RID, arg_enable: bool) !void {
        if (mbind_gi_probe_set_interior == null) {
            mbind_gi_probe_set_interior = try api.createMethod("VisualServer", "gi_probe_set_interior");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_interior, base, cargs, result);
    }

    pub fn giProbeSetNormalBias(self: *const Self, arg_probe: *const godot.RID, arg_bias: f32) !void {
        if (mbind_gi_probe_set_normal_bias == null) {
            mbind_gi_probe_set_normal_bias = try api.createMethod("VisualServer", "gi_probe_set_normal_bias");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_bias),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_normal_bias, base, cargs, result);
    }

    pub fn giProbeSetPropagation(self: *const Self, arg_probe: *const godot.RID, arg_propagation: f32) !void {
        if (mbind_gi_probe_set_propagation == null) {
            mbind_gi_probe_set_propagation = try api.createMethod("VisualServer", "gi_probe_set_propagation");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_propagation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_propagation, base, cargs, result);
    }

    pub fn giProbeSetToCellXform(self: *const Self, arg_probe: *const godot.RID, arg_xform: *const godot.Transform) !void {
        if (mbind_gi_probe_set_to_cell_xform == null) {
            mbind_gi_probe_set_to_cell_xform = try api.createMethod("VisualServer", "gi_probe_set_to_cell_xform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_xform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gi_probe_set_to_cell_xform, base, cargs, result);
    }

    pub fn hasChanged(self: *const Self) !bool {
        if (mbind_has_changed == null) {
            mbind_has_changed = try api.createMethod("VisualServer", "has_changed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_changed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFeature(self: *const Self, arg_feature: i32) !bool {
        if (mbind_has_feature == null) {
            mbind_has_feature = try api.createMethod("VisualServer", "has_feature");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_feature),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_feature, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasOsFeature(self: *const Self, arg_feature: *const godot.String) !bool {
        if (mbind_has_os_feature == null) {
            mbind_has_os_feature = try api.createMethod("VisualServer", "has_os_feature");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_feature),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_os_feature, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn immediateBegin(self: *const Self, arg_immediate: *const godot.RID, arg_primitive: i32, arg_texture: *const godot.RID) !void {
        if (mbind_immediate_begin == null) {
            mbind_immediate_begin = try api.createMethod("VisualServer", "immediate_begin");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, *arg_primitive),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_begin, base, cargs, result);
    }

    pub fn immediateClear(self: *const Self, arg_immediate: *const godot.RID) !void {
        if (mbind_immediate_clear == null) {
            mbind_immediate_clear = try api.createMethod("VisualServer", "immediate_clear");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_clear, base, cargs, result);
    }

    pub fn immediateColor(self: *const Self, arg_immediate: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_immediate_color == null) {
            mbind_immediate_color = try api.createMethod("VisualServer", "immediate_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_color, base, cargs, result);
    }

    pub fn immediateCreate(self: *const Self) !godot.RID {
        if (mbind_immediate_create == null) {
            mbind_immediate_create = try api.createMethod("VisualServer", "immediate_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn immediateEnd(self: *const Self, arg_immediate: *const godot.RID) !void {
        if (mbind_immediate_end == null) {
            mbind_immediate_end = try api.createMethod("VisualServer", "immediate_end");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_end, base, cargs, result);
    }

    pub fn immediateGetMaterial(self: *const Self, arg_immediate: *const godot.RID) !godot.RID {
        if (mbind_immediate_get_material == null) {
            mbind_immediate_get_material = try api.createMethod("VisualServer", "immediate_get_material");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_get_material, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn immediateNormal(self: *const Self, arg_immediate: *const godot.RID, arg_normal: *const godot.Vector3) !void {
        if (mbind_immediate_normal == null) {
            mbind_immediate_normal = try api.createMethod("VisualServer", "immediate_normal");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_normal),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_normal, base, cargs, result);
    }

    pub fn immediateSetMaterial(self: *const Self, arg_immediate: *const godot.RID, arg_material: *const godot.RID) !void {
        if (mbind_immediate_set_material == null) {
            mbind_immediate_set_material = try api.createMethod("VisualServer", "immediate_set_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_set_material, base, cargs, result);
    }

    pub fn immediateTangent(self: *const Self, arg_immediate: *const godot.RID, arg_tangent: *const godot.Plane) !void {
        if (mbind_immediate_tangent == null) {
            mbind_immediate_tangent = try api.createMethod("VisualServer", "immediate_tangent");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_tangent),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_tangent, base, cargs, result);
    }

    pub fn immediateUv(self: *const Self, arg_immediate: *const godot.RID, arg_tex_uv: *const godot.Vector2) !void {
        if (mbind_immediate_uv == null) {
            mbind_immediate_uv = try api.createMethod("VisualServer", "immediate_uv");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_tex_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_uv, base, cargs, result);
    }

    pub fn immediateUv2(self: *const Self, arg_immediate: *const godot.RID, arg_tex_uv: *const godot.Vector2) !void {
        if (mbind_immediate_uv2 == null) {
            mbind_immediate_uv2 = try api.createMethod("VisualServer", "immediate_uv2");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_tex_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_uv2, base, cargs, result);
    }

    pub fn immediateVertex(self: *const Self, arg_immediate: *const godot.RID, arg_vertex: *const godot.Vector3) !void {
        if (mbind_immediate_vertex == null) {
            mbind_immediate_vertex = try api.createMethod("VisualServer", "immediate_vertex");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_vertex),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_vertex, base, cargs, result);
    }

    pub fn immediateVertex2d(self: *const Self, arg_immediate: *const godot.RID, arg_vertex: *const godot.Vector2) !void {
        if (mbind_immediate_vertex_2d == null) {
            mbind_immediate_vertex_2d = try api.createMethod("VisualServer", "immediate_vertex_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_immediate),
            @ptrCast(*const anyopaque, arg_vertex),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_immediate_vertex_2d, base, cargs, result);
    }

    pub fn initFn(self: *const Self) !void {
        if (mbind_init == null) {
            mbind_init = try api.createMethod("VisualServer", "init");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_init, base, cargs, result);
    }

    pub fn instanceAttachObjectInstanceId(self: *const Self, arg_instance: *const godot.RID, arg_id: i32) !void {
        if (mbind_instance_attach_object_instance_id == null) {
            mbind_instance_attach_object_instance_id = try api.createMethod("VisualServer", "instance_attach_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_attach_object_instance_id, base, cargs, result);
    }

    pub fn instanceAttachSkeleton(self: *const Self, arg_instance: *const godot.RID, arg_skeleton: *const godot.RID) !void {
        if (mbind_instance_attach_skeleton == null) {
            mbind_instance_attach_skeleton = try api.createMethod("VisualServer", "instance_attach_skeleton");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_skeleton),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_attach_skeleton, base, cargs, result);
    }

    pub fn instanceCreate(self: *const Self) !godot.RID {
        if (mbind_instance_create == null) {
            mbind_instance_create = try api.createMethod("VisualServer", "instance_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn instanceCreate2(self: *const Self, arg_base: *const godot.RID, arg_scenario: *const godot.RID) !godot.RID {
        if (mbind_instance_create2 == null) {
            mbind_instance_create2 = try api.createMethod("VisualServer", "instance_create2");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_base),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_create2, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn instanceGeometrySetAsInstanceLod(self: *const Self, arg_instance: *const godot.RID, arg_as_lod_of_instance: *const godot.RID) !void {
        if (mbind_instance_geometry_set_as_instance_lod == null) {
            mbind_instance_geometry_set_as_instance_lod = try api.createMethod("VisualServer", "instance_geometry_set_as_instance_lod");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_as_lod_of_instance),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_geometry_set_as_instance_lod, base, cargs, result);
    }

    pub fn instanceGeometrySetCastShadowsSetting(self: *const Self, arg_instance: *const godot.RID, arg_shadow_casting_setting: i32) !void {
        if (mbind_instance_geometry_set_cast_shadows_setting == null) {
            mbind_instance_geometry_set_cast_shadows_setting = try api.createMethod("VisualServer", "instance_geometry_set_cast_shadows_setting");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_shadow_casting_setting),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_geometry_set_cast_shadows_setting, base, cargs, result);
    }

    pub fn instanceGeometrySetDrawRange(self: *const Self, arg_instance: *const godot.RID, arg_min: f32, arg_max: f32, arg_min_margin: f32, arg_max_margin: f32) !void {
        if (mbind_instance_geometry_set_draw_range == null) {
            mbind_instance_geometry_set_draw_range = try api.createMethod("VisualServer", "instance_geometry_set_draw_range");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_min),
            @ptrCast(*const anyopaque, *arg_max),
            @ptrCast(*const anyopaque, *arg_min_margin),
            @ptrCast(*const anyopaque, *arg_max_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_geometry_set_draw_range, base, cargs, result);
    }

    pub fn instanceGeometrySetFlag(self: *const Self, arg_instance: *const godot.RID, arg_flag: i32, arg_enabled: bool) !void {
        if (mbind_instance_geometry_set_flag == null) {
            mbind_instance_geometry_set_flag = try api.createMethod("VisualServer", "instance_geometry_set_flag");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_flag),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_geometry_set_flag, base, cargs, result);
    }

    pub fn instanceGeometrySetMaterialOverride(self: *const Self, arg_instance: *const godot.RID, arg_material: *const godot.RID) !void {
        if (mbind_instance_geometry_set_material_override == null) {
            mbind_instance_geometry_set_material_override = try api.createMethod("VisualServer", "instance_geometry_set_material_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_geometry_set_material_override, base, cargs, result);
    }

    pub fn instanceSetBase(self: *const Self, arg_instance: *const godot.RID, arg_base: *const godot.RID) !void {
        if (mbind_instance_set_base == null) {
            mbind_instance_set_base = try api.createMethod("VisualServer", "instance_set_base");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_base),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_base, base, cargs, result);
    }

    pub fn instanceSetBlendShapeWeight(self: *const Self, arg_instance: *const godot.RID, arg_shape: i32, arg_weight: f32) !void {
        if (mbind_instance_set_blend_shape_weight == null) {
            mbind_instance_set_blend_shape_weight = try api.createMethod("VisualServer", "instance_set_blend_shape_weight");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_shape),
            @ptrCast(*const anyopaque, *arg_weight),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_blend_shape_weight, base, cargs, result);
    }

    pub fn instanceSetCustomAabb(self: *const Self, arg_instance: *const godot.RID, arg_aabb: *const godot.AABB) !void {
        if (mbind_instance_set_custom_aabb == null) {
            mbind_instance_set_custom_aabb = try api.createMethod("VisualServer", "instance_set_custom_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_aabb),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_custom_aabb, base, cargs, result);
    }

    pub fn instanceSetExterior(self: *const Self, arg_instance: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_instance_set_exterior == null) {
            mbind_instance_set_exterior = try api.createMethod("VisualServer", "instance_set_exterior");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_exterior, base, cargs, result);
    }

    pub fn instanceSetExtraVisibilityMargin(self: *const Self, arg_instance: *const godot.RID, arg_margin: f32) !void {
        if (mbind_instance_set_extra_visibility_margin == null) {
            mbind_instance_set_extra_visibility_margin = try api.createMethod("VisualServer", "instance_set_extra_visibility_margin");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_extra_visibility_margin, base, cargs, result);
    }

    pub fn instanceSetLayerMask(self: *const Self, arg_instance: *const godot.RID, arg_mask: i32) !void {
        if (mbind_instance_set_layer_mask == null) {
            mbind_instance_set_layer_mask = try api.createMethod("VisualServer", "instance_set_layer_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_layer_mask, base, cargs, result);
    }

    pub fn instanceSetScenario(self: *const Self, arg_instance: *const godot.RID, arg_scenario: *const godot.RID) !void {
        if (mbind_instance_set_scenario == null) {
            mbind_instance_set_scenario = try api.createMethod("VisualServer", "instance_set_scenario");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_scenario, base, cargs, result);
    }

    pub fn instanceSetSurfaceMaterial(self: *const Self, arg_instance: *const godot.RID, arg_surface: i32, arg_material: *const godot.RID) !void {
        if (mbind_instance_set_surface_material == null) {
            mbind_instance_set_surface_material = try api.createMethod("VisualServer", "instance_set_surface_material");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_surface),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_surface_material, base, cargs, result);
    }

    pub fn instanceSetTransform(self: *const Self, arg_instance: *const godot.RID, arg_transform: *const godot.Transform) !void {
        if (mbind_instance_set_transform == null) {
            mbind_instance_set_transform = try api.createMethod("VisualServer", "instance_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_transform, base, cargs, result);
    }

    pub fn instanceSetUseLightmap(self: *const Self, arg_instance: *const godot.RID, arg_lightmap_instance: *const godot.RID, arg_lightmap: *const godot.RID, arg_lightmap_slice: i32, arg_lightmap_uv_rect: *const godot.Rect2) !void {
        if (mbind_instance_set_use_lightmap == null) {
            mbind_instance_set_use_lightmap = try api.createMethod("VisualServer", "instance_set_use_lightmap");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, arg_lightmap_instance),
            @ptrCast(*const anyopaque, arg_lightmap),
            @ptrCast(*const anyopaque, *arg_lightmap_slice),
            @ptrCast(*const anyopaque, arg_lightmap_uv_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_use_lightmap, base, cargs, result);
    }

    pub fn instanceSetVisible(self: *const Self, arg_instance: *const godot.RID, arg_visible: bool) !void {
        if (mbind_instance_set_visible == null) {
            mbind_instance_set_visible = try api.createMethod("VisualServer", "instance_set_visible");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_instance),
            @ptrCast(*const anyopaque, *arg_visible),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instance_set_visible, base, cargs, result);
    }

    pub fn instancesCullAabb(self: *const Self, arg_aabb: *const godot.AABB, arg_scenario: *const godot.RID) !godot.Array {
        if (mbind_instances_cull_aabb == null) {
            mbind_instances_cull_aabb = try api.createMethod("VisualServer", "instances_cull_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_aabb),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instances_cull_aabb, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn instancesCullConvex(self: *const Self, arg_convex: *const godot.Array, arg_scenario: *const godot.RID) !godot.Array {
        if (mbind_instances_cull_convex == null) {
            mbind_instances_cull_convex = try api.createMethod("VisualServer", "instances_cull_convex");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_convex),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instances_cull_convex, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn instancesCullRay(self: *const Self, arg_from: *const godot.Vector3, arg_to: *const godot.Vector3, arg_scenario: *const godot.RID) !godot.Array {
        if (mbind_instances_cull_ray == null) {
            mbind_instances_cull_ray = try api.createMethod("VisualServer", "instances_cull_ray");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_instances_cull_ray, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn isRenderLoopEnabled(self: *const Self) !bool {
        if (mbind_is_render_loop_enabled == null) {
            mbind_is_render_loop_enabled = try api.createMethod("VisualServer", "is_render_loop_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_render_loop_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn lightDirectionalSetBlendSplits(self: *const Self, arg_light: *const godot.RID, arg_enable: bool) !void {
        if (mbind_light_directional_set_blend_splits == null) {
            mbind_light_directional_set_blend_splits = try api.createMethod("VisualServer", "light_directional_set_blend_splits");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_directional_set_blend_splits, base, cargs, result);
    }

    pub fn lightDirectionalSetShadowDepthRangeMode(self: *const Self, arg_light: *const godot.RID, arg_range_mode: i32) !void {
        if (mbind_light_directional_set_shadow_depth_range_mode == null) {
            mbind_light_directional_set_shadow_depth_range_mode = try api.createMethod("VisualServer", "light_directional_set_shadow_depth_range_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_range_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_directional_set_shadow_depth_range_mode, base, cargs, result);
    }

    pub fn lightDirectionalSetShadowMode(self: *const Self, arg_light: *const godot.RID, arg_mode: i32) !void {
        if (mbind_light_directional_set_shadow_mode == null) {
            mbind_light_directional_set_shadow_mode = try api.createMethod("VisualServer", "light_directional_set_shadow_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_directional_set_shadow_mode, base, cargs, result);
    }

    pub fn lightOmniSetShadowDetail(self: *const Self, arg_light: *const godot.RID, arg_detail: i32) !void {
        if (mbind_light_omni_set_shadow_detail == null) {
            mbind_light_omni_set_shadow_detail = try api.createMethod("VisualServer", "light_omni_set_shadow_detail");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_detail),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_omni_set_shadow_detail, base, cargs, result);
    }

    pub fn lightOmniSetShadowMode(self: *const Self, arg_light: *const godot.RID, arg_mode: i32) !void {
        if (mbind_light_omni_set_shadow_mode == null) {
            mbind_light_omni_set_shadow_mode = try api.createMethod("VisualServer", "light_omni_set_shadow_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_omni_set_shadow_mode, base, cargs, result);
    }

    pub fn lightSetBakeMode(self: *const Self, arg_light: *const godot.RID, arg_bake_mode: i32) !void {
        if (mbind_light_set_bake_mode == null) {
            mbind_light_set_bake_mode = try api.createMethod("VisualServer", "light_set_bake_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_bake_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_bake_mode, base, cargs, result);
    }

    pub fn lightSetColor(self: *const Self, arg_light: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_light_set_color == null) {
            mbind_light_set_color = try api.createMethod("VisualServer", "light_set_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_color, base, cargs, result);
    }

    pub fn lightSetCullMask(self: *const Self, arg_light: *const godot.RID, arg_mask: i32) !void {
        if (mbind_light_set_cull_mask == null) {
            mbind_light_set_cull_mask = try api.createMethod("VisualServer", "light_set_cull_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_cull_mask, base, cargs, result);
    }

    pub fn lightSetNegative(self: *const Self, arg_light: *const godot.RID, arg_enable: bool) !void {
        if (mbind_light_set_negative == null) {
            mbind_light_set_negative = try api.createMethod("VisualServer", "light_set_negative");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_negative, base, cargs, result);
    }

    pub fn lightSetParam(self: *const Self, arg_light: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_light_set_param == null) {
            mbind_light_set_param = try api.createMethod("VisualServer", "light_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_param, base, cargs, result);
    }

    pub fn lightSetProjector(self: *const Self, arg_light: *const godot.RID, arg_texture: *const godot.RID) !void {
        if (mbind_light_set_projector == null) {
            mbind_light_set_projector = try api.createMethod("VisualServer", "light_set_projector");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_projector, base, cargs, result);
    }

    pub fn lightSetReverseCullFaceMode(self: *const Self, arg_light: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_light_set_reverse_cull_face_mode == null) {
            mbind_light_set_reverse_cull_face_mode = try api.createMethod("VisualServer", "light_set_reverse_cull_face_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_reverse_cull_face_mode, base, cargs, result);
    }

    pub fn lightSetShadow(self: *const Self, arg_light: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_light_set_shadow == null) {
            mbind_light_set_shadow = try api.createMethod("VisualServer", "light_set_shadow");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_shadow, base, cargs, result);
    }

    pub fn lightSetShadowColor(self: *const Self, arg_light: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_light_set_shadow_color == null) {
            mbind_light_set_shadow_color = try api.createMethod("VisualServer", "light_set_shadow_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_shadow_color, base, cargs, result);
    }

    pub fn lightSetUseGi(self: *const Self, arg_light: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_light_set_use_gi == null) {
            mbind_light_set_use_gi = try api.createMethod("VisualServer", "light_set_use_gi");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_light),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_light_set_use_gi, base, cargs, result);
    }

    pub fn lightmapCaptureCreate(self: *const Self) !godot.RID {
        if (mbind_lightmap_capture_create == null) {
            mbind_lightmap_capture_create = try api.createMethod("VisualServer", "lightmap_capture_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn lightmapCaptureGetBounds(self: *const Self, arg_capture: *const godot.RID) !godot.AABB {
        if (mbind_lightmap_capture_get_bounds == null) {
            mbind_lightmap_capture_get_bounds = try api.createMethod("VisualServer", "lightmap_capture_get_bounds");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_get_bounds, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn lightmapCaptureGetEnergy(self: *const Self, arg_capture: *const godot.RID) !f32 {
        if (mbind_lightmap_capture_get_energy == null) {
            mbind_lightmap_capture_get_energy = try api.createMethod("VisualServer", "lightmap_capture_get_energy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_get_energy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn lightmapCaptureGetOctree(self: *const Self, arg_capture: *const godot.RID) !godot.PoolByteArray {
        if (mbind_lightmap_capture_get_octree == null) {
            mbind_lightmap_capture_get_octree = try api.createMethod("VisualServer", "lightmap_capture_get_octree");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_get_octree, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn lightmapCaptureGetOctreeCellSubdiv(self: *const Self, arg_capture: *const godot.RID) !i32 {
        if (mbind_lightmap_capture_get_octree_cell_subdiv == null) {
            mbind_lightmap_capture_get_octree_cell_subdiv = try api.createMethod("VisualServer", "lightmap_capture_get_octree_cell_subdiv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_get_octree_cell_subdiv, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn lightmapCaptureGetOctreeCellTransform(self: *const Self, arg_capture: *const godot.RID) !godot.Transform {
        if (mbind_lightmap_capture_get_octree_cell_transform == null) {
            mbind_lightmap_capture_get_octree_cell_transform = try api.createMethod("VisualServer", "lightmap_capture_get_octree_cell_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_get_octree_cell_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn lightmapCaptureIsInterior(self: *const Self, arg_capture: *const godot.RID) !bool {
        if (mbind_lightmap_capture_is_interior == null) {
            mbind_lightmap_capture_is_interior = try api.createMethod("VisualServer", "lightmap_capture_is_interior");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_is_interior, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn lightmapCaptureSetBounds(self: *const Self, arg_capture: *const godot.RID, arg_bounds: *const godot.AABB) !void {
        if (mbind_lightmap_capture_set_bounds == null) {
            mbind_lightmap_capture_set_bounds = try api.createMethod("VisualServer", "lightmap_capture_set_bounds");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, arg_bounds),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_bounds, base, cargs, result);
    }

    pub fn lightmapCaptureSetEnergy(self: *const Self, arg_capture: *const godot.RID, arg_energy: f32) !void {
        if (mbind_lightmap_capture_set_energy == null) {
            mbind_lightmap_capture_set_energy = try api.createMethod("VisualServer", "lightmap_capture_set_energy");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_energy, base, cargs, result);
    }

    pub fn lightmapCaptureSetInterior(self: *const Self, arg_capture: *const godot.RID, arg_interior: bool) !void {
        if (mbind_lightmap_capture_set_interior == null) {
            mbind_lightmap_capture_set_interior = try api.createMethod("VisualServer", "lightmap_capture_set_interior");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, *arg_interior),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_interior, base, cargs, result);
    }

    pub fn lightmapCaptureSetOctree(self: *const Self, arg_capture: *const godot.RID, arg_octree: *const godot.PoolByteArray) !void {
        if (mbind_lightmap_capture_set_octree == null) {
            mbind_lightmap_capture_set_octree = try api.createMethod("VisualServer", "lightmap_capture_set_octree");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, arg_octree),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_octree, base, cargs, result);
    }

    pub fn lightmapCaptureSetOctreeCellSubdiv(self: *const Self, arg_capture: *const godot.RID, arg_subdiv: i32) !void {
        if (mbind_lightmap_capture_set_octree_cell_subdiv == null) {
            mbind_lightmap_capture_set_octree_cell_subdiv = try api.createMethod("VisualServer", "lightmap_capture_set_octree_cell_subdiv");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, *arg_subdiv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_octree_cell_subdiv, base, cargs, result);
    }

    pub fn lightmapCaptureSetOctreeCellTransform(self: *const Self, arg_capture: *const godot.RID, arg_xform: *const godot.Transform) !void {
        if (mbind_lightmap_capture_set_octree_cell_transform == null) {
            mbind_lightmap_capture_set_octree_cell_transform = try api.createMethod("VisualServer", "lightmap_capture_set_octree_cell_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_capture),
            @ptrCast(*const anyopaque, arg_xform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lightmap_capture_set_octree_cell_transform, base, cargs, result);
    }

    pub fn makeSphereMesh(self: *const Self, arg_latitudes: i32, arg_longitudes: i32, arg_radius: f32) !godot.RID {
        if (mbind_make_sphere_mesh == null) {
            mbind_make_sphere_mesh = try api.createMethod("VisualServer", "make_sphere_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_latitudes),
            @ptrCast(*const anyopaque, *arg_longitudes),
            @ptrCast(*const anyopaque, *arg_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_sphere_mesh, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn materialCreate(self: *const Self) !godot.RID {
        if (mbind_material_create == null) {
            mbind_material_create = try api.createMethod("VisualServer", "material_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn materialGetParam(self: *const Self, arg_material: *const godot.RID, arg_parameter: *const godot.String) !godot.Variant {
        if (mbind_material_get_param == null) {
            mbind_material_get_param = try api.createMethod("VisualServer", "material_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, arg_parameter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_get_param, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn materialGetParamDefault(self: *const Self, arg_material: *const godot.RID, arg_parameter: *const godot.String) !godot.Variant {
        if (mbind_material_get_param_default == null) {
            mbind_material_get_param_default = try api.createMethod("VisualServer", "material_get_param_default");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, arg_parameter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_get_param_default, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn materialGetShader(self: *const Self, arg_shader_material: *const godot.RID) !godot.RID {
        if (mbind_material_get_shader == null) {
            mbind_material_get_shader = try api.createMethod("VisualServer", "material_get_shader");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_get_shader, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn materialSetLineWidth(self: *const Self, arg_material: *const godot.RID, arg_width: f32) !void {
        if (mbind_material_set_line_width == null) {
            mbind_material_set_line_width = try api.createMethod("VisualServer", "material_set_line_width");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, *arg_width),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_set_line_width, base, cargs, result);
    }

    pub fn materialSetNextPass(self: *const Self, arg_material: *const godot.RID, arg_next_material: *const godot.RID) !void {
        if (mbind_material_set_next_pass == null) {
            mbind_material_set_next_pass = try api.createMethod("VisualServer", "material_set_next_pass");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, arg_next_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_set_next_pass, base, cargs, result);
    }

    pub fn materialSetParam(self: *const Self, arg_material: *const godot.RID, arg_parameter: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_material_set_param == null) {
            mbind_material_set_param = try api.createMethod("VisualServer", "material_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, arg_parameter),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_set_param, base, cargs, result);
    }

    pub fn materialSetRenderPriority(self: *const Self, arg_material: *const godot.RID, arg_priority: i32) !void {
        if (mbind_material_set_render_priority == null) {
            mbind_material_set_render_priority = try api.createMethod("VisualServer", "material_set_render_priority");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_material),
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_set_render_priority, base, cargs, result);
    }

    pub fn materialSetShader(self: *const Self, arg_shader_material: *const godot.RID, arg_shader: *const godot.RID) !void {
        if (mbind_material_set_shader == null) {
            mbind_material_set_shader = try api.createMethod("VisualServer", "material_set_shader");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader_material),
            @ptrCast(*const anyopaque, arg_shader),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_material_set_shader, base, cargs, result);
    }

    pub fn meshAddSurfaceFromArrays(self: *const Self, arg_mesh: *const godot.RID, arg_primitive: i32, arg_arrays: *const godot.Array, arg_blend_shapes: *const godot.Array, arg_compress_format: i32) !void {
        if (mbind_mesh_add_surface_from_arrays == null) {
            mbind_mesh_add_surface_from_arrays = try api.createMethod("VisualServer", "mesh_add_surface_from_arrays");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_primitive),
            @ptrCast(*const anyopaque, arg_arrays),
            @ptrCast(*const anyopaque, arg_blend_shapes),
            @ptrCast(*const anyopaque, *arg_compress_format),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_add_surface_from_arrays, base, cargs, result);
    }

    pub fn meshClear(self: *const Self, arg_mesh: *const godot.RID) !void {
        if (mbind_mesh_clear == null) {
            mbind_mesh_clear = try api.createMethod("VisualServer", "mesh_clear");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_clear, base, cargs, result);
    }

    pub fn meshCreate(self: *const Self) !godot.RID {
        if (mbind_mesh_create == null) {
            mbind_mesh_create = try api.createMethod("VisualServer", "mesh_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn meshGetBlendShapeCount(self: *const Self, arg_mesh: *const godot.RID) !i32 {
        if (mbind_mesh_get_blend_shape_count == null) {
            mbind_mesh_get_blend_shape_count = try api.createMethod("VisualServer", "mesh_get_blend_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_get_blend_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshGetBlendShapeMode(self: *const Self, arg_mesh: *const godot.RID) !i32 {
        if (mbind_mesh_get_blend_shape_mode == null) {
            mbind_mesh_get_blend_shape_mode = try api.createMethod("VisualServer", "mesh_get_blend_shape_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_get_blend_shape_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshGetCustomAabb(self: *const Self, arg_mesh: *const godot.RID) !godot.AABB {
        if (mbind_mesh_get_custom_aabb == null) {
            mbind_mesh_get_custom_aabb = try api.createMethod("VisualServer", "mesh_get_custom_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_get_custom_aabb, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn meshGetSurfaceCount(self: *const Self, arg_mesh: *const godot.RID) !i32 {
        if (mbind_mesh_get_surface_count == null) {
            mbind_mesh_get_surface_count = try api.createMethod("VisualServer", "mesh_get_surface_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_get_surface_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshRemoveSurface(self: *const Self, arg_mesh: *const godot.RID, arg_index: i32) !void {
        if (mbind_mesh_remove_surface == null) {
            mbind_mesh_remove_surface = try api.createMethod("VisualServer", "mesh_remove_surface");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_remove_surface, base, cargs, result);
    }

    pub fn meshSetBlendShapeCount(self: *const Self, arg_mesh: *const godot.RID, arg_amount: i32) !void {
        if (mbind_mesh_set_blend_shape_count == null) {
            mbind_mesh_set_blend_shape_count = try api.createMethod("VisualServer", "mesh_set_blend_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_set_blend_shape_count, base, cargs, result);
    }

    pub fn meshSetBlendShapeMode(self: *const Self, arg_mesh: *const godot.RID, arg_mode: i32) !void {
        if (mbind_mesh_set_blend_shape_mode == null) {
            mbind_mesh_set_blend_shape_mode = try api.createMethod("VisualServer", "mesh_set_blend_shape_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_set_blend_shape_mode, base, cargs, result);
    }

    pub fn meshSetCustomAabb(self: *const Self, arg_mesh: *const godot.RID, arg_aabb: *const godot.AABB) !void {
        if (mbind_mesh_set_custom_aabb == null) {
            mbind_mesh_set_custom_aabb = try api.createMethod("VisualServer", "mesh_set_custom_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, arg_aabb),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_set_custom_aabb, base, cargs, result);
    }

    pub fn meshSurfaceGetAabb(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.AABB {
        if (mbind_mesh_surface_get_aabb == null) {
            mbind_mesh_surface_get_aabb = try api.createMethod("VisualServer", "mesh_surface_get_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_aabb, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn meshSurfaceGetArray(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.PoolByteArray {
        if (mbind_mesh_surface_get_array == null) {
            mbind_mesh_surface_get_array = try api.createMethod("VisualServer", "mesh_surface_get_array");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_array, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn meshSurfaceGetArrayIndexLen(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !i32 {
        if (mbind_mesh_surface_get_array_index_len == null) {
            mbind_mesh_surface_get_array_index_len = try api.createMethod("VisualServer", "mesh_surface_get_array_index_len");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_array_index_len, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetArrayLen(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !i32 {
        if (mbind_mesh_surface_get_array_len == null) {
            mbind_mesh_surface_get_array_len = try api.createMethod("VisualServer", "mesh_surface_get_array_len");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_array_len, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetArrays(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.Array {
        if (mbind_mesh_surface_get_arrays == null) {
            mbind_mesh_surface_get_arrays = try api.createMethod("VisualServer", "mesh_surface_get_arrays");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_arrays, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn meshSurfaceGetBlendShapeArrays(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.Array {
        if (mbind_mesh_surface_get_blend_shape_arrays == null) {
            mbind_mesh_surface_get_blend_shape_arrays = try api.createMethod("VisualServer", "mesh_surface_get_blend_shape_arrays");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_blend_shape_arrays, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn meshSurfaceGetFormat(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !i32 {
        if (mbind_mesh_surface_get_format == null) {
            mbind_mesh_surface_get_format = try api.createMethod("VisualServer", "mesh_surface_get_format");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_format, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetFormatOffset(self: *const Self, arg_format: i32, arg_vertex_len: i32, arg_index_len: i32, arg_array_index: i32) !i32 {
        if (mbind_mesh_surface_get_format_offset == null) {
            mbind_mesh_surface_get_format_offset = try api.createMethod("VisualServer", "mesh_surface_get_format_offset");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_format),
            @ptrCast(*const anyopaque, *arg_vertex_len),
            @ptrCast(*const anyopaque, *arg_index_len),
            @ptrCast(*const anyopaque, *arg_array_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_format_offset, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetFormatStride(self: *const Self, arg_format: i32, arg_vertex_len: i32, arg_index_len: i32, arg_array_index: i32) !i32 {
        if (mbind_mesh_surface_get_format_stride == null) {
            mbind_mesh_surface_get_format_stride = try api.createMethod("VisualServer", "mesh_surface_get_format_stride");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_format),
            @ptrCast(*const anyopaque, *arg_vertex_len),
            @ptrCast(*const anyopaque, *arg_index_len),
            @ptrCast(*const anyopaque, *arg_array_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_format_stride, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetIndexArray(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.PoolByteArray {
        if (mbind_mesh_surface_get_index_array == null) {
            mbind_mesh_surface_get_index_array = try api.createMethod("VisualServer", "mesh_surface_get_index_array");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_index_array, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn meshSurfaceGetMaterial(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.RID {
        if (mbind_mesh_surface_get_material == null) {
            mbind_mesh_surface_get_material = try api.createMethod("VisualServer", "mesh_surface_get_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_material, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn meshSurfaceGetPrimitiveType(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !i32 {
        if (mbind_mesh_surface_get_primitive_type == null) {
            mbind_mesh_surface_get_primitive_type = try api.createMethod("VisualServer", "mesh_surface_get_primitive_type");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_primitive_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn meshSurfaceGetSkeletonAabb(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32) !godot.Array {
        if (mbind_mesh_surface_get_skeleton_aabb == null) {
            mbind_mesh_surface_get_skeleton_aabb = try api.createMethod("VisualServer", "mesh_surface_get_skeleton_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_get_skeleton_aabb, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn meshSurfaceSetMaterial(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32, arg_material: *const godot.RID) !void {
        if (mbind_mesh_surface_set_material == null) {
            mbind_mesh_surface_set_material = try api.createMethod("VisualServer", "mesh_surface_set_material");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_set_material, base, cargs, result);
    }

    pub fn meshSurfaceUpdateRegion(self: *const Self, arg_mesh: *const godot.RID, arg_surface: i32, arg_offset: i32, arg_data: *const godot.PoolByteArray) !void {
        if (mbind_mesh_surface_update_region == null) {
            mbind_mesh_surface_update_region = try api.createMethod("VisualServer", "mesh_surface_update_region");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
            @ptrCast(*const anyopaque, *arg_surface),
            @ptrCast(*const anyopaque, *arg_offset),
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mesh_surface_update_region, base, cargs, result);
    }

    pub fn multimeshAllocate(self: *const Self, arg_multimesh: *const godot.RID, arg_instances: i32, arg_transform_format: i32, arg_color_format: i32, arg_custom_data_format: i32) !void {
        if (mbind_multimesh_allocate == null) {
            mbind_multimesh_allocate = try api.createMethod("VisualServer", "multimesh_allocate");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_instances),
            @ptrCast(*const anyopaque, *arg_transform_format),
            @ptrCast(*const anyopaque, *arg_color_format),
            @ptrCast(*const anyopaque, *arg_custom_data_format),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_allocate, base, cargs, result);
    }

    pub fn multimeshCreate(self: *const Self) !godot.RID {
        if (mbind_multimesh_create == null) {
            mbind_multimesh_create = try api.createMethod("VisualServer", "multimesh_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn multimeshGetAabb(self: *const Self, arg_multimesh: *const godot.RID) !godot.AABB {
        if (mbind_multimesh_get_aabb == null) {
            mbind_multimesh_get_aabb = try api.createMethod("VisualServer", "multimesh_get_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_get_aabb, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn multimeshGetInstanceCount(self: *const Self, arg_multimesh: *const godot.RID) !i32 {
        if (mbind_multimesh_get_instance_count == null) {
            mbind_multimesh_get_instance_count = try api.createMethod("VisualServer", "multimesh_get_instance_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_get_instance_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn multimeshGetMesh(self: *const Self, arg_multimesh: *const godot.RID) !godot.RID {
        if (mbind_multimesh_get_mesh == null) {
            mbind_multimesh_get_mesh = try api.createMethod("VisualServer", "multimesh_get_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_get_mesh, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn multimeshGetVisibleInstances(self: *const Self, arg_multimesh: *const godot.RID) !i32 {
        if (mbind_multimesh_get_visible_instances == null) {
            mbind_multimesh_get_visible_instances = try api.createMethod("VisualServer", "multimesh_get_visible_instances");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_get_visible_instances, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn multimeshInstanceGetColor(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32) !godot.Color {
        if (mbind_multimesh_instance_get_color == null) {
            mbind_multimesh_instance_get_color = try api.createMethod("VisualServer", "multimesh_instance_get_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_get_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn multimeshInstanceGetCustomData(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32) !godot.Color {
        if (mbind_multimesh_instance_get_custom_data == null) {
            mbind_multimesh_instance_get_custom_data = try api.createMethod("VisualServer", "multimesh_instance_get_custom_data");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_get_custom_data, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn multimeshInstanceGetTransform(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32) !godot.Transform {
        if (mbind_multimesh_instance_get_transform == null) {
            mbind_multimesh_instance_get_transform = try api.createMethod("VisualServer", "multimesh_instance_get_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn multimeshInstanceGetTransform2d(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32) !godot.Transform2D {
        if (mbind_multimesh_instance_get_transform_2d == null) {
            mbind_multimesh_instance_get_transform_2d = try api.createMethod("VisualServer", "multimesh_instance_get_transform_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_get_transform_2d, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn multimeshInstanceSetColor(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32, arg_color: *const godot.Color) !void {
        if (mbind_multimesh_instance_set_color == null) {
            mbind_multimesh_instance_set_color = try api.createMethod("VisualServer", "multimesh_instance_set_color");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_set_color, base, cargs, result);
    }

    pub fn multimeshInstanceSetCustomData(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32, arg_custom_data: *const godot.Color) !void {
        if (mbind_multimesh_instance_set_custom_data == null) {
            mbind_multimesh_instance_set_custom_data = try api.createMethod("VisualServer", "multimesh_instance_set_custom_data");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_custom_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_set_custom_data, base, cargs, result);
    }

    pub fn multimeshInstanceSetTransform(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32, arg_transform: *const godot.Transform) !void {
        if (mbind_multimesh_instance_set_transform == null) {
            mbind_multimesh_instance_set_transform = try api.createMethod("VisualServer", "multimesh_instance_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_set_transform, base, cargs, result);
    }

    pub fn multimeshInstanceSetTransform2d(self: *const Self, arg_multimesh: *const godot.RID, arg_index: i32, arg_transform: *const godot.Transform2D) !void {
        if (mbind_multimesh_instance_set_transform_2d == null) {
            mbind_multimesh_instance_set_transform_2d = try api.createMethod("VisualServer", "multimesh_instance_set_transform_2d");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_instance_set_transform_2d, base, cargs, result);
    }

    pub fn multimeshSetAsBulkArray(self: *const Self, arg_multimesh: *const godot.RID, arg_array: *const godot.PoolRealArray) !void {
        if (mbind_multimesh_set_as_bulk_array == null) {
            mbind_multimesh_set_as_bulk_array = try api.createMethod("VisualServer", "multimesh_set_as_bulk_array");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, arg_array),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_set_as_bulk_array, base, cargs, result);
    }

    pub fn multimeshSetMesh(self: *const Self, arg_multimesh: *const godot.RID, arg_mesh: *const godot.RID) !void {
        if (mbind_multimesh_set_mesh == null) {
            mbind_multimesh_set_mesh = try api.createMethod("VisualServer", "multimesh_set_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_set_mesh, base, cargs, result);
    }

    pub fn multimeshSetVisibleInstances(self: *const Self, arg_multimesh: *const godot.RID, arg_visible: i32) !void {
        if (mbind_multimesh_set_visible_instances == null) {
            mbind_multimesh_set_visible_instances = try api.createMethod("VisualServer", "multimesh_set_visible_instances");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multimesh),
            @ptrCast(*const anyopaque, *arg_visible),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_multimesh_set_visible_instances, base, cargs, result);
    }

    pub fn omniLightCreate(self: *const Self) !godot.RID {
        if (mbind_omni_light_create == null) {
            mbind_omni_light_create = try api.createMethod("VisualServer", "omni_light_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_omni_light_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn particlesCreate(self: *const Self) !godot.RID {
        if (mbind_particles_create == null) {
            mbind_particles_create = try api.createMethod("VisualServer", "particles_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn particlesGetCurrentAabb(self: *const Self, arg_particles: *const godot.RID) !godot.AABB {
        if (mbind_particles_get_current_aabb == null) {
            mbind_particles_get_current_aabb = try api.createMethod("VisualServer", "particles_get_current_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_get_current_aabb, base, cargs, result);
        return @ptrCast(*godot.AABB, @alignCast(@alignOf(&godot.AABB), result)).*;
    }

    pub fn particlesGetEmitting(self: *const Self, arg_particles: *const godot.RID) !bool {
        if (mbind_particles_get_emitting == null) {
            mbind_particles_get_emitting = try api.createMethod("VisualServer", "particles_get_emitting");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_get_emitting, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn particlesIsInactive(self: *const Self, arg_particles: *const godot.RID) !bool {
        if (mbind_particles_is_inactive == null) {
            mbind_particles_is_inactive = try api.createMethod("VisualServer", "particles_is_inactive");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_is_inactive, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn particlesRequestProcess(self: *const Self, arg_particles: *const godot.RID) !void {
        if (mbind_particles_request_process == null) {
            mbind_particles_request_process = try api.createMethod("VisualServer", "particles_request_process");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_request_process, base, cargs, result);
    }

    pub fn particlesRestart(self: *const Self, arg_particles: *const godot.RID) !void {
        if (mbind_particles_restart == null) {
            mbind_particles_restart = try api.createMethod("VisualServer", "particles_restart");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_restart, base, cargs, result);
    }

    pub fn particlesSetAmount(self: *const Self, arg_particles: *const godot.RID, arg_amount: i32) !void {
        if (mbind_particles_set_amount == null) {
            mbind_particles_set_amount = try api.createMethod("VisualServer", "particles_set_amount");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_amount, base, cargs, result);
    }

    pub fn particlesSetCustomAabb(self: *const Self, arg_particles: *const godot.RID, arg_aabb: *const godot.AABB) !void {
        if (mbind_particles_set_custom_aabb == null) {
            mbind_particles_set_custom_aabb = try api.createMethod("VisualServer", "particles_set_custom_aabb");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, arg_aabb),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_custom_aabb, base, cargs, result);
    }

    pub fn particlesSetDrawOrder(self: *const Self, arg_particles: *const godot.RID, arg_order: i32) !void {
        if (mbind_particles_set_draw_order == null) {
            mbind_particles_set_draw_order = try api.createMethod("VisualServer", "particles_set_draw_order");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_order),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_draw_order, base, cargs, result);
    }

    pub fn particlesSetDrawPassMesh(self: *const Self, arg_particles: *const godot.RID, arg_pass: i32, arg_mesh: *const godot.RID) !void {
        if (mbind_particles_set_draw_pass_mesh == null) {
            mbind_particles_set_draw_pass_mesh = try api.createMethod("VisualServer", "particles_set_draw_pass_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_pass),
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_draw_pass_mesh, base, cargs, result);
    }

    pub fn particlesSetDrawPasses(self: *const Self, arg_particles: *const godot.RID, arg_count: i32) !void {
        if (mbind_particles_set_draw_passes == null) {
            mbind_particles_set_draw_passes = try api.createMethod("VisualServer", "particles_set_draw_passes");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_count),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_draw_passes, base, cargs, result);
    }

    pub fn particlesSetEmissionTransform(self: *const Self, arg_particles: *const godot.RID, arg_transform: *const godot.Transform) !void {
        if (mbind_particles_set_emission_transform == null) {
            mbind_particles_set_emission_transform = try api.createMethod("VisualServer", "particles_set_emission_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_emission_transform, base, cargs, result);
    }

    pub fn particlesSetEmitting(self: *const Self, arg_particles: *const godot.RID, arg_emitting: bool) !void {
        if (mbind_particles_set_emitting == null) {
            mbind_particles_set_emitting = try api.createMethod("VisualServer", "particles_set_emitting");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_emitting),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_emitting, base, cargs, result);
    }

    pub fn particlesSetExplosivenessRatio(self: *const Self, arg_particles: *const godot.RID, arg_ratio: f32) !void {
        if (mbind_particles_set_explosiveness_ratio == null) {
            mbind_particles_set_explosiveness_ratio = try api.createMethod("VisualServer", "particles_set_explosiveness_ratio");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_ratio),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_explosiveness_ratio, base, cargs, result);
    }

    pub fn particlesSetFixedFps(self: *const Self, arg_particles: *const godot.RID, arg_fps: i32) !void {
        if (mbind_particles_set_fixed_fps == null) {
            mbind_particles_set_fixed_fps = try api.createMethod("VisualServer", "particles_set_fixed_fps");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_fps),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_fixed_fps, base, cargs, result);
    }

    pub fn particlesSetFractionalDelta(self: *const Self, arg_particles: *const godot.RID, arg_enable: bool) !void {
        if (mbind_particles_set_fractional_delta == null) {
            mbind_particles_set_fractional_delta = try api.createMethod("VisualServer", "particles_set_fractional_delta");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_fractional_delta, base, cargs, result);
    }

    pub fn particlesSetLifetime(self: *const Self, arg_particles: *const godot.RID, arg_lifetime: f32) !void {
        if (mbind_particles_set_lifetime == null) {
            mbind_particles_set_lifetime = try api.createMethod("VisualServer", "particles_set_lifetime");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_lifetime),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_lifetime, base, cargs, result);
    }

    pub fn particlesSetOneShot(self: *const Self, arg_particles: *const godot.RID, arg_one_shot: bool) !void {
        if (mbind_particles_set_one_shot == null) {
            mbind_particles_set_one_shot = try api.createMethod("VisualServer", "particles_set_one_shot");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_one_shot),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_one_shot, base, cargs, result);
    }

    pub fn particlesSetPreProcessTime(self: *const Self, arg_particles: *const godot.RID, arg_time: f32) !void {
        if (mbind_particles_set_pre_process_time == null) {
            mbind_particles_set_pre_process_time = try api.createMethod("VisualServer", "particles_set_pre_process_time");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_time),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_pre_process_time, base, cargs, result);
    }

    pub fn particlesSetProcessMaterial(self: *const Self, arg_particles: *const godot.RID, arg_material: *const godot.RID) !void {
        if (mbind_particles_set_process_material == null) {
            mbind_particles_set_process_material = try api.createMethod("VisualServer", "particles_set_process_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_process_material, base, cargs, result);
    }

    pub fn particlesSetRandomnessRatio(self: *const Self, arg_particles: *const godot.RID, arg_ratio: f32) !void {
        if (mbind_particles_set_randomness_ratio == null) {
            mbind_particles_set_randomness_ratio = try api.createMethod("VisualServer", "particles_set_randomness_ratio");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_ratio),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_randomness_ratio, base, cargs, result);
    }

    pub fn particlesSetSpeedScale(self: *const Self, arg_particles: *const godot.RID, arg_scale: f32) !void {
        if (mbind_particles_set_speed_scale == null) {
            mbind_particles_set_speed_scale = try api.createMethod("VisualServer", "particles_set_speed_scale");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_speed_scale, base, cargs, result);
    }

    pub fn particlesSetUseLocalCoordinates(self: *const Self, arg_particles: *const godot.RID, arg_enable: bool) !void {
        if (mbind_particles_set_use_local_coordinates == null) {
            mbind_particles_set_use_local_coordinates = try api.createMethod("VisualServer", "particles_set_use_local_coordinates");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_particles),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_particles_set_use_local_coordinates, base, cargs, result);
    }

    pub fn reflectionProbeCreate(self: *const Self) !godot.RID {
        if (mbind_reflection_probe_create == null) {
            mbind_reflection_probe_create = try api.createMethod("VisualServer", "reflection_probe_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn reflectionProbeSetAsInterior(self: *const Self, arg_probe: *const godot.RID, arg_enable: bool) !void {
        if (mbind_reflection_probe_set_as_interior == null) {
            mbind_reflection_probe_set_as_interior = try api.createMethod("VisualServer", "reflection_probe_set_as_interior");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_as_interior, base, cargs, result);
    }

    pub fn reflectionProbeSetCullMask(self: *const Self, arg_probe: *const godot.RID, arg_layers: i32) !void {
        if (mbind_reflection_probe_set_cull_mask == null) {
            mbind_reflection_probe_set_cull_mask = try api.createMethod("VisualServer", "reflection_probe_set_cull_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_layers),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_cull_mask, base, cargs, result);
    }

    pub fn reflectionProbeSetEnableBoxProjection(self: *const Self, arg_probe: *const godot.RID, arg_enable: bool) !void {
        if (mbind_reflection_probe_set_enable_box_projection == null) {
            mbind_reflection_probe_set_enable_box_projection = try api.createMethod("VisualServer", "reflection_probe_set_enable_box_projection");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_enable_box_projection, base, cargs, result);
    }

    pub fn reflectionProbeSetEnableShadows(self: *const Self, arg_probe: *const godot.RID, arg_enable: bool) !void {
        if (mbind_reflection_probe_set_enable_shadows == null) {
            mbind_reflection_probe_set_enable_shadows = try api.createMethod("VisualServer", "reflection_probe_set_enable_shadows");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_enable_shadows, base, cargs, result);
    }

    pub fn reflectionProbeSetExtents(self: *const Self, arg_probe: *const godot.RID, arg_extents: *const godot.Vector3) !void {
        if (mbind_reflection_probe_set_extents == null) {
            mbind_reflection_probe_set_extents = try api.createMethod("VisualServer", "reflection_probe_set_extents");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_extents),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_extents, base, cargs, result);
    }

    pub fn reflectionProbeSetIntensity(self: *const Self, arg_probe: *const godot.RID, arg_intensity: f32) !void {
        if (mbind_reflection_probe_set_intensity == null) {
            mbind_reflection_probe_set_intensity = try api.createMethod("VisualServer", "reflection_probe_set_intensity");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_intensity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_intensity, base, cargs, result);
    }

    pub fn reflectionProbeSetInteriorAmbient(self: *const Self, arg_probe: *const godot.RID, arg_color: *const godot.Color) !void {
        if (mbind_reflection_probe_set_interior_ambient == null) {
            mbind_reflection_probe_set_interior_ambient = try api.createMethod("VisualServer", "reflection_probe_set_interior_ambient");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_interior_ambient, base, cargs, result);
    }

    pub fn reflectionProbeSetInteriorAmbientEnergy(self: *const Self, arg_probe: *const godot.RID, arg_energy: f32) !void {
        if (mbind_reflection_probe_set_interior_ambient_energy == null) {
            mbind_reflection_probe_set_interior_ambient_energy = try api.createMethod("VisualServer", "reflection_probe_set_interior_ambient_energy");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_interior_ambient_energy, base, cargs, result);
    }

    pub fn reflectionProbeSetInteriorAmbientProbeContribution(self: *const Self, arg_probe: *const godot.RID, arg_contrib: f32) !void {
        if (mbind_reflection_probe_set_interior_ambient_probe_contribution == null) {
            mbind_reflection_probe_set_interior_ambient_probe_contribution = try api.createMethod("VisualServer", "reflection_probe_set_interior_ambient_probe_contribution");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_contrib),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_interior_ambient_probe_contribution, base, cargs, result);
    }

    pub fn reflectionProbeSetMaxDistance(self: *const Self, arg_probe: *const godot.RID, arg_distance: f32) !void {
        if (mbind_reflection_probe_set_max_distance == null) {
            mbind_reflection_probe_set_max_distance = try api.createMethod("VisualServer", "reflection_probe_set_max_distance");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_distance),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_max_distance, base, cargs, result);
    }

    pub fn reflectionProbeSetOriginOffset(self: *const Self, arg_probe: *const godot.RID, arg_offset: *const godot.Vector3) !void {
        if (mbind_reflection_probe_set_origin_offset == null) {
            mbind_reflection_probe_set_origin_offset = try api.createMethod("VisualServer", "reflection_probe_set_origin_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_origin_offset, base, cargs, result);
    }

    pub fn reflectionProbeSetUpdateMode(self: *const Self, arg_probe: *const godot.RID, arg_mode: i32) !void {
        if (mbind_reflection_probe_set_update_mode == null) {
            mbind_reflection_probe_set_update_mode = try api.createMethod("VisualServer", "reflection_probe_set_update_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_probe),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reflection_probe_set_update_mode, base, cargs, result);
    }

    pub fn requestFrameDrawnCallback(self: *const Self, arg_where: *const godot.Object, arg_method: *const godot.String, arg_userdata: *const godot.Variant) !void {
        if (mbind_request_frame_drawn_callback == null) {
            mbind_request_frame_drawn_callback = try api.createMethod("VisualServer", "request_frame_drawn_callback");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_where),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_userdata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_request_frame_drawn_callback, base, cargs, result);
    }

    pub fn scenarioCreate(self: *const Self) !godot.RID {
        if (mbind_scenario_create == null) {
            mbind_scenario_create = try api.createMethod("VisualServer", "scenario_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scenario_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn scenarioSetDebug(self: *const Self, arg_scenario: *const godot.RID, arg_debug_mode: i32) !void {
        if (mbind_scenario_set_debug == null) {
            mbind_scenario_set_debug = try api.createMethod("VisualServer", "scenario_set_debug");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scenario),
            @ptrCast(*const anyopaque, *arg_debug_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scenario_set_debug, base, cargs, result);
    }

    pub fn scenarioSetEnvironment(self: *const Self, arg_scenario: *const godot.RID, arg_environment: *const godot.RID) !void {
        if (mbind_scenario_set_environment == null) {
            mbind_scenario_set_environment = try api.createMethod("VisualServer", "scenario_set_environment");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scenario),
            @ptrCast(*const anyopaque, arg_environment),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scenario_set_environment, base, cargs, result);
    }

    pub fn scenarioSetFallbackEnvironment(self: *const Self, arg_scenario: *const godot.RID, arg_environment: *const godot.RID) !void {
        if (mbind_scenario_set_fallback_environment == null) {
            mbind_scenario_set_fallback_environment = try api.createMethod("VisualServer", "scenario_set_fallback_environment");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scenario),
            @ptrCast(*const anyopaque, arg_environment),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scenario_set_fallback_environment, base, cargs, result);
    }

    pub fn scenarioSetReflectionAtlasSize(self: *const Self, arg_scenario: *const godot.RID, arg_size: i32, arg_subdiv: i32) !void {
        if (mbind_scenario_set_reflection_atlas_size == null) {
            mbind_scenario_set_reflection_atlas_size = try api.createMethod("VisualServer", "scenario_set_reflection_atlas_size");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scenario),
            @ptrCast(*const anyopaque, *arg_size),
            @ptrCast(*const anyopaque, *arg_subdiv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scenario_set_reflection_atlas_size, base, cargs, result);
    }

    pub fn setBootImage(self: *const Self, arg_image: *const godot.Image, arg_color: *const godot.Color, arg_scale: bool, arg_use_filter: bool) !void {
        if (mbind_set_boot_image == null) {
            mbind_set_boot_image = try api.createMethod("VisualServer", "set_boot_image");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_image),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_scale),
            @ptrCast(*const anyopaque, *arg_use_filter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_boot_image, base, cargs, result);
    }

    pub fn setDebugGenerateWireframes(self: *const Self, arg_generate: bool) !void {
        if (mbind_set_debug_generate_wireframes == null) {
            mbind_set_debug_generate_wireframes = try api.createMethod("VisualServer", "set_debug_generate_wireframes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_generate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_debug_generate_wireframes, base, cargs, result);
    }

    pub fn setDefaultClearColor(self: *const Self, arg_color: *const godot.Color) !void {
        if (mbind_set_default_clear_color == null) {
            mbind_set_default_clear_color = try api.createMethod("VisualServer", "set_default_clear_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_default_clear_color, base, cargs, result);
    }

    pub fn setRenderLoopEnabled(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_render_loop_enabled == null) {
            mbind_set_render_loop_enabled = try api.createMethod("VisualServer", "set_render_loop_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_render_loop_enabled, base, cargs, result);
    }

    pub fn setShaderTimeScale(self: *const Self, arg_scale: f32) !void {
        if (mbind_set_shader_time_scale == null) {
            mbind_set_shader_time_scale = try api.createMethod("VisualServer", "set_shader_time_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_shader_time_scale, base, cargs, result);
    }

    pub fn setUseOcclusionCulling(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_occlusion_culling == null) {
            mbind_set_use_occlusion_culling = try api.createMethod("VisualServer", "set_use_occlusion_culling");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_occlusion_culling, base, cargs, result);
    }

    pub fn shaderCreate(self: *const Self) !godot.RID {
        if (mbind_shader_create == null) {
            mbind_shader_create = try api.createMethod("VisualServer", "shader_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn shaderGetCode(self: *const Self, arg_shader: *const godot.RID) !godot.String {
        if (mbind_shader_get_code == null) {
            mbind_shader_get_code = try api.createMethod("VisualServer", "shader_get_code");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_get_code, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn shaderGetDefaultTextureParam(self: *const Self, arg_shader: *const godot.RID, arg_name: *const godot.String) !godot.RID {
        if (mbind_shader_get_default_texture_param == null) {
            mbind_shader_get_default_texture_param = try api.createMethod("VisualServer", "shader_get_default_texture_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader),
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_get_default_texture_param, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn shaderGetParamList(self: *const Self, arg_shader: *const godot.RID) !godot.Array {
        if (mbind_shader_get_param_list == null) {
            mbind_shader_get_param_list = try api.createMethod("VisualServer", "shader_get_param_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_get_param_list, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn shaderSetCode(self: *const Self, arg_shader: *const godot.RID, arg_code: *const godot.String) !void {
        if (mbind_shader_set_code == null) {
            mbind_shader_set_code = try api.createMethod("VisualServer", "shader_set_code");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader),
            @ptrCast(*const anyopaque, arg_code),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_set_code, base, cargs, result);
    }

    pub fn shaderSetDefaultTextureParam(self: *const Self, arg_shader: *const godot.RID, arg_name: *const godot.String, arg_texture: *const godot.RID) !void {
        if (mbind_shader_set_default_texture_param == null) {
            mbind_shader_set_default_texture_param = try api.createMethod("VisualServer", "shader_set_default_texture_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shader),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shader_set_default_texture_param, base, cargs, result);
    }

    pub fn skeletonAllocate(self: *const Self, arg_skeleton: *const godot.RID, arg_bones: i32, arg_is_2d_skeleton: bool) !void {
        if (mbind_skeleton_allocate == null) {
            mbind_skeleton_allocate = try api.createMethod("VisualServer", "skeleton_allocate");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
            @ptrCast(*const anyopaque, *arg_bones),
            @ptrCast(*const anyopaque, *arg_is_2d_skeleton),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_allocate, base, cargs, result);
    }

    pub fn skeletonBoneGetTransform(self: *const Self, arg_skeleton: *const godot.RID, arg_bone: i32) !godot.Transform {
        if (mbind_skeleton_bone_get_transform == null) {
            mbind_skeleton_bone_get_transform = try api.createMethod("VisualServer", "skeleton_bone_get_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
            @ptrCast(*const anyopaque, *arg_bone),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_bone_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn skeletonBoneGetTransform2d(self: *const Self, arg_skeleton: *const godot.RID, arg_bone: i32) !godot.Transform2D {
        if (mbind_skeleton_bone_get_transform_2d == null) {
            mbind_skeleton_bone_get_transform_2d = try api.createMethod("VisualServer", "skeleton_bone_get_transform_2d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
            @ptrCast(*const anyopaque, *arg_bone),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_bone_get_transform_2d, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn skeletonBoneSetTransform(self: *const Self, arg_skeleton: *const godot.RID, arg_bone: i32, arg_transform: *const godot.Transform) !void {
        if (mbind_skeleton_bone_set_transform == null) {
            mbind_skeleton_bone_set_transform = try api.createMethod("VisualServer", "skeleton_bone_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
            @ptrCast(*const anyopaque, *arg_bone),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_bone_set_transform, base, cargs, result);
    }

    pub fn skeletonBoneSetTransform2d(self: *const Self, arg_skeleton: *const godot.RID, arg_bone: i32, arg_transform: *const godot.Transform2D) !void {
        if (mbind_skeleton_bone_set_transform_2d == null) {
            mbind_skeleton_bone_set_transform_2d = try api.createMethod("VisualServer", "skeleton_bone_set_transform_2d");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
            @ptrCast(*const anyopaque, *arg_bone),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_bone_set_transform_2d, base, cargs, result);
    }

    pub fn skeletonCreate(self: *const Self) !godot.RID {
        if (mbind_skeleton_create == null) {
            mbind_skeleton_create = try api.createMethod("VisualServer", "skeleton_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn skeletonGetBoneCount(self: *const Self, arg_skeleton: *const godot.RID) !i32 {
        if (mbind_skeleton_get_bone_count == null) {
            mbind_skeleton_get_bone_count = try api.createMethod("VisualServer", "skeleton_get_bone_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skeleton_get_bone_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn skyCreate(self: *const Self) !godot.RID {
        if (mbind_sky_create == null) {
            mbind_sky_create = try api.createMethod("VisualServer", "sky_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_sky_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn skySetTexture(self: *const Self, arg_sky: *const godot.RID, arg_cube_map: *const godot.RID, arg_radiance_size: i32) !void {
        if (mbind_sky_set_texture == null) {
            mbind_sky_set_texture = try api.createMethod("VisualServer", "sky_set_texture");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_sky),
            @ptrCast(*const anyopaque, arg_cube_map),
            @ptrCast(*const anyopaque, *arg_radiance_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_sky_set_texture, base, cargs, result);
    }

    pub fn spotLightCreate(self: *const Self) !godot.RID {
        if (mbind_spot_light_create == null) {
            mbind_spot_light_create = try api.createMethod("VisualServer", "spot_light_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_spot_light_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn sync(self: *const Self) !void {
        if (mbind_sync == null) {
            mbind_sync = try api.createMethod("VisualServer", "sync");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_sync, base, cargs, result);
    }

    pub fn textureAllocate(self: *const Self, arg_texture: *const godot.RID, arg_width: i32, arg_height: i32, arg_depth_3d: i32, arg_format: i32, arg_type: i32, arg_flags: i32) !void {
        if (mbind_texture_allocate == null) {
            mbind_texture_allocate = try api.createMethod("VisualServer", "texture_allocate");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_depth_3d),
            @ptrCast(*const anyopaque, *arg_format),
            @ptrCast(*const anyopaque, *arg_type),
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_allocate, base, cargs, result);
    }

    pub fn textureBind(self: *const Self, arg_texture: *const godot.RID, arg_number: i32) !void {
        if (mbind_texture_bind == null) {
            mbind_texture_bind = try api.createMethod("VisualServer", "texture_bind");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_number),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_bind, base, cargs, result);
    }

    pub fn textureCreate(self: *const Self) !godot.RID {
        if (mbind_texture_create == null) {
            mbind_texture_create = try api.createMethod("VisualServer", "texture_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn textureCreateFromImage(self: *const Self, arg_image: *const godot.Image, arg_flags: i32) !godot.RID {
        if (mbind_texture_create_from_image == null) {
            mbind_texture_create_from_image = try api.createMethod("VisualServer", "texture_create_from_image");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_image),
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_create_from_image, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn textureDebugUsage(self: *const Self) !godot.Array {
        if (mbind_texture_debug_usage == null) {
            mbind_texture_debug_usage = try api.createMethod("VisualServer", "texture_debug_usage");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_debug_usage, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn textureGetData(self: *const Self, arg_texture: *const godot.RID, arg_cube_side: i32) !godot.Image {
        if (mbind_texture_get_data == null) {
            mbind_texture_get_data = try api.createMethod("VisualServer", "texture_get_data");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_cube_side),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_data, base, cargs, result);
        return @ptrCast(*godot.Image, @alignCast(@alignOf(&godot.Image), result)).*;
    }

    pub fn textureGetDepth(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_depth == null) {
            mbind_texture_get_depth = try api.createMethod("VisualServer", "texture_get_depth");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_depth, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetFlags(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_flags == null) {
            mbind_texture_get_flags = try api.createMethod("VisualServer", "texture_get_flags");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_flags, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetFormat(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_format == null) {
            mbind_texture_get_format = try api.createMethod("VisualServer", "texture_get_format");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_format, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetHeight(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_height == null) {
            mbind_texture_get_height = try api.createMethod("VisualServer", "texture_get_height");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_height, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetPath(self: *const Self, arg_texture: *const godot.RID) !godot.String {
        if (mbind_texture_get_path == null) {
            mbind_texture_get_path = try api.createMethod("VisualServer", "texture_get_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn textureGetTexid(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_texid == null) {
            mbind_texture_get_texid = try api.createMethod("VisualServer", "texture_get_texid");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_texid, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetType(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_type == null) {
            mbind_texture_get_type = try api.createMethod("VisualServer", "texture_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureGetWidth(self: *const Self, arg_texture: *const godot.RID) !i32 {
        if (mbind_texture_get_width == null) {
            mbind_texture_get_width = try api.createMethod("VisualServer", "texture_get_width");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_get_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn textureSetData(self: *const Self, arg_texture: *const godot.RID, arg_image: *const godot.Image, arg_layer: i32) !void {
        if (mbind_texture_set_data == null) {
            mbind_texture_set_data = try api.createMethod("VisualServer", "texture_set_data");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_image),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_data, base, cargs, result);
    }

    pub fn textureSetDataPartial(self: *const Self, arg_texture: *const godot.RID, arg_image: *const godot.Image, arg_src_x: i32, arg_src_y: i32, arg_src_w: i32, arg_src_h: i32, arg_dst_x: i32, arg_dst_y: i32, arg_dst_mip: i32, arg_layer: i32) !void {
        if (mbind_texture_set_data_partial == null) {
            mbind_texture_set_data_partial = try api.createMethod("VisualServer", "texture_set_data_partial");
        }

        var result: ?*anyopaque = null;
        var args: [10]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_image),
            @ptrCast(*const anyopaque, *arg_src_x),
            @ptrCast(*const anyopaque, *arg_src_y),
            @ptrCast(*const anyopaque, *arg_src_w),
            @ptrCast(*const anyopaque, *arg_src_h),
            @ptrCast(*const anyopaque, *arg_dst_x),
            @ptrCast(*const anyopaque, *arg_dst_y),
            @ptrCast(*const anyopaque, *arg_dst_mip),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_data_partial, base, cargs, result);
    }

    pub fn textureSetFlags(self: *const Self, arg_texture: *const godot.RID, arg_flags: i32) !void {
        if (mbind_texture_set_flags == null) {
            mbind_texture_set_flags = try api.createMethod("VisualServer", "texture_set_flags");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_flags, base, cargs, result);
    }

    pub fn textureSetPath(self: *const Self, arg_texture: *const godot.RID, arg_path: *const godot.String) !void {
        if (mbind_texture_set_path == null) {
            mbind_texture_set_path = try api.createMethod("VisualServer", "texture_set_path");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_path, base, cargs, result);
    }

    pub fn textureSetShrinkAllX2OnSetData(self: *const Self, arg_shrink: bool) !void {
        if (mbind_texture_set_shrink_all_x2_on_set_data == null) {
            mbind_texture_set_shrink_all_x2_on_set_data = try api.createMethod("VisualServer", "texture_set_shrink_all_x2_on_set_data");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_shrink),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_shrink_all_x2_on_set_data, base, cargs, result);
    }

    pub fn textureSetSizeOverride(self: *const Self, arg_texture: *const godot.RID, arg_width: i32, arg_height: i32, arg_depth: i32) !void {
        if (mbind_texture_set_size_override == null) {
            mbind_texture_set_size_override = try api.createMethod("VisualServer", "texture_set_size_override");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_depth),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_texture_set_size_override, base, cargs, result);
    }

    pub fn texturesKeepOriginal(self: *const Self, arg_enable: bool) !void {
        if (mbind_textures_keep_original == null) {
            mbind_textures_keep_original = try api.createMethod("VisualServer", "textures_keep_original");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_textures_keep_original, base, cargs, result);
    }

    pub fn viewportAttachCamera(self: *const Self, arg_viewport: *const godot.RID, arg_camera: *const godot.RID) !void {
        if (mbind_viewport_attach_camera == null) {
            mbind_viewport_attach_camera = try api.createMethod("VisualServer", "viewport_attach_camera");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_camera),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_attach_camera, base, cargs, result);
    }

    pub fn viewportAttachCanvas(self: *const Self, arg_viewport: *const godot.RID, arg_canvas: *const godot.RID) !void {
        if (mbind_viewport_attach_canvas == null) {
            mbind_viewport_attach_canvas = try api.createMethod("VisualServer", "viewport_attach_canvas");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_canvas),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_attach_canvas, base, cargs, result);
    }

    pub fn viewportAttachToScreen(self: *const Self, arg_viewport: *const godot.RID, arg_rect: *const godot.Rect2, arg_screen: i32) !void {
        if (mbind_viewport_attach_to_screen == null) {
            mbind_viewport_attach_to_screen = try api.createMethod("VisualServer", "viewport_attach_to_screen");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_rect),
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_attach_to_screen, base, cargs, result);
    }

    pub fn viewportCreate(self: *const Self) !godot.RID {
        if (mbind_viewport_create == null) {
            mbind_viewport_create = try api.createMethod("VisualServer", "viewport_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn viewportDetach(self: *const Self, arg_viewport: *const godot.RID) !void {
        if (mbind_viewport_detach == null) {
            mbind_viewport_detach = try api.createMethod("VisualServer", "viewport_detach");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_detach, base, cargs, result);
    }

    pub fn viewportGetRenderInfo(self: *const Self, arg_viewport: *const godot.RID, arg_info: i32) !i32 {
        if (mbind_viewport_get_render_info == null) {
            mbind_viewport_get_render_info = try api.createMethod("VisualServer", "viewport_get_render_info");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_info),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_get_render_info, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn viewportGetTexture(self: *const Self, arg_viewport: *const godot.RID) !godot.RID {
        if (mbind_viewport_get_texture == null) {
            mbind_viewport_get_texture = try api.createMethod("VisualServer", "viewport_get_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_get_texture, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn viewportRemoveCanvas(self: *const Self, arg_viewport: *const godot.RID, arg_canvas: *const godot.RID) !void {
        if (mbind_viewport_remove_canvas == null) {
            mbind_viewport_remove_canvas = try api.createMethod("VisualServer", "viewport_remove_canvas");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_canvas),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_remove_canvas, base, cargs, result);
    }

    pub fn viewportSetActive(self: *const Self, arg_viewport: *const godot.RID, arg_active: bool) !void {
        if (mbind_viewport_set_active == null) {
            mbind_viewport_set_active = try api.createMethod("VisualServer", "viewport_set_active");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_active, base, cargs, result);
    }

    pub fn viewportSetCanvasStacking(self: *const Self, arg_viewport: *const godot.RID, arg_canvas: *const godot.RID, arg_layer: i32, arg_sublayer: i32) !void {
        if (mbind_viewport_set_canvas_stacking == null) {
            mbind_viewport_set_canvas_stacking = try api.createMethod("VisualServer", "viewport_set_canvas_stacking");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_canvas),
            @ptrCast(*const anyopaque, *arg_layer),
            @ptrCast(*const anyopaque, *arg_sublayer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_canvas_stacking, base, cargs, result);
    }

    pub fn viewportSetCanvasTransform(self: *const Self, arg_viewport: *const godot.RID, arg_canvas: *const godot.RID, arg_offset: *const godot.Transform2D) !void {
        if (mbind_viewport_set_canvas_transform == null) {
            mbind_viewport_set_canvas_transform = try api.createMethod("VisualServer", "viewport_set_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_canvas),
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_canvas_transform, base, cargs, result);
    }

    pub fn viewportSetClearMode(self: *const Self, arg_viewport: *const godot.RID, arg_clear_mode: i32) !void {
        if (mbind_viewport_set_clear_mode == null) {
            mbind_viewport_set_clear_mode = try api.createMethod("VisualServer", "viewport_set_clear_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_clear_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_clear_mode, base, cargs, result);
    }

    pub fn viewportSetDebugDraw(self: *const Self, arg_viewport: *const godot.RID, arg_draw: i32) !void {
        if (mbind_viewport_set_debug_draw == null) {
            mbind_viewport_set_debug_draw = try api.createMethod("VisualServer", "viewport_set_debug_draw");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_draw),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_debug_draw, base, cargs, result);
    }

    pub fn viewportSetDisable3d(self: *const Self, arg_viewport: *const godot.RID, arg_disabled: bool) !void {
        if (mbind_viewport_set_disable_3d == null) {
            mbind_viewport_set_disable_3d = try api.createMethod("VisualServer", "viewport_set_disable_3d");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_disable_3d, base, cargs, result);
    }

    pub fn viewportSetDisableEnvironment(self: *const Self, arg_viewport: *const godot.RID, arg_disabled: bool) !void {
        if (mbind_viewport_set_disable_environment == null) {
            mbind_viewport_set_disable_environment = try api.createMethod("VisualServer", "viewport_set_disable_environment");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_disable_environment, base, cargs, result);
    }

    pub fn viewportSetGlobalCanvasTransform(self: *const Self, arg_viewport: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_viewport_set_global_canvas_transform == null) {
            mbind_viewport_set_global_canvas_transform = try api.createMethod("VisualServer", "viewport_set_global_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_global_canvas_transform, base, cargs, result);
    }

    pub fn viewportSetHdr(self: *const Self, arg_viewport: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_viewport_set_hdr == null) {
            mbind_viewport_set_hdr = try api.createMethod("VisualServer", "viewport_set_hdr");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_hdr, base, cargs, result);
    }

    pub fn viewportSetHideCanvas(self: *const Self, arg_viewport: *const godot.RID, arg_hidden: bool) !void {
        if (mbind_viewport_set_hide_canvas == null) {
            mbind_viewport_set_hide_canvas = try api.createMethod("VisualServer", "viewport_set_hide_canvas");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_hidden),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_hide_canvas, base, cargs, result);
    }

    pub fn viewportSetHideScenario(self: *const Self, arg_viewport: *const godot.RID, arg_hidden: bool) !void {
        if (mbind_viewport_set_hide_scenario == null) {
            mbind_viewport_set_hide_scenario = try api.createMethod("VisualServer", "viewport_set_hide_scenario");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_hidden),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_hide_scenario, base, cargs, result);
    }

    pub fn viewportSetMsaa(self: *const Self, arg_viewport: *const godot.RID, arg_msaa: i32) !void {
        if (mbind_viewport_set_msaa == null) {
            mbind_viewport_set_msaa = try api.createMethod("VisualServer", "viewport_set_msaa");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_msaa),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_msaa, base, cargs, result);
    }

    pub fn viewportSetParentViewport(self: *const Self, arg_viewport: *const godot.RID, arg_parent_viewport: *const godot.RID) !void {
        if (mbind_viewport_set_parent_viewport == null) {
            mbind_viewport_set_parent_viewport = try api.createMethod("VisualServer", "viewport_set_parent_viewport");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_parent_viewport),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_parent_viewport, base, cargs, result);
    }

    pub fn viewportSetRenderDirectToScreen(self: *const Self, arg_viewport: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_viewport_set_render_direct_to_screen == null) {
            mbind_viewport_set_render_direct_to_screen = try api.createMethod("VisualServer", "viewport_set_render_direct_to_screen");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_render_direct_to_screen, base, cargs, result);
    }

    pub fn viewportSetScenario(self: *const Self, arg_viewport: *const godot.RID, arg_scenario: *const godot.RID) !void {
        if (mbind_viewport_set_scenario == null) {
            mbind_viewport_set_scenario = try api.createMethod("VisualServer", "viewport_set_scenario");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, arg_scenario),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_scenario, base, cargs, result);
    }

    pub fn viewportSetShadowAtlasQuadrantSubdivision(self: *const Self, arg_viewport: *const godot.RID, arg_quadrant: i32, arg_subdivision: i32) !void {
        if (mbind_viewport_set_shadow_atlas_quadrant_subdivision == null) {
            mbind_viewport_set_shadow_atlas_quadrant_subdivision = try api.createMethod("VisualServer", "viewport_set_shadow_atlas_quadrant_subdivision");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_quadrant),
            @ptrCast(*const anyopaque, *arg_subdivision),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_shadow_atlas_quadrant_subdivision, base, cargs, result);
    }

    pub fn viewportSetShadowAtlasSize(self: *const Self, arg_viewport: *const godot.RID, arg_size: i32) !void {
        if (mbind_viewport_set_shadow_atlas_size == null) {
            mbind_viewport_set_shadow_atlas_size = try api.createMethod("VisualServer", "viewport_set_shadow_atlas_size");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_shadow_atlas_size, base, cargs, result);
    }

    pub fn viewportSetSharpenIntensity(self: *const Self, arg_viewport: *const godot.RID, arg_intensity: f32) !void {
        if (mbind_viewport_set_sharpen_intensity == null) {
            mbind_viewport_set_sharpen_intensity = try api.createMethod("VisualServer", "viewport_set_sharpen_intensity");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_intensity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_sharpen_intensity, base, cargs, result);
    }

    pub fn viewportSetSize(self: *const Self, arg_viewport: *const godot.RID, arg_width: i32, arg_height: i32) !void {
        if (mbind_viewport_set_size == null) {
            mbind_viewport_set_size = try api.createMethod("VisualServer", "viewport_set_size");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_size, base, cargs, result);
    }

    pub fn viewportSetTransparentBackground(self: *const Self, arg_viewport: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_viewport_set_transparent_background == null) {
            mbind_viewport_set_transparent_background = try api.createMethod("VisualServer", "viewport_set_transparent_background");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_transparent_background, base, cargs, result);
    }

    pub fn viewportSetUpdateMode(self: *const Self, arg_viewport: *const godot.RID, arg_update_mode: i32) !void {
        if (mbind_viewport_set_update_mode == null) {
            mbind_viewport_set_update_mode = try api.createMethod("VisualServer", "viewport_set_update_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_update_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_update_mode, base, cargs, result);
    }

    pub fn viewportSetUsage(self: *const Self, arg_viewport: *const godot.RID, arg_usage: i32) !void {
        if (mbind_viewport_set_usage == null) {
            mbind_viewport_set_usage = try api.createMethod("VisualServer", "viewport_set_usage");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_usage),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_usage, base, cargs, result);
    }

    pub fn viewportSetUseArvr(self: *const Self, arg_viewport: *const godot.RID, arg_use_arvr: bool) !void {
        if (mbind_viewport_set_use_arvr == null) {
            mbind_viewport_set_use_arvr = try api.createMethod("VisualServer", "viewport_set_use_arvr");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_use_arvr),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_use_arvr, base, cargs, result);
    }

    pub fn viewportSetUseDebanding(self: *const Self, arg_viewport: *const godot.RID, arg_debanding: bool) !void {
        if (mbind_viewport_set_use_debanding == null) {
            mbind_viewport_set_use_debanding = try api.createMethod("VisualServer", "viewport_set_use_debanding");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_debanding),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_use_debanding, base, cargs, result);
    }

    pub fn viewportSetUseFxaa(self: *const Self, arg_viewport: *const godot.RID, arg_fxaa: bool) !void {
        if (mbind_viewport_set_use_fxaa == null) {
            mbind_viewport_set_use_fxaa = try api.createMethod("VisualServer", "viewport_set_use_fxaa");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_fxaa),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_use_fxaa, base, cargs, result);
    }

    pub fn viewportSetVflip(self: *const Self, arg_viewport: *const godot.RID, arg_enabled: bool) !void {
        if (mbind_viewport_set_vflip == null) {
            mbind_viewport_set_vflip = try api.createMethod("VisualServer", "viewport_set_vflip");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_viewport),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_viewport_set_vflip, base, cargs, result);
    }
};