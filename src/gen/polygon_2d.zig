// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node2D = @import("node_2d.zig").Node2D;

// method bindings
var mbind_add_bone: ?*c_api.godot_method_bind = null;
var mbind_clear_bones: ?*c_api.godot_method_bind = null;
var mbind_erase_bone: ?*c_api.godot_method_bind = null;
var mbind_get_antialiased: ?*c_api.godot_method_bind = null;
var mbind_get_bone_count: ?*c_api.godot_method_bind = null;
var mbind_get_bone_path: ?*c_api.godot_method_bind = null;
var mbind_get_bone_weights: ?*c_api.godot_method_bind = null;
var mbind_get_color: ?*c_api.godot_method_bind = null;
var mbind_get_internal_vertex_count: ?*c_api.godot_method_bind = null;
var mbind_get_invert: ?*c_api.godot_method_bind = null;
var mbind_get_invert_border: ?*c_api.godot_method_bind = null;
var mbind_get_offset: ?*c_api.godot_method_bind = null;
var mbind_get_polygon: ?*c_api.godot_method_bind = null;
var mbind_get_polygons: ?*c_api.godot_method_bind = null;
var mbind_get_skeleton: ?*c_api.godot_method_bind = null;
var mbind_get_texture: ?*c_api.godot_method_bind = null;
var mbind_get_texture_offset: ?*c_api.godot_method_bind = null;
var mbind_get_texture_rotation: ?*c_api.godot_method_bind = null;
var mbind_get_texture_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_get_texture_scale: ?*c_api.godot_method_bind = null;
var mbind_get_uv: ?*c_api.godot_method_bind = null;
var mbind_get_vertex_colors: ?*c_api.godot_method_bind = null;
var mbind_set_antialiased: ?*c_api.godot_method_bind = null;
var mbind_set_bone_path: ?*c_api.godot_method_bind = null;
var mbind_set_bone_weights: ?*c_api.godot_method_bind = null;
var mbind_set_color: ?*c_api.godot_method_bind = null;
var mbind_set_internal_vertex_count: ?*c_api.godot_method_bind = null;
var mbind_set_invert: ?*c_api.godot_method_bind = null;
var mbind_set_invert_border: ?*c_api.godot_method_bind = null;
var mbind_set_offset: ?*c_api.godot_method_bind = null;
var mbind_set_polygon: ?*c_api.godot_method_bind = null;
var mbind_set_polygons: ?*c_api.godot_method_bind = null;
var mbind_set_skeleton: ?*c_api.godot_method_bind = null;
var mbind_set_texture: ?*c_api.godot_method_bind = null;
var mbind_set_texture_offset: ?*c_api.godot_method_bind = null;
var mbind_set_texture_rotation: ?*c_api.godot_method_bind = null;
var mbind_set_texture_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_set_texture_scale: ?*c_api.godot_method_bind = null;
var mbind_set_uv: ?*c_api.godot_method_bind = null;
var mbind_set_vertex_colors: ?*c_api.godot_method_bind = null;
var mbind_polygon_2d_constructor: ?fn () ?*c_api.godot_object = null;

pub const Polygon2D = struct {
    const Self = @This();
    const BaseClass = Node2D;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_polygon_2d_constructor == null) {
            mbind_polygon_2d_constructor = try api.createConstructor("Polygon2D");
        }
        return api.createObject(Self, mbind_polygon_2d_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addBone(self: *const Self, arg_path: *const godot.NodePath, arg_weights: *const godot.PoolRealArray) !void {
        if (mbind_add_bone == null) {
            mbind_add_bone = try api.createMethod("Polygon2D", "add_bone");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, arg_weights),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_bone, base, cargs, result);
    }

    pub fn clearBones(self: *const Self) !void {
        if (mbind_clear_bones == null) {
            mbind_clear_bones = try api.createMethod("Polygon2D", "clear_bones");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_bones, base, cargs, result);
    }

    pub fn eraseBone(self: *const Self, arg_index: i32) !void {
        if (mbind_erase_bone == null) {
            mbind_erase_bone = try api.createMethod("Polygon2D", "erase_bone");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_erase_bone, base, cargs, result);
    }

    pub fn getAntialiased(self: *const Self) !bool {
        if (mbind_get_antialiased == null) {
            mbind_get_antialiased = try api.createMethod("Polygon2D", "get_antialiased");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_antialiased, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getBoneCount(self: *const Self) !i32 {
        if (mbind_get_bone_count == null) {
            mbind_get_bone_count = try api.createMethod("Polygon2D", "get_bone_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bone_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBonePath(self: *const Self, arg_index: i32) !godot.NodePath {
        if (mbind_get_bone_path == null) {
            mbind_get_bone_path = try api.createMethod("Polygon2D", "get_bone_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bone_path, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getBoneWeights(self: *const Self, arg_index: i32) !godot.PoolRealArray {
        if (mbind_get_bone_weights == null) {
            mbind_get_bone_weights = try api.createMethod("Polygon2D", "get_bone_weights");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bone_weights, base, cargs, result);
        return @ptrCast(*godot.PoolRealArray, @alignCast(@alignOf(&godot.PoolRealArray), result)).*;
    }

    pub fn getColor(self: *const Self) !godot.Color {
        if (mbind_get_color == null) {
            mbind_get_color = try api.createMethod("Polygon2D", "get_color");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getInternalVertexCount(self: *const Self) !i32 {
        if (mbind_get_internal_vertex_count == null) {
            mbind_get_internal_vertex_count = try api.createMethod("Polygon2D", "get_internal_vertex_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_internal_vertex_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getInvert(self: *const Self) !bool {
        if (mbind_get_invert == null) {
            mbind_get_invert = try api.createMethod("Polygon2D", "get_invert");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_invert, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getInvertBorder(self: *const Self) !f32 {
        if (mbind_get_invert_border == null) {
            mbind_get_invert_border = try api.createMethod("Polygon2D", "get_invert_border");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_invert_border, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getOffset(self: *const Self) !godot.Vector2 {
        if (mbind_get_offset == null) {
            mbind_get_offset = try api.createMethod("Polygon2D", "get_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getPolygon(self: *const Self) !godot.PoolVector2Array {
        if (mbind_get_polygon == null) {
            mbind_get_polygon = try api.createMethod("Polygon2D", "get_polygon");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_polygon, base, cargs, result);
        return @ptrCast(*godot.PoolVector2Array, @alignCast(@alignOf(&godot.PoolVector2Array), result)).*;
    }

    pub fn getPolygons(self: *const Self) !godot.Array {
        if (mbind_get_polygons == null) {
            mbind_get_polygons = try api.createMethod("Polygon2D", "get_polygons");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_polygons, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getSkeleton(self: *const Self) !godot.NodePath {
        if (mbind_get_skeleton == null) {
            mbind_get_skeleton = try api.createMethod("Polygon2D", "get_skeleton");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_skeleton, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getTexture(self: *const Self) !godot.Texture {
        if (mbind_get_texture == null) {
            mbind_get_texture = try api.createMethod("Polygon2D", "get_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getTextureOffset(self: *const Self) !godot.Vector2 {
        if (mbind_get_texture_offset == null) {
            mbind_get_texture_offset = try api.createMethod("Polygon2D", "get_texture_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getTextureRotation(self: *const Self) !f32 {
        if (mbind_get_texture_rotation == null) {
            mbind_get_texture_rotation = try api.createMethod("Polygon2D", "get_texture_rotation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture_rotation, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getTextureRotationDegrees(self: *const Self) !f32 {
        if (mbind_get_texture_rotation_degrees == null) {
            mbind_get_texture_rotation_degrees = try api.createMethod("Polygon2D", "get_texture_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture_rotation_degrees, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getTextureScale(self: *const Self) !godot.Vector2 {
        if (mbind_get_texture_scale == null) {
            mbind_get_texture_scale = try api.createMethod("Polygon2D", "get_texture_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture_scale, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getUv(self: *const Self) !godot.PoolVector2Array {
        if (mbind_get_uv == null) {
            mbind_get_uv = try api.createMethod("Polygon2D", "get_uv");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv, base, cargs, result);
        return @ptrCast(*godot.PoolVector2Array, @alignCast(@alignOf(&godot.PoolVector2Array), result)).*;
    }

    pub fn getVertexColors(self: *const Self) !godot.PoolColorArray {
        if (mbind_get_vertex_colors == null) {
            mbind_get_vertex_colors = try api.createMethod("Polygon2D", "get_vertex_colors");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_vertex_colors, base, cargs, result);
        return @ptrCast(*godot.PoolColorArray, @alignCast(@alignOf(&godot.PoolColorArray), result)).*;
    }

    pub fn setAntialiased(self: *const Self, arg_antialiased: bool) !void {
        if (mbind_set_antialiased == null) {
            mbind_set_antialiased = try api.createMethod("Polygon2D", "set_antialiased");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_antialiased),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_antialiased, base, cargs, result);
    }

    pub fn setBonePath(self: *const Self, arg_index: i32, arg_path: *const godot.NodePath) !void {
        if (mbind_set_bone_path == null) {
            mbind_set_bone_path = try api.createMethod("Polygon2D", "set_bone_path");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bone_path, base, cargs, result);
    }

    pub fn setBoneWeights(self: *const Self, arg_index: i32, arg_weights: *const godot.PoolRealArray) !void {
        if (mbind_set_bone_weights == null) {
            mbind_set_bone_weights = try api.createMethod("Polygon2D", "set_bone_weights");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
            @ptrCast(*const anyopaque, arg_weights),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bone_weights, base, cargs, result);
    }

    pub fn setColor(self: *const Self, arg_color: *const godot.Color) !void {
        if (mbind_set_color == null) {
            mbind_set_color = try api.createMethod("Polygon2D", "set_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_color, base, cargs, result);
    }

    pub fn setInternalVertexCount(self: *const Self, arg_internal_vertex_count: i32) !void {
        if (mbind_set_internal_vertex_count == null) {
            mbind_set_internal_vertex_count = try api.createMethod("Polygon2D", "set_internal_vertex_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_internal_vertex_count),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_internal_vertex_count, base, cargs, result);
    }

    pub fn setInvert(self: *const Self, arg_invert: bool) !void {
        if (mbind_set_invert == null) {
            mbind_set_invert = try api.createMethod("Polygon2D", "set_invert");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_invert),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_invert, base, cargs, result);
    }

    pub fn setInvertBorder(self: *const Self, arg_invert_border: f32) !void {
        if (mbind_set_invert_border == null) {
            mbind_set_invert_border = try api.createMethod("Polygon2D", "set_invert_border");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_invert_border),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_invert_border, base, cargs, result);
    }

    pub fn setOffset(self: *const Self, arg_offset: *const godot.Vector2) !void {
        if (mbind_set_offset == null) {
            mbind_set_offset = try api.createMethod("Polygon2D", "set_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_offset, base, cargs, result);
    }

    pub fn setPolygon(self: *const Self, arg_polygon: *const godot.PoolVector2Array) !void {
        if (mbind_set_polygon == null) {
            mbind_set_polygon = try api.createMethod("Polygon2D", "set_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_polygon, base, cargs, result);
    }

    pub fn setPolygons(self: *const Self, arg_polygons: *const godot.Array) !void {
        if (mbind_set_polygons == null) {
            mbind_set_polygons = try api.createMethod("Polygon2D", "set_polygons");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygons),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_polygons, base, cargs, result);
    }

    pub fn setSkeleton(self: *const Self, arg_skeleton: *const godot.NodePath) !void {
        if (mbind_set_skeleton == null) {
            mbind_set_skeleton = try api.createMethod("Polygon2D", "set_skeleton");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_skeleton),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_skeleton, base, cargs, result);
    }

    pub fn setTexture(self: *const Self, arg_texture: *const godot.Texture) !void {
        if (mbind_set_texture == null) {
            mbind_set_texture = try api.createMethod("Polygon2D", "set_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture, base, cargs, result);
    }

    pub fn setTextureOffset(self: *const Self, arg_texture_offset: *const godot.Vector2) !void {
        if (mbind_set_texture_offset == null) {
            mbind_set_texture_offset = try api.createMethod("Polygon2D", "set_texture_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture_offset, base, cargs, result);
    }

    pub fn setTextureRotation(self: *const Self, arg_texture_rotation: f32) !void {
        if (mbind_set_texture_rotation == null) {
            mbind_set_texture_rotation = try api.createMethod("Polygon2D", "set_texture_rotation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_texture_rotation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture_rotation, base, cargs, result);
    }

    pub fn setTextureRotationDegrees(self: *const Self, arg_texture_rotation: f32) !void {
        if (mbind_set_texture_rotation_degrees == null) {
            mbind_set_texture_rotation_degrees = try api.createMethod("Polygon2D", "set_texture_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_texture_rotation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture_rotation_degrees, base, cargs, result);
    }

    pub fn setTextureScale(self: *const Self, arg_texture_scale: *const godot.Vector2) !void {
        if (mbind_set_texture_scale == null) {
            mbind_set_texture_scale = try api.createMethod("Polygon2D", "set_texture_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture_scale, base, cargs, result);
    }

    pub fn setUv(self: *const Self, arg_uv: *const godot.PoolVector2Array) !void {
        if (mbind_set_uv == null) {
            mbind_set_uv = try api.createMethod("Polygon2D", "set_uv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv, base, cargs, result);
    }

    pub fn setVertexColors(self: *const Self, arg_vertex_colors: *const godot.PoolColorArray) !void {
        if (mbind_set_vertex_colors == null) {
            mbind_set_vertex_colors = try api.createMethod("Polygon2D", "set_vertex_colors");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_vertex_colors),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_vertex_colors, base, cargs, result);
    }
};