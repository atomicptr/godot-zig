// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node = @import("node.zig").Node;

// method bindings
var mbind_add_autoload_singleton: ?*c_api.godot_method_bind = null;
var mbind_add_control_to_bottom_panel: ?*c_api.godot_method_bind = null;
var mbind_add_control_to_container: ?*c_api.godot_method_bind = null;
var mbind_add_control_to_dock: ?*c_api.godot_method_bind = null;
var mbind_add_custom_type: ?*c_api.godot_method_bind = null;
var mbind_add_export_plugin: ?*c_api.godot_method_bind = null;
var mbind_add_import_plugin: ?*c_api.godot_method_bind = null;
var mbind_add_inspector_plugin: ?*c_api.godot_method_bind = null;
var mbind_add_scene_import_plugin: ?*c_api.godot_method_bind = null;
var mbind_add_spatial_gizmo_plugin: ?*c_api.godot_method_bind = null;
var mbind_add_tool_menu_item: ?*c_api.godot_method_bind = null;
var mbind_add_tool_submenu_item: ?*c_api.godot_method_bind = null;
var mbind_get_editor_interface: ?*c_api.godot_method_bind = null;
var mbind_get_script_create_dialog: ?*c_api.godot_method_bind = null;
var mbind_get_undo_redo: ?*c_api.godot_method_bind = null;
var mbind_hide_bottom_panel: ?*c_api.godot_method_bind = null;
var mbind_make_bottom_panel_item_visible: ?*c_api.godot_method_bind = null;
var mbind_queue_save_layout: ?*c_api.godot_method_bind = null;
var mbind_remove_autoload_singleton: ?*c_api.godot_method_bind = null;
var mbind_remove_control_from_bottom_panel: ?*c_api.godot_method_bind = null;
var mbind_remove_control_from_container: ?*c_api.godot_method_bind = null;
var mbind_remove_control_from_docks: ?*c_api.godot_method_bind = null;
var mbind_remove_custom_type: ?*c_api.godot_method_bind = null;
var mbind_remove_export_plugin: ?*c_api.godot_method_bind = null;
var mbind_remove_import_plugin: ?*c_api.godot_method_bind = null;
var mbind_remove_inspector_plugin: ?*c_api.godot_method_bind = null;
var mbind_remove_scene_import_plugin: ?*c_api.godot_method_bind = null;
var mbind_remove_spatial_gizmo_plugin: ?*c_api.godot_method_bind = null;
var mbind_remove_tool_menu_item: ?*c_api.godot_method_bind = null;
var mbind_set_force_draw_over_forwarding_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_input_event_forwarding_always_enabled: ?*c_api.godot_method_bind = null;
var mbind_update_overlays: ?*c_api.godot_method_bind = null;
var mbind_editor_plugin_constructor: ?fn () ?*c_api.godot_object = null;

pub const EditorPlugin = struct {
    const Self = @This();
    const BaseClass = Node;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_editor_plugin_constructor == null) {
            mbind_editor_plugin_constructor = try api.createConstructor("EditorPlugin");
        }
        return api.createObject(Self, mbind_editor_plugin_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addAutoloadSingleton(self: *const Self, arg_name: *const godot.String, arg_path: *const godot.String) !void {
        if (mbind_add_autoload_singleton == null) {
            mbind_add_autoload_singleton = try api.createMethod("EditorPlugin", "add_autoload_singleton");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_autoload_singleton, base, cargs, result);
    }

    pub fn addControlToBottomPanel(self: *const Self, arg_control: *const godot.Control, arg_title: *const godot.String) !godot.ToolButton {
        if (mbind_add_control_to_bottom_panel == null) {
            mbind_add_control_to_bottom_panel = try api.createMethod("EditorPlugin", "add_control_to_bottom_panel");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_control),
            @ptrCast(*const anyopaque, arg_title),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_control_to_bottom_panel, base, cargs, result);
        return @ptrCast(*godot.ToolButton, @alignCast(@alignOf(&godot.ToolButton), result)).*;
    }

    pub fn addControlToContainer(self: *const Self, arg_container: i32, arg_control: *const godot.Control) !void {
        if (mbind_add_control_to_container == null) {
            mbind_add_control_to_container = try api.createMethod("EditorPlugin", "add_control_to_container");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_container),
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_control_to_container, base, cargs, result);
    }

    pub fn addControlToDock(self: *const Self, arg_slot: i32, arg_control: *const godot.Control) !void {
        if (mbind_add_control_to_dock == null) {
            mbind_add_control_to_dock = try api.createMethod("EditorPlugin", "add_control_to_dock");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_slot),
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_control_to_dock, base, cargs, result);
    }

    pub fn addCustomType(self: *const Self, arg_type: *const godot.String, arg_base: *const godot.String, arg_script: *const godot.Script, arg_icon: *const godot.Texture) !void {
        if (mbind_add_custom_type == null) {
            mbind_add_custom_type = try api.createMethod("EditorPlugin", "add_custom_type");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_type),
            @ptrCast(*const anyopaque, arg_base),
            @ptrCast(*const anyopaque, arg_script),
            @ptrCast(*const anyopaque, arg_icon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_custom_type, base, cargs, result);
    }

    pub fn addExportPlugin(self: *const Self, arg_plugin: *const godot.EditorExportPlugin) !void {
        if (mbind_add_export_plugin == null) {
            mbind_add_export_plugin = try api.createMethod("EditorPlugin", "add_export_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_export_plugin, base, cargs, result);
    }

    pub fn addImportPlugin(self: *const Self, arg_importer: *const godot.EditorImportPlugin) !void {
        if (mbind_add_import_plugin == null) {
            mbind_add_import_plugin = try api.createMethod("EditorPlugin", "add_import_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_importer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_import_plugin, base, cargs, result);
    }

    pub fn addInspectorPlugin(self: *const Self, arg_plugin: *const godot.EditorInspectorPlugin) !void {
        if (mbind_add_inspector_plugin == null) {
            mbind_add_inspector_plugin = try api.createMethod("EditorPlugin", "add_inspector_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_inspector_plugin, base, cargs, result);
    }

    pub fn addSceneImportPlugin(self: *const Self, arg_scene_importer: *const godot.EditorSceneImporter) !void {
        if (mbind_add_scene_import_plugin == null) {
            mbind_add_scene_import_plugin = try api.createMethod("EditorPlugin", "add_scene_import_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene_importer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_scene_import_plugin, base, cargs, result);
    }

    pub fn addSpatialGizmoPlugin(self: *const Self, arg_plugin: *const godot.EditorSpatialGizmoPlugin) !void {
        if (mbind_add_spatial_gizmo_plugin == null) {
            mbind_add_spatial_gizmo_plugin = try api.createMethod("EditorPlugin", "add_spatial_gizmo_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_spatial_gizmo_plugin, base, cargs, result);
    }

    pub fn addToolMenuItem(self: *const Self, arg_name: *const godot.String, arg_handler: *const godot.Object, arg_callback: *const godot.String, arg_ud: *const godot.Variant) !void {
        if (mbind_add_tool_menu_item == null) {
            mbind_add_tool_menu_item = try api.createMethod("EditorPlugin", "add_tool_menu_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_handler),
            @ptrCast(*const anyopaque, arg_callback),
            @ptrCast(*const anyopaque, arg_ud),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_tool_menu_item, base, cargs, result);
    }

    pub fn addToolSubmenuItem(self: *const Self, arg_name: *const godot.String, arg_submenu: *const godot.Object) !void {
        if (mbind_add_tool_submenu_item == null) {
            mbind_add_tool_submenu_item = try api.createMethod("EditorPlugin", "add_tool_submenu_item");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_submenu),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_tool_submenu_item, base, cargs, result);
    }

    pub fn getEditorInterface(self: *const Self) !godot.EditorInterface {
        if (mbind_get_editor_interface == null) {
            mbind_get_editor_interface = try api.createMethod("EditorPlugin", "get_editor_interface");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_editor_interface, base, cargs, result);
        return @ptrCast(*godot.EditorInterface, @alignCast(@alignOf(&godot.EditorInterface), result)).*;
    }

    pub fn getScriptCreateDialog(self: *const Self) !godot.ScriptCreateDialog {
        if (mbind_get_script_create_dialog == null) {
            mbind_get_script_create_dialog = try api.createMethod("EditorPlugin", "get_script_create_dialog");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_script_create_dialog, base, cargs, result);
        return @ptrCast(*godot.ScriptCreateDialog, @alignCast(@alignOf(&godot.ScriptCreateDialog), result)).*;
    }

    pub fn getUndoRedo(self: *const Self) !godot.UndoRedo {
        if (mbind_get_undo_redo == null) {
            mbind_get_undo_redo = try api.createMethod("EditorPlugin", "get_undo_redo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_undo_redo, base, cargs, result);
        return @ptrCast(*godot.UndoRedo, @alignCast(@alignOf(&godot.UndoRedo), result)).*;
    }

    pub fn hideBottomPanel(self: *const Self) !void {
        if (mbind_hide_bottom_panel == null) {
            mbind_hide_bottom_panel = try api.createMethod("EditorPlugin", "hide_bottom_panel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hide_bottom_panel, base, cargs, result);
    }

    pub fn makeBottomPanelItemVisible(self: *const Self, arg_item: *const godot.Control) !void {
        if (mbind_make_bottom_panel_item_visible == null) {
            mbind_make_bottom_panel_item_visible = try api.createMethod("EditorPlugin", "make_bottom_panel_item_visible");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_item),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_make_bottom_panel_item_visible, base, cargs, result);
    }

    pub fn queueSaveLayout(self: *const Self) !void {
        if (mbind_queue_save_layout == null) {
            mbind_queue_save_layout = try api.createMethod("EditorPlugin", "queue_save_layout");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_queue_save_layout, base, cargs, result);
    }

    pub fn removeAutoloadSingleton(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_remove_autoload_singleton == null) {
            mbind_remove_autoload_singleton = try api.createMethod("EditorPlugin", "remove_autoload_singleton");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_autoload_singleton, base, cargs, result);
    }

    pub fn removeControlFromBottomPanel(self: *const Self, arg_control: *const godot.Control) !void {
        if (mbind_remove_control_from_bottom_panel == null) {
            mbind_remove_control_from_bottom_panel = try api.createMethod("EditorPlugin", "remove_control_from_bottom_panel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_control_from_bottom_panel, base, cargs, result);
    }

    pub fn removeControlFromContainer(self: *const Self, arg_container: i32, arg_control: *const godot.Control) !void {
        if (mbind_remove_control_from_container == null) {
            mbind_remove_control_from_container = try api.createMethod("EditorPlugin", "remove_control_from_container");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_container),
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_control_from_container, base, cargs, result);
    }

    pub fn removeControlFromDocks(self: *const Self, arg_control: *const godot.Control) !void {
        if (mbind_remove_control_from_docks == null) {
            mbind_remove_control_from_docks = try api.createMethod("EditorPlugin", "remove_control_from_docks");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_control_from_docks, base, cargs, result);
    }

    pub fn removeCustomType(self: *const Self, arg_type: *const godot.String) !void {
        if (mbind_remove_custom_type == null) {
            mbind_remove_custom_type = try api.createMethod("EditorPlugin", "remove_custom_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_custom_type, base, cargs, result);
    }

    pub fn removeExportPlugin(self: *const Self, arg_plugin: *const godot.EditorExportPlugin) !void {
        if (mbind_remove_export_plugin == null) {
            mbind_remove_export_plugin = try api.createMethod("EditorPlugin", "remove_export_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_export_plugin, base, cargs, result);
    }

    pub fn removeImportPlugin(self: *const Self, arg_importer: *const godot.EditorImportPlugin) !void {
        if (mbind_remove_import_plugin == null) {
            mbind_remove_import_plugin = try api.createMethod("EditorPlugin", "remove_import_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_importer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_import_plugin, base, cargs, result);
    }

    pub fn removeInspectorPlugin(self: *const Self, arg_plugin: *const godot.EditorInspectorPlugin) !void {
        if (mbind_remove_inspector_plugin == null) {
            mbind_remove_inspector_plugin = try api.createMethod("EditorPlugin", "remove_inspector_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_inspector_plugin, base, cargs, result);
    }

    pub fn removeSceneImportPlugin(self: *const Self, arg_scene_importer: *const godot.EditorSceneImporter) !void {
        if (mbind_remove_scene_import_plugin == null) {
            mbind_remove_scene_import_plugin = try api.createMethod("EditorPlugin", "remove_scene_import_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene_importer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_scene_import_plugin, base, cargs, result);
    }

    pub fn removeSpatialGizmoPlugin(self: *const Self, arg_plugin: *const godot.EditorSpatialGizmoPlugin) !void {
        if (mbind_remove_spatial_gizmo_plugin == null) {
            mbind_remove_spatial_gizmo_plugin = try api.createMethod("EditorPlugin", "remove_spatial_gizmo_plugin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_plugin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_spatial_gizmo_plugin, base, cargs, result);
    }

    pub fn removeToolMenuItem(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_remove_tool_menu_item == null) {
            mbind_remove_tool_menu_item = try api.createMethod("EditorPlugin", "remove_tool_menu_item");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_tool_menu_item, base, cargs, result);
    }

    pub fn setForceDrawOverForwardingEnabled(self: *const Self) !void {
        if (mbind_set_force_draw_over_forwarding_enabled == null) {
            mbind_set_force_draw_over_forwarding_enabled = try api.createMethod("EditorPlugin", "set_force_draw_over_forwarding_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_force_draw_over_forwarding_enabled, base, cargs, result);
    }

    pub fn setInputEventForwardingAlwaysEnabled(self: *const Self) !void {
        if (mbind_set_input_event_forwarding_always_enabled == null) {
            mbind_set_input_event_forwarding_always_enabled = try api.createMethod("EditorPlugin", "set_input_event_forwarding_always_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_input_event_forwarding_always_enabled, base, cargs, result);
    }

    pub fn updateOverlays(self: *const Self) !i32 {
        if (mbind_update_overlays == null) {
            mbind_update_overlays = try api.createMethod("EditorPlugin", "update_overlays");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_overlays, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }
};