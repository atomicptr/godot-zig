// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Resource = @import("resource.zig").Resource;

// method bindings
var mbind_add_polygon: ?*c_api.godot_method_bind = null;
var mbind_clear_polygons: ?*c_api.godot_method_bind = null;
var mbind_create_from_mesh: ?*c_api.godot_method_bind = null;
var mbind_get_agent_height: ?*c_api.godot_method_bind = null;
var mbind_get_agent_max_climb: ?*c_api.godot_method_bind = null;
var mbind_get_agent_max_slope: ?*c_api.godot_method_bind = null;
var mbind_get_agent_radius: ?*c_api.godot_method_bind = null;
var mbind_get_cell_height: ?*c_api.godot_method_bind = null;
var mbind_get_cell_size: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_get_detail_sample_distance: ?*c_api.godot_method_bind = null;
var mbind_get_detail_sample_max_error: ?*c_api.godot_method_bind = null;
var mbind_get_edge_max_error: ?*c_api.godot_method_bind = null;
var mbind_get_edge_max_length: ?*c_api.godot_method_bind = null;
var mbind_get_filter_ledge_spans: ?*c_api.godot_method_bind = null;
var mbind_get_filter_low_hanging_obstacles: ?*c_api.godot_method_bind = null;
var mbind_get_filter_walkable_low_height_spans: ?*c_api.godot_method_bind = null;
var mbind_get_parsed_geometry_type: ?*c_api.godot_method_bind = null;
var mbind_get_polygon: ?*c_api.godot_method_bind = null;
var mbind_get_polygon_count: ?*c_api.godot_method_bind = null;
var mbind_get_region_merge_size: ?*c_api.godot_method_bind = null;
var mbind_get_region_min_size: ?*c_api.godot_method_bind = null;
var mbind_get_sample_partition_type: ?*c_api.godot_method_bind = null;
var mbind_get_source_geometry_mode: ?*c_api.godot_method_bind = null;
var mbind_get_source_group_name: ?*c_api.godot_method_bind = null;
var mbind_get_vertices: ?*c_api.godot_method_bind = null;
var mbind_get_verts_per_poly: ?*c_api.godot_method_bind = null;
var mbind_set_agent_height: ?*c_api.godot_method_bind = null;
var mbind_set_agent_max_climb: ?*c_api.godot_method_bind = null;
var mbind_set_agent_max_slope: ?*c_api.godot_method_bind = null;
var mbind_set_agent_radius: ?*c_api.godot_method_bind = null;
var mbind_set_cell_height: ?*c_api.godot_method_bind = null;
var mbind_set_cell_size: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_set_detail_sample_distance: ?*c_api.godot_method_bind = null;
var mbind_set_detail_sample_max_error: ?*c_api.godot_method_bind = null;
var mbind_set_edge_max_error: ?*c_api.godot_method_bind = null;
var mbind_set_edge_max_length: ?*c_api.godot_method_bind = null;
var mbind_set_filter_ledge_spans: ?*c_api.godot_method_bind = null;
var mbind_set_filter_low_hanging_obstacles: ?*c_api.godot_method_bind = null;
var mbind_set_filter_walkable_low_height_spans: ?*c_api.godot_method_bind = null;
var mbind_set_parsed_geometry_type: ?*c_api.godot_method_bind = null;
var mbind_set_region_merge_size: ?*c_api.godot_method_bind = null;
var mbind_set_region_min_size: ?*c_api.godot_method_bind = null;
var mbind_set_sample_partition_type: ?*c_api.godot_method_bind = null;
var mbind_set_source_geometry_mode: ?*c_api.godot_method_bind = null;
var mbind_set_source_group_name: ?*c_api.godot_method_bind = null;
var mbind_set_vertices: ?*c_api.godot_method_bind = null;
var mbind_set_verts_per_poly: ?*c_api.godot_method_bind = null;
var mbind_navigation_mesh_constructor: ?fn () ?*c_api.godot_object = null;

pub const NavigationMesh = struct {
    const Self = @This();
    const BaseClass = Resource;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_navigation_mesh_constructor == null) {
            mbind_navigation_mesh_constructor = try api.createConstructor("NavigationMesh");
        }
        return api.createObject(Self, mbind_navigation_mesh_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addPolygon(self: *const Self, arg_polygon: *const godot.PoolIntArray) !void {
        if (mbind_add_polygon == null) {
            mbind_add_polygon = try api.createMethod("NavigationMesh", "add_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_polygon, base, cargs, result);
    }

    pub fn clearPolygons(self: *const Self) !void {
        if (mbind_clear_polygons == null) {
            mbind_clear_polygons = try api.createMethod("NavigationMesh", "clear_polygons");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_polygons, base, cargs, result);
    }

    pub fn createFromMesh(self: *const Self, arg_mesh: *const godot.Mesh) !void {
        if (mbind_create_from_mesh == null) {
            mbind_create_from_mesh = try api.createMethod("NavigationMesh", "create_from_mesh");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mesh),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_create_from_mesh, base, cargs, result);
    }

    pub fn getAgentHeight(self: *const Self) !f32 {
        if (mbind_get_agent_height == null) {
            mbind_get_agent_height = try api.createMethod("NavigationMesh", "get_agent_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_agent_height, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAgentMaxClimb(self: *const Self) !f32 {
        if (mbind_get_agent_max_climb == null) {
            mbind_get_agent_max_climb = try api.createMethod("NavigationMesh", "get_agent_max_climb");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_agent_max_climb, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAgentMaxSlope(self: *const Self) !f32 {
        if (mbind_get_agent_max_slope == null) {
            mbind_get_agent_max_slope = try api.createMethod("NavigationMesh", "get_agent_max_slope");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_agent_max_slope, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAgentRadius(self: *const Self) !f32 {
        if (mbind_get_agent_radius == null) {
            mbind_get_agent_radius = try api.createMethod("NavigationMesh", "get_agent_radius");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_agent_radius, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCellHeight(self: *const Self) !f32 {
        if (mbind_get_cell_height == null) {
            mbind_get_cell_height = try api.createMethod("NavigationMesh", "get_cell_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_height, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCellSize(self: *const Self) !f32 {
        if (mbind_get_cell_size == null) {
            mbind_get_cell_size = try api.createMethod("NavigationMesh", "get_cell_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollisionMask(self: *const Self) !i32 {
        if (mbind_get_collision_mask == null) {
            mbind_get_collision_mask = try api.createMethod("NavigationMesh", "get_collision_mask");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCollisionMaskBit(self: *const Self, arg_bit: i32) !bool {
        if (mbind_get_collision_mask_bit == null) {
            mbind_get_collision_mask_bit = try api.createMethod("NavigationMesh", "get_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask_bit, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getDetailSampleDistance(self: *const Self) !f32 {
        if (mbind_get_detail_sample_distance == null) {
            mbind_get_detail_sample_distance = try api.createMethod("NavigationMesh", "get_detail_sample_distance");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_detail_sample_distance, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getDetailSampleMaxError(self: *const Self) !f32 {
        if (mbind_get_detail_sample_max_error == null) {
            mbind_get_detail_sample_max_error = try api.createMethod("NavigationMesh", "get_detail_sample_max_error");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_detail_sample_max_error, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEdgeMaxError(self: *const Self) !f32 {
        if (mbind_get_edge_max_error == null) {
            mbind_get_edge_max_error = try api.createMethod("NavigationMesh", "get_edge_max_error");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_edge_max_error, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEdgeMaxLength(self: *const Self) !f32 {
        if (mbind_get_edge_max_length == null) {
            mbind_get_edge_max_length = try api.createMethod("NavigationMesh", "get_edge_max_length");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_edge_max_length, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getFilterLedgeSpans(self: *const Self) !bool {
        if (mbind_get_filter_ledge_spans == null) {
            mbind_get_filter_ledge_spans = try api.createMethod("NavigationMesh", "get_filter_ledge_spans");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_filter_ledge_spans, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getFilterLowHangingObstacles(self: *const Self) !bool {
        if (mbind_get_filter_low_hanging_obstacles == null) {
            mbind_get_filter_low_hanging_obstacles = try api.createMethod("NavigationMesh", "get_filter_low_hanging_obstacles");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_filter_low_hanging_obstacles, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getFilterWalkableLowHeightSpans(self: *const Self) !bool {
        if (mbind_get_filter_walkable_low_height_spans == null) {
            mbind_get_filter_walkable_low_height_spans = try api.createMethod("NavigationMesh", "get_filter_walkable_low_height_spans");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_filter_walkable_low_height_spans, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getParsedGeometryType(self: *const Self) !i32 {
        if (mbind_get_parsed_geometry_type == null) {
            mbind_get_parsed_geometry_type = try api.createMethod("NavigationMesh", "get_parsed_geometry_type");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_parsed_geometry_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPolygon(self: *const Self, arg_idx: i32) !godot.PoolIntArray {
        if (mbind_get_polygon == null) {
            mbind_get_polygon = try api.createMethod("NavigationMesh", "get_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_polygon, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn getPolygonCount(self: *const Self) !i32 {
        if (mbind_get_polygon_count == null) {
            mbind_get_polygon_count = try api.createMethod("NavigationMesh", "get_polygon_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_polygon_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getRegionMergeSize(self: *const Self) !f32 {
        if (mbind_get_region_merge_size == null) {
            mbind_get_region_merge_size = try api.createMethod("NavigationMesh", "get_region_merge_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_region_merge_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRegionMinSize(self: *const Self) !f32 {
        if (mbind_get_region_min_size == null) {
            mbind_get_region_min_size = try api.createMethod("NavigationMesh", "get_region_min_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_region_min_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSamplePartitionType(self: *const Self) !i32 {
        if (mbind_get_sample_partition_type == null) {
            mbind_get_sample_partition_type = try api.createMethod("NavigationMesh", "get_sample_partition_type");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_sample_partition_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSourceGeometryMode(self: *const Self) !i32 {
        if (mbind_get_source_geometry_mode == null) {
            mbind_get_source_geometry_mode = try api.createMethod("NavigationMesh", "get_source_geometry_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_source_geometry_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSourceGroupName(self: *const Self) !godot.String {
        if (mbind_get_source_group_name == null) {
            mbind_get_source_group_name = try api.createMethod("NavigationMesh", "get_source_group_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_source_group_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVertices(self: *const Self) !godot.PoolVector3Array {
        if (mbind_get_vertices == null) {
            mbind_get_vertices = try api.createMethod("NavigationMesh", "get_vertices");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_vertices, base, cargs, result);
        return @ptrCast(*godot.PoolVector3Array, @alignCast(@alignOf(&godot.PoolVector3Array), result)).*;
    }

    pub fn getVertsPerPoly(self: *const Self) !f32 {
        if (mbind_get_verts_per_poly == null) {
            mbind_get_verts_per_poly = try api.createMethod("NavigationMesh", "get_verts_per_poly");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_verts_per_poly, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn setAgentHeight(self: *const Self, arg_agent_height: f32) !void {
        if (mbind_set_agent_height == null) {
            mbind_set_agent_height = try api.createMethod("NavigationMesh", "set_agent_height");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_agent_height),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_agent_height, base, cargs, result);
    }

    pub fn setAgentMaxClimb(self: *const Self, arg_agent_max_climb: f32) !void {
        if (mbind_set_agent_max_climb == null) {
            mbind_set_agent_max_climb = try api.createMethod("NavigationMesh", "set_agent_max_climb");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_agent_max_climb),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_agent_max_climb, base, cargs, result);
    }

    pub fn setAgentMaxSlope(self: *const Self, arg_agent_max_slope: f32) !void {
        if (mbind_set_agent_max_slope == null) {
            mbind_set_agent_max_slope = try api.createMethod("NavigationMesh", "set_agent_max_slope");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_agent_max_slope),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_agent_max_slope, base, cargs, result);
    }

    pub fn setAgentRadius(self: *const Self, arg_agent_radius: f32) !void {
        if (mbind_set_agent_radius == null) {
            mbind_set_agent_radius = try api.createMethod("NavigationMesh", "set_agent_radius");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_agent_radius),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_agent_radius, base, cargs, result);
    }

    pub fn setCellHeight(self: *const Self, arg_cell_height: f32) !void {
        if (mbind_set_cell_height == null) {
            mbind_set_cell_height = try api.createMethod("NavigationMesh", "set_cell_height");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_cell_height),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_height, base, cargs, result);
    }

    pub fn setCellSize(self: *const Self, arg_cell_size: f32) !void {
        if (mbind_set_cell_size == null) {
            mbind_set_cell_size = try api.createMethod("NavigationMesh", "set_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_cell_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_size, base, cargs, result);
    }

    pub fn setCollisionMask(self: *const Self, arg_mask: i32) !void {
        if (mbind_set_collision_mask == null) {
            mbind_set_collision_mask = try api.createMethod("NavigationMesh", "set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask, base, cargs, result);
    }

    pub fn setCollisionMaskBit(self: *const Self, arg_bit: i32, arg_value: bool) !void {
        if (mbind_set_collision_mask_bit == null) {
            mbind_set_collision_mask_bit = try api.createMethod("NavigationMesh", "set_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask_bit, base, cargs, result);
    }

    pub fn setDetailSampleDistance(self: *const Self, arg_detail_sample_dist: f32) !void {
        if (mbind_set_detail_sample_distance == null) {
            mbind_set_detail_sample_distance = try api.createMethod("NavigationMesh", "set_detail_sample_distance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_detail_sample_dist),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_detail_sample_distance, base, cargs, result);
    }

    pub fn setDetailSampleMaxError(self: *const Self, arg_detail_sample_max_error: f32) !void {
        if (mbind_set_detail_sample_max_error == null) {
            mbind_set_detail_sample_max_error = try api.createMethod("NavigationMesh", "set_detail_sample_max_error");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_detail_sample_max_error),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_detail_sample_max_error, base, cargs, result);
    }

    pub fn setEdgeMaxError(self: *const Self, arg_edge_max_error: f32) !void {
        if (mbind_set_edge_max_error == null) {
            mbind_set_edge_max_error = try api.createMethod("NavigationMesh", "set_edge_max_error");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_edge_max_error),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_edge_max_error, base, cargs, result);
    }

    pub fn setEdgeMaxLength(self: *const Self, arg_edge_max_length: f32) !void {
        if (mbind_set_edge_max_length == null) {
            mbind_set_edge_max_length = try api.createMethod("NavigationMesh", "set_edge_max_length");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_edge_max_length),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_edge_max_length, base, cargs, result);
    }

    pub fn setFilterLedgeSpans(self: *const Self, arg_filter_ledge_spans: bool) !void {
        if (mbind_set_filter_ledge_spans == null) {
            mbind_set_filter_ledge_spans = try api.createMethod("NavigationMesh", "set_filter_ledge_spans");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_filter_ledge_spans),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_filter_ledge_spans, base, cargs, result);
    }

    pub fn setFilterLowHangingObstacles(self: *const Self, arg_filter_low_hanging_obstacles: bool) !void {
        if (mbind_set_filter_low_hanging_obstacles == null) {
            mbind_set_filter_low_hanging_obstacles = try api.createMethod("NavigationMesh", "set_filter_low_hanging_obstacles");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_filter_low_hanging_obstacles),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_filter_low_hanging_obstacles, base, cargs, result);
    }

    pub fn setFilterWalkableLowHeightSpans(self: *const Self, arg_filter_walkable_low_height_spans: bool) !void {
        if (mbind_set_filter_walkable_low_height_spans == null) {
            mbind_set_filter_walkable_low_height_spans = try api.createMethod("NavigationMesh", "set_filter_walkable_low_height_spans");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_filter_walkable_low_height_spans),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_filter_walkable_low_height_spans, base, cargs, result);
    }

    pub fn setParsedGeometryType(self: *const Self, arg_geometry_type: i32) !void {
        if (mbind_set_parsed_geometry_type == null) {
            mbind_set_parsed_geometry_type = try api.createMethod("NavigationMesh", "set_parsed_geometry_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_geometry_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_parsed_geometry_type, base, cargs, result);
    }

    pub fn setRegionMergeSize(self: *const Self, arg_region_merge_size: f32) !void {
        if (mbind_set_region_merge_size == null) {
            mbind_set_region_merge_size = try api.createMethod("NavigationMesh", "set_region_merge_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_region_merge_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_region_merge_size, base, cargs, result);
    }

    pub fn setRegionMinSize(self: *const Self, arg_region_min_size: f32) !void {
        if (mbind_set_region_min_size == null) {
            mbind_set_region_min_size = try api.createMethod("NavigationMesh", "set_region_min_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_region_min_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_region_min_size, base, cargs, result);
    }

    pub fn setSamplePartitionType(self: *const Self, arg_sample_partition_type: i32) !void {
        if (mbind_set_sample_partition_type == null) {
            mbind_set_sample_partition_type = try api.createMethod("NavigationMesh", "set_sample_partition_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_sample_partition_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_sample_partition_type, base, cargs, result);
    }

    pub fn setSourceGeometryMode(self: *const Self, arg_mask: i32) !void {
        if (mbind_set_source_geometry_mode == null) {
            mbind_set_source_geometry_mode = try api.createMethod("NavigationMesh", "set_source_geometry_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_source_geometry_mode, base, cargs, result);
    }

    pub fn setSourceGroupName(self: *const Self, arg_mask: *const godot.String) !void {
        if (mbind_set_source_group_name == null) {
            mbind_set_source_group_name = try api.createMethod("NavigationMesh", "set_source_group_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_source_group_name, base, cargs, result);
    }

    pub fn setVertices(self: *const Self, arg_vertices: *const godot.PoolVector3Array) !void {
        if (mbind_set_vertices == null) {
            mbind_set_vertices = try api.createMethod("NavigationMesh", "set_vertices");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_vertices),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_vertices, base, cargs, result);
    }

    pub fn setVertsPerPoly(self: *const Self, arg_verts_per_poly: f32) !void {
        if (mbind_set_verts_per_poly == null) {
            mbind_set_verts_per_poly = try api.createMethod("NavigationMesh", "set_verts_per_poly");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_verts_per_poly),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_verts_per_poly, base, cargs, result);
    }
};