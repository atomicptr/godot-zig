// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Popup = @import("popup.zig").Popup;

// method bindings
var mbind_add_check_item: ?*c_api.godot_method_bind = null;
var mbind_add_check_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_icon_check_item: ?*c_api.godot_method_bind = null;
var mbind_add_icon_check_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_icon_item: ?*c_api.godot_method_bind = null;
var mbind_add_icon_radio_check_item: ?*c_api.godot_method_bind = null;
var mbind_add_icon_radio_check_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_icon_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_item: ?*c_api.godot_method_bind = null;
var mbind_add_multistate_item: ?*c_api.godot_method_bind = null;
var mbind_add_radio_check_item: ?*c_api.godot_method_bind = null;
var mbind_add_radio_check_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_separator: ?*c_api.godot_method_bind = null;
var mbind_add_shortcut: ?*c_api.godot_method_bind = null;
var mbind_add_submenu_item: ?*c_api.godot_method_bind = null;
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_get_allow_search: ?*c_api.godot_method_bind = null;
var mbind_get_current_index: ?*c_api.godot_method_bind = null;
var mbind_get_item_accelerator: ?*c_api.godot_method_bind = null;
var mbind_get_item_count: ?*c_api.godot_method_bind = null;
var mbind_get_item_icon: ?*c_api.godot_method_bind = null;
var mbind_get_item_id: ?*c_api.godot_method_bind = null;
var mbind_get_item_index: ?*c_api.godot_method_bind = null;
var mbind_get_item_metadata: ?*c_api.godot_method_bind = null;
var mbind_get_item_shortcut: ?*c_api.godot_method_bind = null;
var mbind_get_item_submenu: ?*c_api.godot_method_bind = null;
var mbind_get_item_text: ?*c_api.godot_method_bind = null;
var mbind_get_item_tooltip: ?*c_api.godot_method_bind = null;
var mbind_get_submenu_popup_delay: ?*c_api.godot_method_bind = null;
var mbind_is_hide_on_checkable_item_selection: ?*c_api.godot_method_bind = null;
var mbind_is_hide_on_item_selection: ?*c_api.godot_method_bind = null;
var mbind_is_hide_on_state_item_selection: ?*c_api.godot_method_bind = null;
var mbind_is_hide_on_window_lose_focus: ?*c_api.godot_method_bind = null;
var mbind_is_item_checkable: ?*c_api.godot_method_bind = null;
var mbind_is_item_checked: ?*c_api.godot_method_bind = null;
var mbind_is_item_disabled: ?*c_api.godot_method_bind = null;
var mbind_is_item_radio_checkable: ?*c_api.godot_method_bind = null;
var mbind_is_item_separator: ?*c_api.godot_method_bind = null;
var mbind_is_item_shortcut_disabled: ?*c_api.godot_method_bind = null;
var mbind_remove_item: ?*c_api.godot_method_bind = null;
var mbind_set_allow_search: ?*c_api.godot_method_bind = null;
var mbind_set_hide_on_checkable_item_selection: ?*c_api.godot_method_bind = null;
var mbind_set_hide_on_item_selection: ?*c_api.godot_method_bind = null;
var mbind_set_hide_on_state_item_selection: ?*c_api.godot_method_bind = null;
var mbind_set_hide_on_window_lose_focus: ?*c_api.godot_method_bind = null;
var mbind_set_item_accelerator: ?*c_api.godot_method_bind = null;
var mbind_set_item_as_checkable: ?*c_api.godot_method_bind = null;
var mbind_set_item_as_radio_checkable: ?*c_api.godot_method_bind = null;
var mbind_set_item_as_separator: ?*c_api.godot_method_bind = null;
var mbind_set_item_checked: ?*c_api.godot_method_bind = null;
var mbind_set_item_disabled: ?*c_api.godot_method_bind = null;
var mbind_set_item_icon: ?*c_api.godot_method_bind = null;
var mbind_set_item_id: ?*c_api.godot_method_bind = null;
var mbind_set_item_metadata: ?*c_api.godot_method_bind = null;
var mbind_set_item_multistate: ?*c_api.godot_method_bind = null;
var mbind_set_item_shortcut: ?*c_api.godot_method_bind = null;
var mbind_set_item_shortcut_disabled: ?*c_api.godot_method_bind = null;
var mbind_set_item_submenu: ?*c_api.godot_method_bind = null;
var mbind_set_item_text: ?*c_api.godot_method_bind = null;
var mbind_set_item_tooltip: ?*c_api.godot_method_bind = null;
var mbind_set_submenu_popup_delay: ?*c_api.godot_method_bind = null;
var mbind_toggle_item_checked: ?*c_api.godot_method_bind = null;
var mbind_toggle_item_multistate: ?*c_api.godot_method_bind = null;
var mbind_popup_menu_constructor: ?fn () ?*c_api.godot_object = null;

pub const PopupMenu = struct {
    const Self = @This();
    const BaseClass = Popup;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_popup_menu_constructor == null) {
            mbind_popup_menu_constructor = try api.createConstructor("PopupMenu");
        }
        return api.createObject(Self, mbind_popup_menu_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addCheckItem(self: *const Self, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_check_item == null) {
            mbind_add_check_item = try api.createMethod("PopupMenu", "add_check_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_check_item, base, cargs, result);
    }

    pub fn addCheckShortcut(self: *const Self, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_check_shortcut == null) {
            mbind_add_check_shortcut = try api.createMethod("PopupMenu", "add_check_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_check_shortcut, base, cargs, result);
    }

    pub fn addIconCheckItem(self: *const Self, arg_texture: *const godot.Texture, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_icon_check_item == null) {
            mbind_add_icon_check_item = try api.createMethod("PopupMenu", "add_icon_check_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_check_item, base, cargs, result);
    }

    pub fn addIconCheckShortcut(self: *const Self, arg_texture: *const godot.Texture, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_icon_check_shortcut == null) {
            mbind_add_icon_check_shortcut = try api.createMethod("PopupMenu", "add_icon_check_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_check_shortcut, base, cargs, result);
    }

    pub fn addIconItem(self: *const Self, arg_texture: *const godot.Texture, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_icon_item == null) {
            mbind_add_icon_item = try api.createMethod("PopupMenu", "add_icon_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_item, base, cargs, result);
    }

    pub fn addIconRadioCheckItem(self: *const Self, arg_texture: *const godot.Texture, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_icon_radio_check_item == null) {
            mbind_add_icon_radio_check_item = try api.createMethod("PopupMenu", "add_icon_radio_check_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_radio_check_item, base, cargs, result);
    }

    pub fn addIconRadioCheckShortcut(self: *const Self, arg_texture: *const godot.Texture, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_icon_radio_check_shortcut == null) {
            mbind_add_icon_radio_check_shortcut = try api.createMethod("PopupMenu", "add_icon_radio_check_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_radio_check_shortcut, base, cargs, result);
    }

    pub fn addIconShortcut(self: *const Self, arg_texture: *const godot.Texture, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_icon_shortcut == null) {
            mbind_add_icon_shortcut = try api.createMethod("PopupMenu", "add_icon_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_texture),
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_shortcut, base, cargs, result);
    }

    pub fn addItem(self: *const Self, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_item == null) {
            mbind_add_item = try api.createMethod("PopupMenu", "add_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_item, base, cargs, result);
    }

    pub fn addMultistateItem(self: *const Self, arg_label: *const godot.String, arg_max_states: i32, arg_default_state: i32, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_multistate_item == null) {
            mbind_add_multistate_item = try api.createMethod("PopupMenu", "add_multistate_item");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_max_states),
            @ptrCast(*const anyopaque, *arg_default_state),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_multistate_item, base, cargs, result);
    }

    pub fn addRadioCheckItem(self: *const Self, arg_label: *const godot.String, arg_id: i32, arg_accel: i32) !void {
        if (mbind_add_radio_check_item == null) {
            mbind_add_radio_check_item = try api.createMethod("PopupMenu", "add_radio_check_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_radio_check_item, base, cargs, result);
    }

    pub fn addRadioCheckShortcut(self: *const Self, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_radio_check_shortcut == null) {
            mbind_add_radio_check_shortcut = try api.createMethod("PopupMenu", "add_radio_check_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_radio_check_shortcut, base, cargs, result);
    }

    pub fn addSeparator(self: *const Self, arg_label: *const godot.String, arg_id: i32) !void {
        if (mbind_add_separator == null) {
            mbind_add_separator = try api.createMethod("PopupMenu", "add_separator");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_separator, base, cargs, result);
    }

    pub fn addShortcut(self: *const Self, arg_shortcut: *const godot.ShortCut, arg_id: i32, arg_global: bool) !void {
        if (mbind_add_shortcut == null) {
            mbind_add_shortcut = try api.createMethod("PopupMenu", "add_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_shortcut, base, cargs, result);
    }

    pub fn addSubmenuItem(self: *const Self, arg_label: *const godot.String, arg_submenu: *const godot.String, arg_id: i32) !void {
        if (mbind_add_submenu_item == null) {
            mbind_add_submenu_item = try api.createMethod("PopupMenu", "add_submenu_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, arg_submenu),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_submenu_item, base, cargs, result);
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("PopupMenu", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn getAllowSearch(self: *const Self) !bool {
        if (mbind_get_allow_search == null) {
            mbind_get_allow_search = try api.createMethod("PopupMenu", "get_allow_search");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_allow_search, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCurrentIndex(self: *const Self) !i32 {
        if (mbind_get_current_index == null) {
            mbind_get_current_index = try api.createMethod("PopupMenu", "get_current_index");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemAccelerator(self: *const Self, arg_idx: i32) !i32 {
        if (mbind_get_item_accelerator == null) {
            mbind_get_item_accelerator = try api.createMethod("PopupMenu", "get_item_accelerator");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_accelerator, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemCount(self: *const Self) !i32 {
        if (mbind_get_item_count == null) {
            mbind_get_item_count = try api.createMethod("PopupMenu", "get_item_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemIcon(self: *const Self, arg_idx: i32) !godot.Texture {
        if (mbind_get_item_icon == null) {
            mbind_get_item_icon = try api.createMethod("PopupMenu", "get_item_icon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_icon, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getItemId(self: *const Self, arg_idx: i32) !i32 {
        if (mbind_get_item_id == null) {
            mbind_get_item_id = try api.createMethod("PopupMenu", "get_item_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemIndex(self: *const Self, arg_id: i32) !i32 {
        if (mbind_get_item_index == null) {
            mbind_get_item_index = try api.createMethod("PopupMenu", "get_item_index");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemMetadata(self: *const Self, arg_idx: i32) !godot.Variant {
        if (mbind_get_item_metadata == null) {
            mbind_get_item_metadata = try api.createMethod("PopupMenu", "get_item_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_metadata, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn getItemShortcut(self: *const Self, arg_idx: i32) !godot.ShortCut {
        if (mbind_get_item_shortcut == null) {
            mbind_get_item_shortcut = try api.createMethod("PopupMenu", "get_item_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_shortcut, base, cargs, result);
        return @ptrCast(*godot.ShortCut, @alignCast(@alignOf(&godot.ShortCut), result)).*;
    }

    pub fn getItemSubmenu(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_item_submenu == null) {
            mbind_get_item_submenu = try api.createMethod("PopupMenu", "get_item_submenu");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_submenu, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getItemText(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_item_text == null) {
            mbind_get_item_text = try api.createMethod("PopupMenu", "get_item_text");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getItemTooltip(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_item_tooltip == null) {
            mbind_get_item_tooltip = try api.createMethod("PopupMenu", "get_item_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_tooltip, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getSubmenuPopupDelay(self: *const Self) !f32 {
        if (mbind_get_submenu_popup_delay == null) {
            mbind_get_submenu_popup_delay = try api.createMethod("PopupMenu", "get_submenu_popup_delay");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_submenu_popup_delay, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn isHideOnCheckableItemSelection(self: *const Self) !bool {
        if (mbind_is_hide_on_checkable_item_selection == null) {
            mbind_is_hide_on_checkable_item_selection = try api.createMethod("PopupMenu", "is_hide_on_checkable_item_selection");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_hide_on_checkable_item_selection, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHideOnItemSelection(self: *const Self) !bool {
        if (mbind_is_hide_on_item_selection == null) {
            mbind_is_hide_on_item_selection = try api.createMethod("PopupMenu", "is_hide_on_item_selection");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_hide_on_item_selection, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHideOnStateItemSelection(self: *const Self) !bool {
        if (mbind_is_hide_on_state_item_selection == null) {
            mbind_is_hide_on_state_item_selection = try api.createMethod("PopupMenu", "is_hide_on_state_item_selection");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_hide_on_state_item_selection, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHideOnWindowLoseFocus(self: *const Self) !bool {
        if (mbind_is_hide_on_window_lose_focus == null) {
            mbind_is_hide_on_window_lose_focus = try api.createMethod("PopupMenu", "is_hide_on_window_lose_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_hide_on_window_lose_focus, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemCheckable(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_checkable == null) {
            mbind_is_item_checkable = try api.createMethod("PopupMenu", "is_item_checkable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_checkable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemChecked(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_checked == null) {
            mbind_is_item_checked = try api.createMethod("PopupMenu", "is_item_checked");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_checked, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemDisabled(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_disabled == null) {
            mbind_is_item_disabled = try api.createMethod("PopupMenu", "is_item_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemRadioCheckable(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_radio_checkable == null) {
            mbind_is_item_radio_checkable = try api.createMethod("PopupMenu", "is_item_radio_checkable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_radio_checkable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemSeparator(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_separator == null) {
            mbind_is_item_separator = try api.createMethod("PopupMenu", "is_item_separator");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_separator, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemShortcutDisabled(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_shortcut_disabled == null) {
            mbind_is_item_shortcut_disabled = try api.createMethod("PopupMenu", "is_item_shortcut_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_shortcut_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn removeItem(self: *const Self, arg_idx: i32) !void {
        if (mbind_remove_item == null) {
            mbind_remove_item = try api.createMethod("PopupMenu", "remove_item");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_item, base, cargs, result);
    }

    pub fn setAllowSearch(self: *const Self, arg_allow: bool) !void {
        if (mbind_set_allow_search == null) {
            mbind_set_allow_search = try api.createMethod("PopupMenu", "set_allow_search");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_allow),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_allow_search, base, cargs, result);
    }

    pub fn setHideOnCheckableItemSelection(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hide_on_checkable_item_selection == null) {
            mbind_set_hide_on_checkable_item_selection = try api.createMethod("PopupMenu", "set_hide_on_checkable_item_selection");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hide_on_checkable_item_selection, base, cargs, result);
    }

    pub fn setHideOnItemSelection(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hide_on_item_selection == null) {
            mbind_set_hide_on_item_selection = try api.createMethod("PopupMenu", "set_hide_on_item_selection");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hide_on_item_selection, base, cargs, result);
    }

    pub fn setHideOnStateItemSelection(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hide_on_state_item_selection == null) {
            mbind_set_hide_on_state_item_selection = try api.createMethod("PopupMenu", "set_hide_on_state_item_selection");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hide_on_state_item_selection, base, cargs, result);
    }

    pub fn setHideOnWindowLoseFocus(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hide_on_window_lose_focus == null) {
            mbind_set_hide_on_window_lose_focus = try api.createMethod("PopupMenu", "set_hide_on_window_lose_focus");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hide_on_window_lose_focus, base, cargs, result);
    }

    pub fn setItemAccelerator(self: *const Self, arg_idx: i32, arg_accel: i32) !void {
        if (mbind_set_item_accelerator == null) {
            mbind_set_item_accelerator = try api.createMethod("PopupMenu", "set_item_accelerator");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_accel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_accelerator, base, cargs, result);
    }

    pub fn setItemAsCheckable(self: *const Self, arg_idx: i32, arg_enable: bool) !void {
        if (mbind_set_item_as_checkable == null) {
            mbind_set_item_as_checkable = try api.createMethod("PopupMenu", "set_item_as_checkable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_as_checkable, base, cargs, result);
    }

    pub fn setItemAsRadioCheckable(self: *const Self, arg_idx: i32, arg_enable: bool) !void {
        if (mbind_set_item_as_radio_checkable == null) {
            mbind_set_item_as_radio_checkable = try api.createMethod("PopupMenu", "set_item_as_radio_checkable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_as_radio_checkable, base, cargs, result);
    }

    pub fn setItemAsSeparator(self: *const Self, arg_idx: i32, arg_enable: bool) !void {
        if (mbind_set_item_as_separator == null) {
            mbind_set_item_as_separator = try api.createMethod("PopupMenu", "set_item_as_separator");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_as_separator, base, cargs, result);
    }

    pub fn setItemChecked(self: *const Self, arg_idx: i32, arg_checked: bool) !void {
        if (mbind_set_item_checked == null) {
            mbind_set_item_checked = try api.createMethod("PopupMenu", "set_item_checked");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_checked),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_checked, base, cargs, result);
    }

    pub fn setItemDisabled(self: *const Self, arg_idx: i32, arg_disabled: bool) !void {
        if (mbind_set_item_disabled == null) {
            mbind_set_item_disabled = try api.createMethod("PopupMenu", "set_item_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_disabled, base, cargs, result);
    }

    pub fn setItemIcon(self: *const Self, arg_idx: i32, arg_icon: *const godot.Texture) !void {
        if (mbind_set_item_icon == null) {
            mbind_set_item_icon = try api.createMethod("PopupMenu", "set_item_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_icon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_icon, base, cargs, result);
    }

    pub fn setItemId(self: *const Self, arg_idx: i32, arg_id: i32) !void {
        if (mbind_set_item_id == null) {
            mbind_set_item_id = try api.createMethod("PopupMenu", "set_item_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_id, base, cargs, result);
    }

    pub fn setItemMetadata(self: *const Self, arg_idx: i32, arg_metadata: *const godot.Variant) !void {
        if (mbind_set_item_metadata == null) {
            mbind_set_item_metadata = try api.createMethod("PopupMenu", "set_item_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_metadata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_metadata, base, cargs, result);
    }

    pub fn setItemMultistate(self: *const Self, arg_idx: i32, arg_state: i32) !void {
        if (mbind_set_item_multistate == null) {
            mbind_set_item_multistate = try api.createMethod("PopupMenu", "set_item_multistate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_state),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_multistate, base, cargs, result);
    }

    pub fn setItemShortcut(self: *const Self, arg_idx: i32, arg_shortcut: *const godot.ShortCut, arg_global: bool) !void {
        if (mbind_set_item_shortcut == null) {
            mbind_set_item_shortcut = try api.createMethod("PopupMenu", "set_item_shortcut");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_shortcut),
            @ptrCast(*const anyopaque, *arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_shortcut, base, cargs, result);
    }

    pub fn setItemShortcutDisabled(self: *const Self, arg_idx: i32, arg_disabled: bool) !void {
        if (mbind_set_item_shortcut_disabled == null) {
            mbind_set_item_shortcut_disabled = try api.createMethod("PopupMenu", "set_item_shortcut_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_shortcut_disabled, base, cargs, result);
    }

    pub fn setItemSubmenu(self: *const Self, arg_idx: i32, arg_submenu: *const godot.String) !void {
        if (mbind_set_item_submenu == null) {
            mbind_set_item_submenu = try api.createMethod("PopupMenu", "set_item_submenu");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_submenu),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_submenu, base, cargs, result);
    }

    pub fn setItemText(self: *const Self, arg_idx: i32, arg_text: *const godot.String) !void {
        if (mbind_set_item_text == null) {
            mbind_set_item_text = try api.createMethod("PopupMenu", "set_item_text");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_text, base, cargs, result);
    }

    pub fn setItemTooltip(self: *const Self, arg_idx: i32, arg_tooltip: *const godot.String) !void {
        if (mbind_set_item_tooltip == null) {
            mbind_set_item_tooltip = try api.createMethod("PopupMenu", "set_item_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_tooltip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_tooltip, base, cargs, result);
    }

    pub fn setSubmenuPopupDelay(self: *const Self, arg_seconds: f32) !void {
        if (mbind_set_submenu_popup_delay == null) {
            mbind_set_submenu_popup_delay = try api.createMethod("PopupMenu", "set_submenu_popup_delay");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_seconds),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_submenu_popup_delay, base, cargs, result);
    }

    pub fn toggleItemChecked(self: *const Self, arg_idx: i32) !void {
        if (mbind_toggle_item_checked == null) {
            mbind_toggle_item_checked = try api.createMethod("PopupMenu", "toggle_item_checked");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_toggle_item_checked, base, cargs, result);
    }

    pub fn toggleItemMultistate(self: *const Self, arg_idx: i32) !void {
        if (mbind_toggle_item_multistate == null) {
            mbind_toggle_item_multistate = try api.createMethod("PopupMenu", "toggle_item_multistate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_toggle_item_multistate, base, cargs, result);
    }
};