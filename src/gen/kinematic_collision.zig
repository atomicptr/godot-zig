// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Reference = @import("reference.zig").Reference;

// method bindings
var mbind_get_angle: ?*c_api.godot_method_bind = null;
var mbind_get_collider: ?*c_api.godot_method_bind = null;
var mbind_get_collider_id: ?*c_api.godot_method_bind = null;
var mbind_get_collider_metadata: ?*c_api.godot_method_bind = null;
var mbind_get_collider_rid: ?*c_api.godot_method_bind = null;
var mbind_get_collider_shape: ?*c_api.godot_method_bind = null;
var mbind_get_collider_shape_index: ?*c_api.godot_method_bind = null;
var mbind_get_collider_velocity: ?*c_api.godot_method_bind = null;
var mbind_get_local_shape: ?*c_api.godot_method_bind = null;
var mbind_get_normal: ?*c_api.godot_method_bind = null;
var mbind_get_position: ?*c_api.godot_method_bind = null;
var mbind_get_remainder: ?*c_api.godot_method_bind = null;
var mbind_get_travel: ?*c_api.godot_method_bind = null;
var mbind_kinematic_collision_constructor: ?fn () ?*c_api.godot_object = null;

pub const KinematicCollision = struct {
    const Self = @This();
    const BaseClass = Reference;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_kinematic_collision_constructor == null) {
            mbind_kinematic_collision_constructor = try api.createConstructor("KinematicCollision");
        }
        return api.createObject(Self, mbind_kinematic_collision_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getAngle(self: *const Self, arg_up_direction: *const godot.Vector3) !f32 {
        if (mbind_get_angle == null) {
            mbind_get_angle = try api.createMethod("KinematicCollision", "get_angle");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_up_direction),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_angle, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollider(self: *const Self) !godot.Object {
        if (mbind_get_collider == null) {
            mbind_get_collider = try api.createMethod("KinematicCollision", "get_collider");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider, base, cargs, result);
        return @ptrCast(*godot.Object, @alignCast(@alignOf(&godot.Object), result)).*;
    }

    pub fn getColliderId(self: *const Self) !i32 {
        if (mbind_get_collider_id == null) {
            mbind_get_collider_id = try api.createMethod("KinematicCollision", "get_collider_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getColliderMetadata(self: *const Self) !godot.Variant {
        if (mbind_get_collider_metadata == null) {
            mbind_get_collider_metadata = try api.createMethod("KinematicCollision", "get_collider_metadata");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_metadata, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn getColliderRid(self: *const Self) !godot.RID {
        if (mbind_get_collider_rid == null) {
            mbind_get_collider_rid = try api.createMethod("KinematicCollision", "get_collider_rid");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_rid, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getColliderShape(self: *const Self) !godot.Object {
        if (mbind_get_collider_shape == null) {
            mbind_get_collider_shape = try api.createMethod("KinematicCollision", "get_collider_shape");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_shape, base, cargs, result);
        return @ptrCast(*godot.Object, @alignCast(@alignOf(&godot.Object), result)).*;
    }

    pub fn getColliderShapeIndex(self: *const Self) !i32 {
        if (mbind_get_collider_shape_index == null) {
            mbind_get_collider_shape_index = try api.createMethod("KinematicCollision", "get_collider_shape_index");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_shape_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getColliderVelocity(self: *const Self) !godot.Vector3 {
        if (mbind_get_collider_velocity == null) {
            mbind_get_collider_velocity = try api.createMethod("KinematicCollision", "get_collider_velocity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_velocity, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getLocalShape(self: *const Self) !godot.Object {
        if (mbind_get_local_shape == null) {
            mbind_get_local_shape = try api.createMethod("KinematicCollision", "get_local_shape");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_local_shape, base, cargs, result);
        return @ptrCast(*godot.Object, @alignCast(@alignOf(&godot.Object), result)).*;
    }

    pub fn getNormal(self: *const Self) !godot.Vector3 {
        if (mbind_get_normal == null) {
            mbind_get_normal = try api.createMethod("KinematicCollision", "get_normal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_normal, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getPosition(self: *const Self) !godot.Vector3 {
        if (mbind_get_position == null) {
            mbind_get_position = try api.createMethod("KinematicCollision", "get_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_position, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getRemainder(self: *const Self) !godot.Vector3 {
        if (mbind_get_remainder == null) {
            mbind_get_remainder = try api.createMethod("KinematicCollision", "get_remainder");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_remainder, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getTravel(self: *const Self) !godot.Vector3 {
        if (mbind_get_travel == null) {
            mbind_get_travel = try api.createMethod("KinematicCollision", "get_travel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_travel, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }
};