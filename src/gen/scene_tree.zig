// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const MainLoop = @import("main_loop.zig").MainLoop;

// method bindings
var mbind_call_group: ?*c_api.godot_method_bind = null;
var mbind_call_group_flags: ?*c_api.godot_method_bind = null;
var mbind_change_scene: ?*c_api.godot_method_bind = null;
var mbind_change_scene_to: ?*c_api.godot_method_bind = null;
var mbind_create_timer: ?*c_api.godot_method_bind = null;
var mbind_get_current_scene: ?*c_api.godot_method_bind = null;
var mbind_get_edited_scene_root: ?*c_api.godot_method_bind = null;
var mbind_get_frame: ?*c_api.godot_method_bind = null;
var mbind_get_multiplayer: ?*c_api.godot_method_bind = null;
var mbind_get_network_connected_peers: ?*c_api.godot_method_bind = null;
var mbind_get_network_peer: ?*c_api.godot_method_bind = null;
var mbind_get_network_unique_id: ?*c_api.godot_method_bind = null;
var mbind_get_node_count: ?*c_api.godot_method_bind = null;
var mbind_get_nodes_in_group: ?*c_api.godot_method_bind = null;
var mbind_get_root: ?*c_api.godot_method_bind = null;
var mbind_get_rpc_sender_id: ?*c_api.godot_method_bind = null;
var mbind_has_group: ?*c_api.godot_method_bind = null;
var mbind_has_network_peer: ?*c_api.godot_method_bind = null;
var mbind_is_debugging_collisions_hint: ?*c_api.godot_method_bind = null;
var mbind_is_debugging_navigation_hint: ?*c_api.godot_method_bind = null;
var mbind_is_input_handled: ?*c_api.godot_method_bind = null;
var mbind_is_multiplayer_poll_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_network_server: ?*c_api.godot_method_bind = null;
var mbind_is_paused: ?*c_api.godot_method_bind = null;
var mbind_is_refusing_new_network_connections: ?*c_api.godot_method_bind = null;
var mbind_is_using_font_oversampling: ?*c_api.godot_method_bind = null;
var mbind_notify_group: ?*c_api.godot_method_bind = null;
var mbind_notify_group_flags: ?*c_api.godot_method_bind = null;
var mbind_queue_delete: ?*c_api.godot_method_bind = null;
var mbind_quit: ?*c_api.godot_method_bind = null;
var mbind_reload_current_scene: ?*c_api.godot_method_bind = null;
var mbind_set_auto_accept_quit: ?*c_api.godot_method_bind = null;
var mbind_set_current_scene: ?*c_api.godot_method_bind = null;
var mbind_set_debug_collisions_hint: ?*c_api.godot_method_bind = null;
var mbind_set_debug_navigation_hint: ?*c_api.godot_method_bind = null;
var mbind_set_edited_scene_root: ?*c_api.godot_method_bind = null;
var mbind_set_group: ?*c_api.godot_method_bind = null;
var mbind_set_group_flags: ?*c_api.godot_method_bind = null;
var mbind_set_input_as_handled: ?*c_api.godot_method_bind = null;
var mbind_set_multiplayer: ?*c_api.godot_method_bind = null;
var mbind_set_multiplayer_poll_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_network_peer: ?*c_api.godot_method_bind = null;
var mbind_set_pause: ?*c_api.godot_method_bind = null;
var mbind_set_quit_on_go_back: ?*c_api.godot_method_bind = null;
var mbind_set_refuse_new_network_connections: ?*c_api.godot_method_bind = null;
var mbind_set_screen_stretch: ?*c_api.godot_method_bind = null;
var mbind_set_use_font_oversampling: ?*c_api.godot_method_bind = null;
var mbind_scene_tree_constructor: ?fn () ?*c_api.godot_object = null;

pub const SceneTree = struct {
    const Self = @This();
    const BaseClass = MainLoop;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_scene_tree_constructor == null) {
            mbind_scene_tree_constructor = try api.createConstructor("SceneTree");
        }
        return api.createObject(Self, mbind_scene_tree_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn callGroup(self: *const Self, arg_group: *const godot.String, arg_method: *const godot.String) !godot.Variant {
        if (mbind_call_group == null) {
            mbind_call_group = try api.createMethod("SceneTree", "call_group");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_call_group, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn callGroupFlags(self: *const Self, arg_flags: i32, arg_group: *const godot.String, arg_method: *const godot.String) !godot.Variant {
        if (mbind_call_group_flags == null) {
            mbind_call_group_flags = try api.createMethod("SceneTree", "call_group_flags");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flags),
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_call_group_flags, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn changeScene(self: *const Self, arg_path: *const godot.String) !i32 {
        if (mbind_change_scene == null) {
            mbind_change_scene = try api.createMethod("SceneTree", "change_scene");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_change_scene, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn changeSceneTo(self: *const Self, arg_packed_scene: *const godot.PackedScene) !i32 {
        if (mbind_change_scene_to == null) {
            mbind_change_scene_to = try api.createMethod("SceneTree", "change_scene_to");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_packed_scene),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_change_scene_to, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn createTimer(self: *const Self, arg_time_sec: f32, arg_pause_mode_process: bool) !godot.SceneTreeTimer {
        if (mbind_create_timer == null) {
            mbind_create_timer = try api.createMethod("SceneTree", "create_timer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_time_sec),
            @ptrCast(*const anyopaque, *arg_pause_mode_process),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_create_timer, base, cargs, result);
        return @ptrCast(*godot.SceneTreeTimer, @alignCast(@alignOf(&godot.SceneTreeTimer), result)).*;
    }

    pub fn getCurrentScene(self: *const Self) !godot.Node {
        if (mbind_get_current_scene == null) {
            mbind_get_current_scene = try api.createMethod("SceneTree", "get_current_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_scene, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getEditedSceneRoot(self: *const Self) !godot.Node {
        if (mbind_get_edited_scene_root == null) {
            mbind_get_edited_scene_root = try api.createMethod("SceneTree", "get_edited_scene_root");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_edited_scene_root, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getFrame(self: *const Self) !i32 {
        if (mbind_get_frame == null) {
            mbind_get_frame = try api.createMethod("SceneTree", "get_frame");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_frame, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMultiplayer(self: *const Self) !godot.MultiplayerAPI {
        if (mbind_get_multiplayer == null) {
            mbind_get_multiplayer = try api.createMethod("SceneTree", "get_multiplayer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_multiplayer, base, cargs, result);
        return @ptrCast(*godot.MultiplayerAPI, @alignCast(@alignOf(&godot.MultiplayerAPI), result)).*;
    }

    pub fn getNetworkConnectedPeers(self: *const Self) !godot.PoolIntArray {
        if (mbind_get_network_connected_peers == null) {
            mbind_get_network_connected_peers = try api.createMethod("SceneTree", "get_network_connected_peers");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_network_connected_peers, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn getNetworkPeer(self: *const Self) !godot.NetworkedMultiplayerPeer {
        if (mbind_get_network_peer == null) {
            mbind_get_network_peer = try api.createMethod("SceneTree", "get_network_peer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_network_peer, base, cargs, result);
        return @ptrCast(*godot.NetworkedMultiplayerPeer, @alignCast(@alignOf(&godot.NetworkedMultiplayerPeer), result)).*;
    }

    pub fn getNetworkUniqueId(self: *const Self) !i32 {
        if (mbind_get_network_unique_id == null) {
            mbind_get_network_unique_id = try api.createMethod("SceneTree", "get_network_unique_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_network_unique_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNodeCount(self: *const Self) !i32 {
        if (mbind_get_node_count == null) {
            mbind_get_node_count = try api.createMethod("SceneTree", "get_node_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNodesInGroup(self: *const Self, arg_group: *const godot.String) !godot.Array {
        if (mbind_get_nodes_in_group == null) {
            mbind_get_nodes_in_group = try api.createMethod("SceneTree", "get_nodes_in_group");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_nodes_in_group, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getRoot(self: *const Self) !godot.Viewport {
        if (mbind_get_root == null) {
            mbind_get_root = try api.createMethod("SceneTree", "get_root");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_root, base, cargs, result);
        return @ptrCast(*godot.Viewport, @alignCast(@alignOf(&godot.Viewport), result)).*;
    }

    pub fn getRpcSenderId(self: *const Self) !i32 {
        if (mbind_get_rpc_sender_id == null) {
            mbind_get_rpc_sender_id = try api.createMethod("SceneTree", "get_rpc_sender_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rpc_sender_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn hasGroup(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_group == null) {
            mbind_has_group = try api.createMethod("SceneTree", "has_group");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_group, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasNetworkPeer(self: *const Self) !bool {
        if (mbind_has_network_peer == null) {
            mbind_has_network_peer = try api.createMethod("SceneTree", "has_network_peer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_network_peer, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDebuggingCollisionsHint(self: *const Self) !bool {
        if (mbind_is_debugging_collisions_hint == null) {
            mbind_is_debugging_collisions_hint = try api.createMethod("SceneTree", "is_debugging_collisions_hint");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_debugging_collisions_hint, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDebuggingNavigationHint(self: *const Self) !bool {
        if (mbind_is_debugging_navigation_hint == null) {
            mbind_is_debugging_navigation_hint = try api.createMethod("SceneTree", "is_debugging_navigation_hint");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_debugging_navigation_hint, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInputHandled(self: *const Self) !bool {
        if (mbind_is_input_handled == null) {
            mbind_is_input_handled = try api.createMethod("SceneTree", "is_input_handled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_input_handled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isMultiplayerPollEnabled(self: *const Self) !bool {
        if (mbind_is_multiplayer_poll_enabled == null) {
            mbind_is_multiplayer_poll_enabled = try api.createMethod("SceneTree", "is_multiplayer_poll_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_multiplayer_poll_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isNetworkServer(self: *const Self) !bool {
        if (mbind_is_network_server == null) {
            mbind_is_network_server = try api.createMethod("SceneTree", "is_network_server");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_network_server, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPaused(self: *const Self) !bool {
        if (mbind_is_paused == null) {
            mbind_is_paused = try api.createMethod("SceneTree", "is_paused");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_paused, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isRefusingNewNetworkConnections(self: *const Self) !bool {
        if (mbind_is_refusing_new_network_connections == null) {
            mbind_is_refusing_new_network_connections = try api.createMethod("SceneTree", "is_refusing_new_network_connections");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_refusing_new_network_connections, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingFontOversampling(self: *const Self) !bool {
        if (mbind_is_using_font_oversampling == null) {
            mbind_is_using_font_oversampling = try api.createMethod("SceneTree", "is_using_font_oversampling");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_font_oversampling, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn notifyGroup(self: *const Self, arg_group: *const godot.String, arg_notification: i32) !void {
        if (mbind_notify_group == null) {
            mbind_notify_group = try api.createMethod("SceneTree", "notify_group");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, *arg_notification),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_notify_group, base, cargs, result);
    }

    pub fn notifyGroupFlags(self: *const Self, arg_call_flags: i32, arg_group: *const godot.String, arg_notification: i32) !void {
        if (mbind_notify_group_flags == null) {
            mbind_notify_group_flags = try api.createMethod("SceneTree", "notify_group_flags");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_call_flags),
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, *arg_notification),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_notify_group_flags, base, cargs, result);
    }

    pub fn queueDelete(self: *const Self, arg_obj: *const godot.Object) !void {
        if (mbind_queue_delete == null) {
            mbind_queue_delete = try api.createMethod("SceneTree", "queue_delete");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_obj),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_queue_delete, base, cargs, result);
    }

    pub fn quit(self: *const Self, arg_exit_code: i32) !void {
        if (mbind_quit == null) {
            mbind_quit = try api.createMethod("SceneTree", "quit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_exit_code),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_quit, base, cargs, result);
    }

    pub fn reloadCurrentScene(self: *const Self) !i32 {
        if (mbind_reload_current_scene == null) {
            mbind_reload_current_scene = try api.createMethod("SceneTree", "reload_current_scene");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reload_current_scene, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn setAutoAcceptQuit(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_auto_accept_quit == null) {
            mbind_set_auto_accept_quit = try api.createMethod("SceneTree", "set_auto_accept_quit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_auto_accept_quit, base, cargs, result);
    }

    pub fn setCurrentScene(self: *const Self, arg_child_node: *const godot.Node) !void {
        if (mbind_set_current_scene == null) {
            mbind_set_current_scene = try api.createMethod("SceneTree", "set_current_scene");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_child_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_current_scene, base, cargs, result);
    }

    pub fn setDebugCollisionsHint(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_debug_collisions_hint == null) {
            mbind_set_debug_collisions_hint = try api.createMethod("SceneTree", "set_debug_collisions_hint");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_debug_collisions_hint, base, cargs, result);
    }

    pub fn setDebugNavigationHint(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_debug_navigation_hint == null) {
            mbind_set_debug_navigation_hint = try api.createMethod("SceneTree", "set_debug_navigation_hint");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_debug_navigation_hint, base, cargs, result);
    }

    pub fn setEditedSceneRoot(self: *const Self, arg_scene: *const godot.Node) !void {
        if (mbind_set_edited_scene_root == null) {
            mbind_set_edited_scene_root = try api.createMethod("SceneTree", "set_edited_scene_root");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scene),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_edited_scene_root, base, cargs, result);
    }

    pub fn setGroup(self: *const Self, arg_group: *const godot.String, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_set_group == null) {
            mbind_set_group = try api.createMethod("SceneTree", "set_group");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_group, base, cargs, result);
    }

    pub fn setGroupFlags(self: *const Self, arg_call_flags: i32, arg_group: *const godot.String, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_set_group_flags == null) {
            mbind_set_group_flags = try api.createMethod("SceneTree", "set_group_flags");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_call_flags),
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_group_flags, base, cargs, result);
    }

    pub fn setInputAsHandled(self: *const Self) !void {
        if (mbind_set_input_as_handled == null) {
            mbind_set_input_as_handled = try api.createMethod("SceneTree", "set_input_as_handled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_input_as_handled, base, cargs, result);
    }

    pub fn setMultiplayer(self: *const Self, arg_multiplayer: *const godot.MultiplayerAPI) !void {
        if (mbind_set_multiplayer == null) {
            mbind_set_multiplayer = try api.createMethod("SceneTree", "set_multiplayer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_multiplayer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_multiplayer, base, cargs, result);
    }

    pub fn setMultiplayerPollEnabled(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_multiplayer_poll_enabled == null) {
            mbind_set_multiplayer_poll_enabled = try api.createMethod("SceneTree", "set_multiplayer_poll_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_multiplayer_poll_enabled, base, cargs, result);
    }

    pub fn setNetworkPeer(self: *const Self, arg_peer: *const godot.NetworkedMultiplayerPeer) !void {
        if (mbind_set_network_peer == null) {
            mbind_set_network_peer = try api.createMethod("SceneTree", "set_network_peer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_peer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_network_peer, base, cargs, result);
    }

    pub fn setPause(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_pause == null) {
            mbind_set_pause = try api.createMethod("SceneTree", "set_pause");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pause, base, cargs, result);
    }

    pub fn setQuitOnGoBack(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_quit_on_go_back == null) {
            mbind_set_quit_on_go_back = try api.createMethod("SceneTree", "set_quit_on_go_back");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_quit_on_go_back, base, cargs, result);
    }

    pub fn setRefuseNewNetworkConnections(self: *const Self, arg_refuse: bool) !void {
        if (mbind_set_refuse_new_network_connections == null) {
            mbind_set_refuse_new_network_connections = try api.createMethod("SceneTree", "set_refuse_new_network_connections");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_refuse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_refuse_new_network_connections, base, cargs, result);
    }

    pub fn setScreenStretch(self: *const Self, arg_mode: i32, arg_aspect: i32, arg_minsize: *const godot.Vector2, arg_scale: f32) !void {
        if (mbind_set_screen_stretch == null) {
            mbind_set_screen_stretch = try api.createMethod("SceneTree", "set_screen_stretch");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
            @ptrCast(*const anyopaque, *arg_aspect),
            @ptrCast(*const anyopaque, arg_minsize),
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_screen_stretch, base, cargs, result);
    }

    pub fn setUseFontOversampling(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_font_oversampling == null) {
            mbind_set_use_font_oversampling = try api.createMethod("SceneTree", "set_use_font_oversampling");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_font_oversampling, base, cargs, result);
    }
};