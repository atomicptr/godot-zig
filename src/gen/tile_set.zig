// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Resource = @import("resource.zig").Resource;

// method bindings
var mbind_autotile_clear_bitmask_map: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_bitmask: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_bitmask_mode: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_icon_coordinate: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_light_occluder: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_navigation_polygon: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_size: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_spacing: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_subtile_priority: ?*c_api.godot_method_bind = null;
var mbind_autotile_get_z_index: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_bitmask: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_bitmask_mode: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_icon_coordinate: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_light_occluder: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_navigation_polygon: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_size: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_spacing: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_subtile_priority: ?*c_api.godot_method_bind = null;
var mbind_autotile_set_z_index: ?*c_api.godot_method_bind = null;
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_create_tile: ?*c_api.godot_method_bind = null;
var mbind_find_tile_by_name: ?*c_api.godot_method_bind = null;
var mbind_get_last_unused_tile_id: ?*c_api.godot_method_bind = null;
var mbind_get_tiles_ids: ?*c_api.godot_method_bind = null;
var mbind_remove_tile: ?*c_api.godot_method_bind = null;
var mbind_tile_add_shape: ?*c_api.godot_method_bind = null;
var mbind_tile_get_light_occluder: ?*c_api.godot_method_bind = null;
var mbind_tile_get_material: ?*c_api.godot_method_bind = null;
var mbind_tile_get_modulate: ?*c_api.godot_method_bind = null;
var mbind_tile_get_name: ?*c_api.godot_method_bind = null;
var mbind_tile_get_navigation_polygon: ?*c_api.godot_method_bind = null;
var mbind_tile_get_navigation_polygon_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_get_normal_map: ?*c_api.godot_method_bind = null;
var mbind_tile_get_occluder_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_get_region: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape_count: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape_one_way: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape_one_way_margin: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_tile_get_shapes: ?*c_api.godot_method_bind = null;
var mbind_tile_get_texture: ?*c_api.godot_method_bind = null;
var mbind_tile_get_texture_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_get_tile_mode: ?*c_api.godot_method_bind = null;
var mbind_tile_get_z_index: ?*c_api.godot_method_bind = null;
var mbind_tile_set_light_occluder: ?*c_api.godot_method_bind = null;
var mbind_tile_set_material: ?*c_api.godot_method_bind = null;
var mbind_tile_set_modulate: ?*c_api.godot_method_bind = null;
var mbind_tile_set_name: ?*c_api.godot_method_bind = null;
var mbind_tile_set_navigation_polygon: ?*c_api.godot_method_bind = null;
var mbind_tile_set_navigation_polygon_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_set_normal_map: ?*c_api.godot_method_bind = null;
var mbind_tile_set_occluder_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_set_region: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shape: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shape_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shape_one_way: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shape_one_way_margin: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_tile_set_shapes: ?*c_api.godot_method_bind = null;
var mbind_tile_set_texture: ?*c_api.godot_method_bind = null;
var mbind_tile_set_texture_offset: ?*c_api.godot_method_bind = null;
var mbind_tile_set_tile_mode: ?*c_api.godot_method_bind = null;
var mbind_tile_set_z_index: ?*c_api.godot_method_bind = null;
var mbind_tile_set_constructor: ?fn () ?*c_api.godot_object = null;

pub const TileSet = struct {
    const Self = @This();
    const BaseClass = Resource;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_tile_set_constructor == null) {
            mbind_tile_set_constructor = try api.createConstructor("TileSet");
        }
        return api.createObject(Self, mbind_tile_set_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn autotileClearBitmaskMap(self: *const Self, arg_id: i32) !void {
        if (mbind_autotile_clear_bitmask_map == null) {
            mbind_autotile_clear_bitmask_map = try api.createMethod("TileSet", "autotile_clear_bitmask_map");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_clear_bitmask_map, base, cargs, result);
    }

    pub fn autotileGetBitmask(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !i32 {
        if (mbind_autotile_get_bitmask == null) {
            mbind_autotile_get_bitmask = try api.createMethod("TileSet", "autotile_get_bitmask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_bitmask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn autotileGetBitmaskMode(self: *const Self, arg_id: i32) !i32 {
        if (mbind_autotile_get_bitmask_mode == null) {
            mbind_autotile_get_bitmask_mode = try api.createMethod("TileSet", "autotile_get_bitmask_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_bitmask_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn autotileGetIconCoordinate(self: *const Self, arg_id: i32) !godot.Vector2 {
        if (mbind_autotile_get_icon_coordinate == null) {
            mbind_autotile_get_icon_coordinate = try api.createMethod("TileSet", "autotile_get_icon_coordinate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_icon_coordinate, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn autotileGetLightOccluder(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !godot.OccluderPolygon2D {
        if (mbind_autotile_get_light_occluder == null) {
            mbind_autotile_get_light_occluder = try api.createMethod("TileSet", "autotile_get_light_occluder");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_light_occluder, base, cargs, result);
        return @ptrCast(*godot.OccluderPolygon2D, @alignCast(@alignOf(&godot.OccluderPolygon2D), result)).*;
    }

    pub fn autotileGetNavigationPolygon(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !godot.NavigationPolygon {
        if (mbind_autotile_get_navigation_polygon == null) {
            mbind_autotile_get_navigation_polygon = try api.createMethod("TileSet", "autotile_get_navigation_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_navigation_polygon, base, cargs, result);
        return @ptrCast(*godot.NavigationPolygon, @alignCast(@alignOf(&godot.NavigationPolygon), result)).*;
    }

    pub fn autotileGetSize(self: *const Self, arg_id: i32) !godot.Vector2 {
        if (mbind_autotile_get_size == null) {
            mbind_autotile_get_size = try api.createMethod("TileSet", "autotile_get_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn autotileGetSpacing(self: *const Self, arg_id: i32) !i32 {
        if (mbind_autotile_get_spacing == null) {
            mbind_autotile_get_spacing = try api.createMethod("TileSet", "autotile_get_spacing");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_spacing, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn autotileGetSubtilePriority(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !i32 {
        if (mbind_autotile_get_subtile_priority == null) {
            mbind_autotile_get_subtile_priority = try api.createMethod("TileSet", "autotile_get_subtile_priority");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_subtile_priority, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn autotileGetZIndex(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !i32 {
        if (mbind_autotile_get_z_index == null) {
            mbind_autotile_get_z_index = try api.createMethod("TileSet", "autotile_get_z_index");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_get_z_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn autotileSetBitmask(self: *const Self, arg_id: i32, arg_bitmask: *const godot.Vector2, arg_flag: i32) !void {
        if (mbind_autotile_set_bitmask == null) {
            mbind_autotile_set_bitmask = try api.createMethod("TileSet", "autotile_set_bitmask");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_bitmask),
            @ptrCast(*const anyopaque, *arg_flag),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_bitmask, base, cargs, result);
    }

    pub fn autotileSetBitmaskMode(self: *const Self, arg_id: i32, arg_mode: i32) !void {
        if (mbind_autotile_set_bitmask_mode == null) {
            mbind_autotile_set_bitmask_mode = try api.createMethod("TileSet", "autotile_set_bitmask_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_bitmask_mode, base, cargs, result);
    }

    pub fn autotileSetIconCoordinate(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2) !void {
        if (mbind_autotile_set_icon_coordinate == null) {
            mbind_autotile_set_icon_coordinate = try api.createMethod("TileSet", "autotile_set_icon_coordinate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_icon_coordinate, base, cargs, result);
    }

    pub fn autotileSetLightOccluder(self: *const Self, arg_id: i32, arg_light_occluder: *const godot.OccluderPolygon2D, arg_coord: *const godot.Vector2) !void {
        if (mbind_autotile_set_light_occluder == null) {
            mbind_autotile_set_light_occluder = try api.createMethod("TileSet", "autotile_set_light_occluder");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_light_occluder),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_light_occluder, base, cargs, result);
    }

    pub fn autotileSetNavigationPolygon(self: *const Self, arg_id: i32, arg_navigation_polygon: *const godot.NavigationPolygon, arg_coord: *const godot.Vector2) !void {
        if (mbind_autotile_set_navigation_polygon == null) {
            mbind_autotile_set_navigation_polygon = try api.createMethod("TileSet", "autotile_set_navigation_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_navigation_polygon),
            @ptrCast(*const anyopaque, arg_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_navigation_polygon, base, cargs, result);
    }

    pub fn autotileSetSize(self: *const Self, arg_id: i32, arg_size: *const godot.Vector2) !void {
        if (mbind_autotile_set_size == null) {
            mbind_autotile_set_size = try api.createMethod("TileSet", "autotile_set_size");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_size, base, cargs, result);
    }

    pub fn autotileSetSpacing(self: *const Self, arg_id: i32, arg_spacing: i32) !void {
        if (mbind_autotile_set_spacing == null) {
            mbind_autotile_set_spacing = try api.createMethod("TileSet", "autotile_set_spacing");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_spacing),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_spacing, base, cargs, result);
    }

    pub fn autotileSetSubtilePriority(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2, arg_priority: i32) !void {
        if (mbind_autotile_set_subtile_priority == null) {
            mbind_autotile_set_subtile_priority = try api.createMethod("TileSet", "autotile_set_subtile_priority");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_subtile_priority, base, cargs, result);
    }

    pub fn autotileSetZIndex(self: *const Self, arg_id: i32, arg_coord: *const godot.Vector2, arg_z_index: i32) !void {
        if (mbind_autotile_set_z_index == null) {
            mbind_autotile_set_z_index = try api.createMethod("TileSet", "autotile_set_z_index");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_coord),
            @ptrCast(*const anyopaque, *arg_z_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_autotile_set_z_index, base, cargs, result);
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("TileSet", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn createTile(self: *const Self, arg_id: i32) !void {
        if (mbind_create_tile == null) {
            mbind_create_tile = try api.createMethod("TileSet", "create_tile");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_create_tile, base, cargs, result);
    }

    pub fn findTileByName(self: *const Self, arg_name: *const godot.String) !i32 {
        if (mbind_find_tile_by_name == null) {
            mbind_find_tile_by_name = try api.createMethod("TileSet", "find_tile_by_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_tile_by_name, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLastUnusedTileId(self: *const Self) !i32 {
        if (mbind_get_last_unused_tile_id == null) {
            mbind_get_last_unused_tile_id = try api.createMethod("TileSet", "get_last_unused_tile_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_last_unused_tile_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTilesIds(self: *const Self) !godot.Array {
        if (mbind_get_tiles_ids == null) {
            mbind_get_tiles_ids = try api.createMethod("TileSet", "get_tiles_ids");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tiles_ids, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn removeTile(self: *const Self, arg_id: i32) !void {
        if (mbind_remove_tile == null) {
            mbind_remove_tile = try api.createMethod("TileSet", "remove_tile");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_tile, base, cargs, result);
    }

    pub fn tileAddShape(self: *const Self, arg_id: i32, arg_shape: *const godot.Shape2D, arg_shape_transform: *const godot.Transform2D, arg_one_way: bool, arg_autotile_coord: *const godot.Vector2) !void {
        if (mbind_tile_add_shape == null) {
            mbind_tile_add_shape = try api.createMethod("TileSet", "tile_add_shape");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_shape_transform),
            @ptrCast(*const anyopaque, *arg_one_way),
            @ptrCast(*const anyopaque, arg_autotile_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_add_shape, base, cargs, result);
    }

    pub fn tileGetLightOccluder(self: *const Self, arg_id: i32) !godot.OccluderPolygon2D {
        if (mbind_tile_get_light_occluder == null) {
            mbind_tile_get_light_occluder = try api.createMethod("TileSet", "tile_get_light_occluder");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_light_occluder, base, cargs, result);
        return @ptrCast(*godot.OccluderPolygon2D, @alignCast(@alignOf(&godot.OccluderPolygon2D), result)).*;
    }

    pub fn tileGetMaterial(self: *const Self, arg_id: i32) !godot.ShaderMaterial {
        if (mbind_tile_get_material == null) {
            mbind_tile_get_material = try api.createMethod("TileSet", "tile_get_material");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_material, base, cargs, result);
        return @ptrCast(*godot.ShaderMaterial, @alignCast(@alignOf(&godot.ShaderMaterial), result)).*;
    }

    pub fn tileGetModulate(self: *const Self, arg_id: i32) !godot.Color {
        if (mbind_tile_get_modulate == null) {
            mbind_tile_get_modulate = try api.createMethod("TileSet", "tile_get_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_modulate, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn tileGetName(self: *const Self, arg_id: i32) !godot.String {
        if (mbind_tile_get_name == null) {
            mbind_tile_get_name = try api.createMethod("TileSet", "tile_get_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn tileGetNavigationPolygon(self: *const Self, arg_id: i32) !godot.NavigationPolygon {
        if (mbind_tile_get_navigation_polygon == null) {
            mbind_tile_get_navigation_polygon = try api.createMethod("TileSet", "tile_get_navigation_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_navigation_polygon, base, cargs, result);
        return @ptrCast(*godot.NavigationPolygon, @alignCast(@alignOf(&godot.NavigationPolygon), result)).*;
    }

    pub fn tileGetNavigationPolygonOffset(self: *const Self, arg_id: i32) !godot.Vector2 {
        if (mbind_tile_get_navigation_polygon_offset == null) {
            mbind_tile_get_navigation_polygon_offset = try api.createMethod("TileSet", "tile_get_navigation_polygon_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_navigation_polygon_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn tileGetNormalMap(self: *const Self, arg_id: i32) !godot.Texture {
        if (mbind_tile_get_normal_map == null) {
            mbind_tile_get_normal_map = try api.createMethod("TileSet", "tile_get_normal_map");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_normal_map, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn tileGetOccluderOffset(self: *const Self, arg_id: i32) !godot.Vector2 {
        if (mbind_tile_get_occluder_offset == null) {
            mbind_tile_get_occluder_offset = try api.createMethod("TileSet", "tile_get_occluder_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_occluder_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn tileGetRegion(self: *const Self, arg_id: i32) !godot.Rect2 {
        if (mbind_tile_get_region == null) {
            mbind_tile_get_region = try api.createMethod("TileSet", "tile_get_region");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_region, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn tileGetShape(self: *const Self, arg_id: i32, arg_shape_id: i32) !godot.Shape2D {
        if (mbind_tile_get_shape == null) {
            mbind_tile_get_shape = try api.createMethod("TileSet", "tile_get_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape, base, cargs, result);
        return @ptrCast(*godot.Shape2D, @alignCast(@alignOf(&godot.Shape2D), result)).*;
    }

    pub fn tileGetShapeCount(self: *const Self, arg_id: i32) !i32 {
        if (mbind_tile_get_shape_count == null) {
            mbind_tile_get_shape_count = try api.createMethod("TileSet", "tile_get_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn tileGetShapeOffset(self: *const Self, arg_id: i32, arg_shape_id: i32) !godot.Vector2 {
        if (mbind_tile_get_shape_offset == null) {
            mbind_tile_get_shape_offset = try api.createMethod("TileSet", "tile_get_shape_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn tileGetShapeOneWay(self: *const Self, arg_id: i32, arg_shape_id: i32) !bool {
        if (mbind_tile_get_shape_one_way == null) {
            mbind_tile_get_shape_one_way = try api.createMethod("TileSet", "tile_get_shape_one_way");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape_one_way, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn tileGetShapeOneWayMargin(self: *const Self, arg_id: i32, arg_shape_id: i32) !f32 {
        if (mbind_tile_get_shape_one_way_margin == null) {
            mbind_tile_get_shape_one_way_margin = try api.createMethod("TileSet", "tile_get_shape_one_way_margin");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape_one_way_margin, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn tileGetShapeTransform(self: *const Self, arg_id: i32, arg_shape_id: i32) !godot.Transform2D {
        if (mbind_tile_get_shape_transform == null) {
            mbind_tile_get_shape_transform = try api.createMethod("TileSet", "tile_get_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shape_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn tileGetShapes(self: *const Self, arg_id: i32) !godot.Array {
        if (mbind_tile_get_shapes == null) {
            mbind_tile_get_shapes = try api.createMethod("TileSet", "tile_get_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_shapes, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn tileGetTexture(self: *const Self, arg_id: i32) !godot.Texture {
        if (mbind_tile_get_texture == null) {
            mbind_tile_get_texture = try api.createMethod("TileSet", "tile_get_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn tileGetTextureOffset(self: *const Self, arg_id: i32) !godot.Vector2 {
        if (mbind_tile_get_texture_offset == null) {
            mbind_tile_get_texture_offset = try api.createMethod("TileSet", "tile_get_texture_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_texture_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn tileGetTileMode(self: *const Self, arg_id: i32) !i32 {
        if (mbind_tile_get_tile_mode == null) {
            mbind_tile_get_tile_mode = try api.createMethod("TileSet", "tile_get_tile_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_tile_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn tileGetZIndex(self: *const Self, arg_id: i32) !i32 {
        if (mbind_tile_get_z_index == null) {
            mbind_tile_get_z_index = try api.createMethod("TileSet", "tile_get_z_index");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_get_z_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn tileSetLightOccluder(self: *const Self, arg_id: i32, arg_light_occluder: *const godot.OccluderPolygon2D) !void {
        if (mbind_tile_set_light_occluder == null) {
            mbind_tile_set_light_occluder = try api.createMethod("TileSet", "tile_set_light_occluder");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_light_occluder),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_light_occluder, base, cargs, result);
    }

    pub fn tileSetMaterial(self: *const Self, arg_id: i32, arg_material: *const godot.ShaderMaterial) !void {
        if (mbind_tile_set_material == null) {
            mbind_tile_set_material = try api.createMethod("TileSet", "tile_set_material");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_material),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_material, base, cargs, result);
    }

    pub fn tileSetModulate(self: *const Self, arg_id: i32, arg_color: *const godot.Color) !void {
        if (mbind_tile_set_modulate == null) {
            mbind_tile_set_modulate = try api.createMethod("TileSet", "tile_set_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_modulate, base, cargs, result);
    }

    pub fn tileSetName(self: *const Self, arg_id: i32, arg_name: *const godot.String) !void {
        if (mbind_tile_set_name == null) {
            mbind_tile_set_name = try api.createMethod("TileSet", "tile_set_name");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_name, base, cargs, result);
    }

    pub fn tileSetNavigationPolygon(self: *const Self, arg_id: i32, arg_navigation_polygon: *const godot.NavigationPolygon) !void {
        if (mbind_tile_set_navigation_polygon == null) {
            mbind_tile_set_navigation_polygon = try api.createMethod("TileSet", "tile_set_navigation_polygon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_navigation_polygon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_navigation_polygon, base, cargs, result);
    }

    pub fn tileSetNavigationPolygonOffset(self: *const Self, arg_id: i32, arg_navigation_polygon_offset: *const godot.Vector2) !void {
        if (mbind_tile_set_navigation_polygon_offset == null) {
            mbind_tile_set_navigation_polygon_offset = try api.createMethod("TileSet", "tile_set_navigation_polygon_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_navigation_polygon_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_navigation_polygon_offset, base, cargs, result);
    }

    pub fn tileSetNormalMap(self: *const Self, arg_id: i32, arg_normal_map: *const godot.Texture) !void {
        if (mbind_tile_set_normal_map == null) {
            mbind_tile_set_normal_map = try api.createMethod("TileSet", "tile_set_normal_map");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_normal_map),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_normal_map, base, cargs, result);
    }

    pub fn tileSetOccluderOffset(self: *const Self, arg_id: i32, arg_occluder_offset: *const godot.Vector2) !void {
        if (mbind_tile_set_occluder_offset == null) {
            mbind_tile_set_occluder_offset = try api.createMethod("TileSet", "tile_set_occluder_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_occluder_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_occluder_offset, base, cargs, result);
    }

    pub fn tileSetRegion(self: *const Self, arg_id: i32, arg_region: *const godot.Rect2) !void {
        if (mbind_tile_set_region == null) {
            mbind_tile_set_region = try api.createMethod("TileSet", "tile_set_region");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_region),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_region, base, cargs, result);
    }

    pub fn tileSetShape(self: *const Self, arg_id: i32, arg_shape_id: i32, arg_shape: *const godot.Shape2D) !void {
        if (mbind_tile_set_shape == null) {
            mbind_tile_set_shape = try api.createMethod("TileSet", "tile_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shape, base, cargs, result);
    }

    pub fn tileSetShapeOffset(self: *const Self, arg_id: i32, arg_shape_id: i32, arg_shape_offset: *const godot.Vector2) !void {
        if (mbind_tile_set_shape_offset == null) {
            mbind_tile_set_shape_offset = try api.createMethod("TileSet", "tile_set_shape_offset");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
            @ptrCast(*const anyopaque, arg_shape_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shape_offset, base, cargs, result);
    }

    pub fn tileSetShapeOneWay(self: *const Self, arg_id: i32, arg_shape_id: i32, arg_one_way: bool) !void {
        if (mbind_tile_set_shape_one_way == null) {
            mbind_tile_set_shape_one_way = try api.createMethod("TileSet", "tile_set_shape_one_way");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
            @ptrCast(*const anyopaque, *arg_one_way),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shape_one_way, base, cargs, result);
    }

    pub fn tileSetShapeOneWayMargin(self: *const Self, arg_id: i32, arg_shape_id: i32, arg_one_way: f32) !void {
        if (mbind_tile_set_shape_one_way_margin == null) {
            mbind_tile_set_shape_one_way_margin = try api.createMethod("TileSet", "tile_set_shape_one_way_margin");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
            @ptrCast(*const anyopaque, *arg_one_way),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shape_one_way_margin, base, cargs, result);
    }

    pub fn tileSetShapeTransform(self: *const Self, arg_id: i32, arg_shape_id: i32, arg_shape_transform: *const godot.Transform2D) !void {
        if (mbind_tile_set_shape_transform == null) {
            mbind_tile_set_shape_transform = try api.createMethod("TileSet", "tile_set_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_shape_id),
            @ptrCast(*const anyopaque, arg_shape_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shape_transform, base, cargs, result);
    }

    pub fn tileSetShapes(self: *const Self, arg_id: i32, arg_shapes: *const godot.Array) !void {
        if (mbind_tile_set_shapes == null) {
            mbind_tile_set_shapes = try api.createMethod("TileSet", "tile_set_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_shapes),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_shapes, base, cargs, result);
    }

    pub fn tileSetTexture(self: *const Self, arg_id: i32, arg_texture: *const godot.Texture) !void {
        if (mbind_tile_set_texture == null) {
            mbind_tile_set_texture = try api.createMethod("TileSet", "tile_set_texture");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_texture, base, cargs, result);
    }

    pub fn tileSetTextureOffset(self: *const Self, arg_id: i32, arg_texture_offset: *const godot.Vector2) !void {
        if (mbind_tile_set_texture_offset == null) {
            mbind_tile_set_texture_offset = try api.createMethod("TileSet", "tile_set_texture_offset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, arg_texture_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_texture_offset, base, cargs, result);
    }

    pub fn tileSetTileMode(self: *const Self, arg_id: i32, arg_tilemode: i32) !void {
        if (mbind_tile_set_tile_mode == null) {
            mbind_tile_set_tile_mode = try api.createMethod("TileSet", "tile_set_tile_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_tilemode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_tile_mode, base, cargs, result);
    }

    pub fn tileSetZIndex(self: *const Self, arg_id: i32, arg_z_index: i32) !void {
        if (mbind_tile_set_z_index == null) {
            mbind_tile_set_z_index = try api.createMethod("TileSet", "tile_set_z_index");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_z_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tile_set_z_index, base, cargs, result);
    }
};