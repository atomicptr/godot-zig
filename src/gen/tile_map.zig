// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node2D = @import("node_2d.zig").Node2D;

// method bindings
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_fix_invalid_tiles: ?*c_api.godot_method_bind = null;
var mbind_get_cell: ?*c_api.godot_method_bind = null;
var mbind_get_cell_autotile_coord: ?*c_api.godot_method_bind = null;
var mbind_get_cell_size: ?*c_api.godot_method_bind = null;
var mbind_get_cellv: ?*c_api.godot_method_bind = null;
var mbind_get_clip_uv: ?*c_api.godot_method_bind = null;
var mbind_get_collision_bounce: ?*c_api.godot_method_bind = null;
var mbind_get_collision_friction: ?*c_api.godot_method_bind = null;
var mbind_get_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_get_collision_layer_bit: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_get_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_get_collision_use_kinematic: ?*c_api.godot_method_bind = null;
var mbind_get_collision_use_parent: ?*c_api.godot_method_bind = null;
var mbind_get_custom_transform: ?*c_api.godot_method_bind = null;
var mbind_get_half_offset: ?*c_api.godot_method_bind = null;
var mbind_get_mode: ?*c_api.godot_method_bind = null;
var mbind_get_occluder_light_mask: ?*c_api.godot_method_bind = null;
var mbind_get_quadrant_size: ?*c_api.godot_method_bind = null;
var mbind_get_tile_origin: ?*c_api.godot_method_bind = null;
var mbind_get_tileset: ?*c_api.godot_method_bind = null;
var mbind_get_used_cells: ?*c_api.godot_method_bind = null;
var mbind_get_used_cells_by_id: ?*c_api.godot_method_bind = null;
var mbind_get_used_rect: ?*c_api.godot_method_bind = null;
var mbind_is_cell_transposed: ?*c_api.godot_method_bind = null;
var mbind_is_cell_x_flipped: ?*c_api.godot_method_bind = null;
var mbind_is_cell_y_flipped: ?*c_api.godot_method_bind = null;
var mbind_is_centered_textures_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_compatibility_mode_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_show_collision_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_y_sort_mode_enabled: ?*c_api.godot_method_bind = null;
var mbind_map_to_world: ?*c_api.godot_method_bind = null;
var mbind_set_cell: ?*c_api.godot_method_bind = null;
var mbind_set_cell_size: ?*c_api.godot_method_bind = null;
var mbind_set_cellv: ?*c_api.godot_method_bind = null;
var mbind_set_centered_textures: ?*c_api.godot_method_bind = null;
var mbind_set_clip_uv: ?*c_api.godot_method_bind = null;
var mbind_set_collision_bounce: ?*c_api.godot_method_bind = null;
var mbind_set_collision_friction: ?*c_api.godot_method_bind = null;
var mbind_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_set_collision_layer_bit: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_set_collision_mask_bit: ?*c_api.godot_method_bind = null;
var mbind_set_collision_use_kinematic: ?*c_api.godot_method_bind = null;
var mbind_set_collision_use_parent: ?*c_api.godot_method_bind = null;
var mbind_set_compatibility_mode: ?*c_api.godot_method_bind = null;
var mbind_set_custom_transform: ?*c_api.godot_method_bind = null;
var mbind_set_half_offset: ?*c_api.godot_method_bind = null;
var mbind_set_mode: ?*c_api.godot_method_bind = null;
var mbind_set_occluder_light_mask: ?*c_api.godot_method_bind = null;
var mbind_set_quadrant_size: ?*c_api.godot_method_bind = null;
var mbind_set_show_collision: ?*c_api.godot_method_bind = null;
var mbind_set_tile_origin: ?*c_api.godot_method_bind = null;
var mbind_set_tileset: ?*c_api.godot_method_bind = null;
var mbind_set_y_sort_mode: ?*c_api.godot_method_bind = null;
var mbind_update_bitmask_area: ?*c_api.godot_method_bind = null;
var mbind_update_bitmask_region: ?*c_api.godot_method_bind = null;
var mbind_update_dirty_quadrants: ?*c_api.godot_method_bind = null;
var mbind_world_to_map: ?*c_api.godot_method_bind = null;
var mbind_tile_map_constructor: ?fn () ?*c_api.godot_object = null;

pub const TileMap = struct {
    const Self = @This();
    const BaseClass = Node2D;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_tile_map_constructor == null) {
            mbind_tile_map_constructor = try api.createConstructor("TileMap");
        }
        return api.createObject(Self, mbind_tile_map_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("TileMap", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn fixInvalidTiles(self: *const Self) !void {
        if (mbind_fix_invalid_tiles == null) {
            mbind_fix_invalid_tiles = try api.createMethod("TileMap", "fix_invalid_tiles");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_fix_invalid_tiles, base, cargs, result);
    }

    pub fn getCell(self: *const Self, arg_x: i32, arg_y: i32) !i32 {
        if (mbind_get_cell == null) {
            mbind_get_cell = try api.createMethod("TileMap", "get_cell");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCellAutotileCoord(self: *const Self, arg_x: i32, arg_y: i32) !godot.Vector2 {
        if (mbind_get_cell_autotile_coord == null) {
            mbind_get_cell_autotile_coord = try api.createMethod("TileMap", "get_cell_autotile_coord");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_autotile_coord, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getCellSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_cell_size == null) {
            mbind_get_cell_size = try api.createMethod("TileMap", "get_cell_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cell_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getCellv(self: *const Self, arg_position: *const godot.Vector2) !i32 {
        if (mbind_get_cellv == null) {
            mbind_get_cellv = try api.createMethod("TileMap", "get_cellv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cellv, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getClipUv(self: *const Self) !bool {
        if (mbind_get_clip_uv == null) {
            mbind_get_clip_uv = try api.createMethod("TileMap", "get_clip_uv");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_clip_uv, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionBounce(self: *const Self) !f32 {
        if (mbind_get_collision_bounce == null) {
            mbind_get_collision_bounce = try api.createMethod("TileMap", "get_collision_bounce");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_bounce, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollisionFriction(self: *const Self) !f32 {
        if (mbind_get_collision_friction == null) {
            mbind_get_collision_friction = try api.createMethod("TileMap", "get_collision_friction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_friction, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollisionLayer(self: *const Self) !i32 {
        if (mbind_get_collision_layer == null) {
            mbind_get_collision_layer = try api.createMethod("TileMap", "get_collision_layer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_layer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCollisionLayerBit(self: *const Self, arg_bit: i32) !bool {
        if (mbind_get_collision_layer_bit == null) {
            mbind_get_collision_layer_bit = try api.createMethod("TileMap", "get_collision_layer_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_layer_bit, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionMask(self: *const Self) !i32 {
        if (mbind_get_collision_mask == null) {
            mbind_get_collision_mask = try api.createMethod("TileMap", "get_collision_mask");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCollisionMaskBit(self: *const Self, arg_bit: i32) !bool {
        if (mbind_get_collision_mask_bit == null) {
            mbind_get_collision_mask_bit = try api.createMethod("TileMap", "get_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_mask_bit, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionUseKinematic(self: *const Self) !bool {
        if (mbind_get_collision_use_kinematic == null) {
            mbind_get_collision_use_kinematic = try api.createMethod("TileMap", "get_collision_use_kinematic");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_use_kinematic, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCollisionUseParent(self: *const Self) !bool {
        if (mbind_get_collision_use_parent == null) {
            mbind_get_collision_use_parent = try api.createMethod("TileMap", "get_collision_use_parent");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_use_parent, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCustomTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_custom_transform == null) {
            mbind_get_custom_transform = try api.createMethod("TileMap", "get_custom_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_custom_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getHalfOffset(self: *const Self) !i32 {
        if (mbind_get_half_offset == null) {
            mbind_get_half_offset = try api.createMethod("TileMap", "get_half_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_half_offset, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMode(self: *const Self) !i32 {
        if (mbind_get_mode == null) {
            mbind_get_mode = try api.createMethod("TileMap", "get_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getOccluderLightMask(self: *const Self) !i32 {
        if (mbind_get_occluder_light_mask == null) {
            mbind_get_occluder_light_mask = try api.createMethod("TileMap", "get_occluder_light_mask");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_occluder_light_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getQuadrantSize(self: *const Self) !i32 {
        if (mbind_get_quadrant_size == null) {
            mbind_get_quadrant_size = try api.createMethod("TileMap", "get_quadrant_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_quadrant_size, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTileOrigin(self: *const Self) !i32 {
        if (mbind_get_tile_origin == null) {
            mbind_get_tile_origin = try api.createMethod("TileMap", "get_tile_origin");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tile_origin, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTileset(self: *const Self) !godot.TileSet {
        if (mbind_get_tileset == null) {
            mbind_get_tileset = try api.createMethod("TileMap", "get_tileset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tileset, base, cargs, result);
        return @ptrCast(*godot.TileSet, @alignCast(@alignOf(&godot.TileSet), result)).*;
    }

    pub fn getUsedCells(self: *const Self) !godot.Array {
        if (mbind_get_used_cells == null) {
            mbind_get_used_cells = try api.createMethod("TileMap", "get_used_cells");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_used_cells, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getUsedCellsById(self: *const Self, arg_id: i32) !godot.Array {
        if (mbind_get_used_cells_by_id == null) {
            mbind_get_used_cells_by_id = try api.createMethod("TileMap", "get_used_cells_by_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_used_cells_by_id, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getUsedRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_used_rect == null) {
            mbind_get_used_rect = try api.createMethod("TileMap", "get_used_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_used_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn isCellTransposed(self: *const Self, arg_x: i32, arg_y: i32) !bool {
        if (mbind_is_cell_transposed == null) {
            mbind_is_cell_transposed = try api.createMethod("TileMap", "is_cell_transposed");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_cell_transposed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isCellXFlipped(self: *const Self, arg_x: i32, arg_y: i32) !bool {
        if (mbind_is_cell_x_flipped == null) {
            mbind_is_cell_x_flipped = try api.createMethod("TileMap", "is_cell_x_flipped");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_cell_x_flipped, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isCellYFlipped(self: *const Self, arg_x: i32, arg_y: i32) !bool {
        if (mbind_is_cell_y_flipped == null) {
            mbind_is_cell_y_flipped = try api.createMethod("TileMap", "is_cell_y_flipped");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_cell_y_flipped, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isCenteredTexturesEnabled(self: *const Self) !bool {
        if (mbind_is_centered_textures_enabled == null) {
            mbind_is_centered_textures_enabled = try api.createMethod("TileMap", "is_centered_textures_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_centered_textures_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isCompatibilityModeEnabled(self: *const Self) !bool {
        if (mbind_is_compatibility_mode_enabled == null) {
            mbind_is_compatibility_mode_enabled = try api.createMethod("TileMap", "is_compatibility_mode_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_compatibility_mode_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isShowCollisionEnabled(self: *const Self) !bool {
        if (mbind_is_show_collision_enabled == null) {
            mbind_is_show_collision_enabled = try api.createMethod("TileMap", "is_show_collision_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_show_collision_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isYSortModeEnabled(self: *const Self) !bool {
        if (mbind_is_y_sort_mode_enabled == null) {
            mbind_is_y_sort_mode_enabled = try api.createMethod("TileMap", "is_y_sort_mode_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_y_sort_mode_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn mapToWorld(self: *const Self, arg_map_position: *const godot.Vector2, arg_ignore_half_ofs: bool) !godot.Vector2 {
        if (mbind_map_to_world == null) {
            mbind_map_to_world = try api.createMethod("TileMap", "map_to_world");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_map_position),
            @ptrCast(*const anyopaque, *arg_ignore_half_ofs),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_map_to_world, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn setCell(self: *const Self, arg_x: i32, arg_y: i32, arg_tile: i32, arg_flip_x: bool, arg_flip_y: bool, arg_transpose: bool, arg_autotile_coord: *const godot.Vector2) !void {
        if (mbind_set_cell == null) {
            mbind_set_cell = try api.createMethod("TileMap", "set_cell");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, *arg_tile),
            @ptrCast(*const anyopaque, *arg_flip_x),
            @ptrCast(*const anyopaque, *arg_flip_y),
            @ptrCast(*const anyopaque, *arg_transpose),
            @ptrCast(*const anyopaque, arg_autotile_coord),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell, base, cargs, result);
    }

    pub fn setCellSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_cell_size == null) {
            mbind_set_cell_size = try api.createMethod("TileMap", "set_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cell_size, base, cargs, result);
    }

    pub fn setCellv(self: *const Self, arg_position: *const godot.Vector2, arg_tile: i32, arg_flip_x: bool, arg_flip_y: bool, arg_transpose: bool) !void {
        if (mbind_set_cellv == null) {
            mbind_set_cellv = try api.createMethod("TileMap", "set_cellv");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_tile),
            @ptrCast(*const anyopaque, *arg_flip_x),
            @ptrCast(*const anyopaque, *arg_flip_y),
            @ptrCast(*const anyopaque, *arg_transpose),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cellv, base, cargs, result);
    }

    pub fn setCenteredTextures(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_centered_textures == null) {
            mbind_set_centered_textures = try api.createMethod("TileMap", "set_centered_textures");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_centered_textures, base, cargs, result);
    }

    pub fn setClipUv(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_clip_uv == null) {
            mbind_set_clip_uv = try api.createMethod("TileMap", "set_clip_uv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clip_uv, base, cargs, result);
    }

    pub fn setCollisionBounce(self: *const Self, arg_value: f32) !void {
        if (mbind_set_collision_bounce == null) {
            mbind_set_collision_bounce = try api.createMethod("TileMap", "set_collision_bounce");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_bounce, base, cargs, result);
    }

    pub fn setCollisionFriction(self: *const Self, arg_value: f32) !void {
        if (mbind_set_collision_friction == null) {
            mbind_set_collision_friction = try api.createMethod("TileMap", "set_collision_friction");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_friction, base, cargs, result);
    }

    pub fn setCollisionLayer(self: *const Self, arg_layer: i32) !void {
        if (mbind_set_collision_layer == null) {
            mbind_set_collision_layer = try api.createMethod("TileMap", "set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_layer, base, cargs, result);
    }

    pub fn setCollisionLayerBit(self: *const Self, arg_bit: i32, arg_value: bool) !void {
        if (mbind_set_collision_layer_bit == null) {
            mbind_set_collision_layer_bit = try api.createMethod("TileMap", "set_collision_layer_bit");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_layer_bit, base, cargs, result);
    }

    pub fn setCollisionMask(self: *const Self, arg_mask: i32) !void {
        if (mbind_set_collision_mask == null) {
            mbind_set_collision_mask = try api.createMethod("TileMap", "set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask, base, cargs, result);
    }

    pub fn setCollisionMaskBit(self: *const Self, arg_bit: i32, arg_value: bool) !void {
        if (mbind_set_collision_mask_bit == null) {
            mbind_set_collision_mask_bit = try api.createMethod("TileMap", "set_collision_mask_bit");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bit),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_mask_bit, base, cargs, result);
    }

    pub fn setCollisionUseKinematic(self: *const Self, arg_use_kinematic: bool) !void {
        if (mbind_set_collision_use_kinematic == null) {
            mbind_set_collision_use_kinematic = try api.createMethod("TileMap", "set_collision_use_kinematic");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_kinematic),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_use_kinematic, base, cargs, result);
    }

    pub fn setCollisionUseParent(self: *const Self, arg_use_parent: bool) !void {
        if (mbind_set_collision_use_parent == null) {
            mbind_set_collision_use_parent = try api.createMethod("TileMap", "set_collision_use_parent");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_parent),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_use_parent, base, cargs, result);
    }

    pub fn setCompatibilityMode(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_compatibility_mode == null) {
            mbind_set_compatibility_mode = try api.createMethod("TileMap", "set_compatibility_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_compatibility_mode, base, cargs, result);
    }

    pub fn setCustomTransform(self: *const Self, arg_custom_transform: *const godot.Transform2D) !void {
        if (mbind_set_custom_transform == null) {
            mbind_set_custom_transform = try api.createMethod("TileMap", "set_custom_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_custom_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_custom_transform, base, cargs, result);
    }

    pub fn setHalfOffset(self: *const Self, arg_half_offset: i32) !void {
        if (mbind_set_half_offset == null) {
            mbind_set_half_offset = try api.createMethod("TileMap", "set_half_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_half_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_half_offset, base, cargs, result);
    }

    pub fn setMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_mode == null) {
            mbind_set_mode = try api.createMethod("TileMap", "set_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_mode, base, cargs, result);
    }

    pub fn setOccluderLightMask(self: *const Self, arg_mask: i32) !void {
        if (mbind_set_occluder_light_mask == null) {
            mbind_set_occluder_light_mask = try api.createMethod("TileMap", "set_occluder_light_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_occluder_light_mask, base, cargs, result);
    }

    pub fn setQuadrantSize(self: *const Self, arg_size: i32) !void {
        if (mbind_set_quadrant_size == null) {
            mbind_set_quadrant_size = try api.createMethod("TileMap", "set_quadrant_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_quadrant_size, base, cargs, result);
    }

    pub fn setShowCollision(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_show_collision == null) {
            mbind_set_show_collision = try api.createMethod("TileMap", "set_show_collision");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_show_collision, base, cargs, result);
    }

    pub fn setTileOrigin(self: *const Self, arg_origin: i32) !void {
        if (mbind_set_tile_origin == null) {
            mbind_set_tile_origin = try api.createMethod("TileMap", "set_tile_origin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_origin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tile_origin, base, cargs, result);
    }

    pub fn setTileset(self: *const Self, arg_tileset: *const godot.TileSet) !void {
        if (mbind_set_tileset == null) {
            mbind_set_tileset = try api.createMethod("TileMap", "set_tileset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tileset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tileset, base, cargs, result);
    }

    pub fn setYSortMode(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_y_sort_mode == null) {
            mbind_set_y_sort_mode = try api.createMethod("TileMap", "set_y_sort_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_y_sort_mode, base, cargs, result);
    }

    pub fn updateBitmaskArea(self: *const Self, arg_position: *const godot.Vector2) !void {
        if (mbind_update_bitmask_area == null) {
            mbind_update_bitmask_area = try api.createMethod("TileMap", "update_bitmask_area");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_bitmask_area, base, cargs, result);
    }

    pub fn updateBitmaskRegion(self: *const Self, arg_start: *const godot.Vector2, arg_end: *const godot.Vector2) !void {
        if (mbind_update_bitmask_region == null) {
            mbind_update_bitmask_region = try api.createMethod("TileMap", "update_bitmask_region");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_start),
            @ptrCast(*const anyopaque, arg_end),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_bitmask_region, base, cargs, result);
    }

    pub fn updateDirtyQuadrants(self: *const Self) !void {
        if (mbind_update_dirty_quadrants == null) {
            mbind_update_dirty_quadrants = try api.createMethod("TileMap", "update_dirty_quadrants");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_dirty_quadrants, base, cargs, result);
    }

    pub fn worldToMap(self: *const Self, arg_world_position: *const godot.Vector2) !godot.Vector2 {
        if (mbind_world_to_map == null) {
            mbind_world_to_map = try api.createMethod("TileMap", "world_to_map");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_world_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_world_to_map, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }
};