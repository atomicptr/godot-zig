// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_bake: ?*c_api.godot_method_bind = null;
var mbind_get_bake_quality: ?*c_api.godot_method_bind = null;
var mbind_get_bias: ?*c_api.godot_method_bind = null;
var mbind_get_bounce_indirect_energy: ?*c_api.godot_method_bind = null;
var mbind_get_bounces: ?*c_api.godot_method_bind = null;
var mbind_get_capture_cell_size: ?*c_api.godot_method_bind = null;
var mbind_get_capture_enabled: ?*c_api.godot_method_bind = null;
var mbind_get_capture_propagation: ?*c_api.godot_method_bind = null;
var mbind_get_capture_quality: ?*c_api.godot_method_bind = null;
var mbind_get_default_texels_per_unit: ?*c_api.godot_method_bind = null;
var mbind_get_environment_custom_color: ?*c_api.godot_method_bind = null;
var mbind_get_environment_custom_energy: ?*c_api.godot_method_bind = null;
var mbind_get_environment_custom_sky: ?*c_api.godot_method_bind = null;
var mbind_get_environment_custom_sky_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_get_environment_min_light: ?*c_api.godot_method_bind = null;
var mbind_get_environment_mode: ?*c_api.godot_method_bind = null;
var mbind_get_extents: ?*c_api.godot_method_bind = null;
var mbind_get_image_path: ?*c_api.godot_method_bind = null;
var mbind_get_light_data: ?*c_api.godot_method_bind = null;
var mbind_get_max_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_is_generate_atlas_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_using_color: ?*c_api.godot_method_bind = null;
var mbind_is_using_denoiser: ?*c_api.godot_method_bind = null;
var mbind_is_using_hdr: ?*c_api.godot_method_bind = null;
var mbind_set_bake_quality: ?*c_api.godot_method_bind = null;
var mbind_set_bias: ?*c_api.godot_method_bind = null;
var mbind_set_bounce_indirect_energy: ?*c_api.godot_method_bind = null;
var mbind_set_bounces: ?*c_api.godot_method_bind = null;
var mbind_set_capture_cell_size: ?*c_api.godot_method_bind = null;
var mbind_set_capture_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_capture_propagation: ?*c_api.godot_method_bind = null;
var mbind_set_capture_quality: ?*c_api.godot_method_bind = null;
var mbind_set_default_texels_per_unit: ?*c_api.godot_method_bind = null;
var mbind_set_environment_custom_color: ?*c_api.godot_method_bind = null;
var mbind_set_environment_custom_energy: ?*c_api.godot_method_bind = null;
var mbind_set_environment_custom_sky: ?*c_api.godot_method_bind = null;
var mbind_set_environment_custom_sky_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_set_environment_min_light: ?*c_api.godot_method_bind = null;
var mbind_set_environment_mode: ?*c_api.godot_method_bind = null;
var mbind_set_extents: ?*c_api.godot_method_bind = null;
var mbind_set_generate_atlas: ?*c_api.godot_method_bind = null;
var mbind_set_image_path: ?*c_api.godot_method_bind = null;
var mbind_set_light_data: ?*c_api.godot_method_bind = null;
var mbind_set_max_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_set_use_color: ?*c_api.godot_method_bind = null;
var mbind_set_use_denoiser: ?*c_api.godot_method_bind = null;
var mbind_set_use_hdr: ?*c_api.godot_method_bind = null;
var mbind_baked_lightmap_constructor: ?fn () ?*c_api.godot_object = null;

pub const BakedLightmap = struct {
    const Self = @This();
    pub const BaseClass = godot.VisualInstance;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_baked_lightmap_constructor == null) {
            mbind_baked_lightmap_constructor = try api.createConstructor("BakedLightmap");
        }
        return api.createObject(Self, mbind_baked_lightmap_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn bake(self: *const Self, arg_from_node: *const godot.Node, arg_data_save_path: *const godot.String) !i32 {
        if (mbind_bake == null) {
            mbind_bake = try api.createMethod("BakedLightmap", "bake");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from_node),
            @ptrCast(*const anyopaque, arg_data_save_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_bake, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBakeQuality(self: *const Self) !i32 {
        if (mbind_get_bake_quality == null) {
            mbind_get_bake_quality = try api.createMethod("BakedLightmap", "get_bake_quality");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bake_quality, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBias(self: *const Self) !f32 {
        if (mbind_get_bias == null) {
            mbind_get_bias = try api.createMethod("BakedLightmap", "get_bias");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bias, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getBounceIndirectEnergy(self: *const Self) !f32 {
        if (mbind_get_bounce_indirect_energy == null) {
            mbind_get_bounce_indirect_energy = try api.createMethod("BakedLightmap", "get_bounce_indirect_energy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bounce_indirect_energy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getBounces(self: *const Self) !i32 {
        if (mbind_get_bounces == null) {
            mbind_get_bounces = try api.createMethod("BakedLightmap", "get_bounces");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_bounces, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCaptureCellSize(self: *const Self) !f32 {
        if (mbind_get_capture_cell_size == null) {
            mbind_get_capture_cell_size = try api.createMethod("BakedLightmap", "get_capture_cell_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_capture_cell_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCaptureEnabled(self: *const Self) !bool {
        if (mbind_get_capture_enabled == null) {
            mbind_get_capture_enabled = try api.createMethod("BakedLightmap", "get_capture_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_capture_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCapturePropagation(self: *const Self) !f32 {
        if (mbind_get_capture_propagation == null) {
            mbind_get_capture_propagation = try api.createMethod("BakedLightmap", "get_capture_propagation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_capture_propagation, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCaptureQuality(self: *const Self) !i32 {
        if (mbind_get_capture_quality == null) {
            mbind_get_capture_quality = try api.createMethod("BakedLightmap", "get_capture_quality");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_capture_quality, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDefaultTexelsPerUnit(self: *const Self) !f32 {
        if (mbind_get_default_texels_per_unit == null) {
            mbind_get_default_texels_per_unit = try api.createMethod("BakedLightmap", "get_default_texels_per_unit");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_default_texels_per_unit, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEnvironmentCustomColor(self: *const Self) !godot.Color {
        if (mbind_get_environment_custom_color == null) {
            mbind_get_environment_custom_color = try api.createMethod("BakedLightmap", "get_environment_custom_color");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_custom_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getEnvironmentCustomEnergy(self: *const Self) !f32 {
        if (mbind_get_environment_custom_energy == null) {
            mbind_get_environment_custom_energy = try api.createMethod("BakedLightmap", "get_environment_custom_energy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_custom_energy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEnvironmentCustomSky(self: *const Self) !godot.Sky {
        if (mbind_get_environment_custom_sky == null) {
            mbind_get_environment_custom_sky = try api.createMethod("BakedLightmap", "get_environment_custom_sky");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_custom_sky, base, cargs, result);
        return @ptrCast(*godot.Sky, @alignCast(@alignOf(&godot.Sky), result)).*;
    }

    pub fn getEnvironmentCustomSkyRotationDegrees(self: *const Self) !godot.Vector3 {
        if (mbind_get_environment_custom_sky_rotation_degrees == null) {
            mbind_get_environment_custom_sky_rotation_degrees = try api.createMethod("BakedLightmap", "get_environment_custom_sky_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_custom_sky_rotation_degrees, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getEnvironmentMinLight(self: *const Self) !godot.Color {
        if (mbind_get_environment_min_light == null) {
            mbind_get_environment_min_light = try api.createMethod("BakedLightmap", "get_environment_min_light");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_min_light, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getEnvironmentMode(self: *const Self) !i32 {
        if (mbind_get_environment_mode == null) {
            mbind_get_environment_mode = try api.createMethod("BakedLightmap", "get_environment_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getExtents(self: *const Self) !godot.Vector3 {
        if (mbind_get_extents == null) {
            mbind_get_extents = try api.createMethod("BakedLightmap", "get_extents");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_extents, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getImagePath(self: *const Self) !godot.String {
        if (mbind_get_image_path == null) {
            mbind_get_image_path = try api.createMethod("BakedLightmap", "get_image_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_image_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLightData(self: *const Self) !godot.BakedLightmapData {
        if (mbind_get_light_data == null) {
            mbind_get_light_data = try api.createMethod("BakedLightmap", "get_light_data");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_light_data, base, cargs, result);
        return @ptrCast(*godot.BakedLightmapData, @alignCast(@alignOf(&godot.BakedLightmapData), result)).*;
    }

    pub fn getMaxAtlasSize(self: *const Self) !i32 {
        if (mbind_get_max_atlas_size == null) {
            mbind_get_max_atlas_size = try api.createMethod("BakedLightmap", "get_max_atlas_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_max_atlas_size, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn isGenerateAtlasEnabled(self: *const Self) !bool {
        if (mbind_is_generate_atlas_enabled == null) {
            mbind_is_generate_atlas_enabled = try api.createMethod("BakedLightmap", "is_generate_atlas_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_generate_atlas_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingColor(self: *const Self) !bool {
        if (mbind_is_using_color == null) {
            mbind_is_using_color = try api.createMethod("BakedLightmap", "is_using_color");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_color, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingDenoiser(self: *const Self) !bool {
        if (mbind_is_using_denoiser == null) {
            mbind_is_using_denoiser = try api.createMethod("BakedLightmap", "is_using_denoiser");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_denoiser, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingHdr(self: *const Self) !bool {
        if (mbind_is_using_hdr == null) {
            mbind_is_using_hdr = try api.createMethod("BakedLightmap", "is_using_hdr");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_hdr, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setBakeQuality(self: *const Self, arg_quality: i32) !void {
        if (mbind_set_bake_quality == null) {
            mbind_set_bake_quality = try api.createMethod("BakedLightmap", "set_bake_quality");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bake_quality, base, cargs, result);
    }

    pub fn setBias(self: *const Self, arg_bias: f32) !void {
        if (mbind_set_bias == null) {
            mbind_set_bias = try api.createMethod("BakedLightmap", "set_bias");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bias),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bias, base, cargs, result);
    }

    pub fn setBounceIndirectEnergy(self: *const Self, arg_bounce_indirect_energy: f32) !void {
        if (mbind_set_bounce_indirect_energy == null) {
            mbind_set_bounce_indirect_energy = try api.createMethod("BakedLightmap", "set_bounce_indirect_energy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bounce_indirect_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bounce_indirect_energy, base, cargs, result);
    }

    pub fn setBounces(self: *const Self, arg_bounces: i32) !void {
        if (mbind_set_bounces == null) {
            mbind_set_bounces = try api.createMethod("BakedLightmap", "set_bounces");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bounces),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bounces, base, cargs, result);
    }

    pub fn setCaptureCellSize(self: *const Self, arg_capture_cell_size: f32) !void {
        if (mbind_set_capture_cell_size == null) {
            mbind_set_capture_cell_size = try api.createMethod("BakedLightmap", "set_capture_cell_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_capture_cell_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_capture_cell_size, base, cargs, result);
    }

    pub fn setCaptureEnabled(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_capture_enabled == null) {
            mbind_set_capture_enabled = try api.createMethod("BakedLightmap", "set_capture_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_capture_enabled, base, cargs, result);
    }

    pub fn setCapturePropagation(self: *const Self, arg_propagation: f32) !void {
        if (mbind_set_capture_propagation == null) {
            mbind_set_capture_propagation = try api.createMethod("BakedLightmap", "set_capture_propagation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_propagation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_capture_propagation, base, cargs, result);
    }

    pub fn setCaptureQuality(self: *const Self, arg_capture_quality: i32) !void {
        if (mbind_set_capture_quality == null) {
            mbind_set_capture_quality = try api.createMethod("BakedLightmap", "set_capture_quality");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_capture_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_capture_quality, base, cargs, result);
    }

    pub fn setDefaultTexelsPerUnit(self: *const Self, arg_texels: f32) !void {
        if (mbind_set_default_texels_per_unit == null) {
            mbind_set_default_texels_per_unit = try api.createMethod("BakedLightmap", "set_default_texels_per_unit");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_texels),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_default_texels_per_unit, base, cargs, result);
    }

    pub fn setEnvironmentCustomColor(self: *const Self, arg_color: *const godot.Color) !void {
        if (mbind_set_environment_custom_color == null) {
            mbind_set_environment_custom_color = try api.createMethod("BakedLightmap", "set_environment_custom_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_custom_color, base, cargs, result);
    }

    pub fn setEnvironmentCustomEnergy(self: *const Self, arg_energy: f32) !void {
        if (mbind_set_environment_custom_energy == null) {
            mbind_set_environment_custom_energy = try api.createMethod("BakedLightmap", "set_environment_custom_energy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_custom_energy, base, cargs, result);
    }

    pub fn setEnvironmentCustomSky(self: *const Self, arg_sky: *const godot.Sky) !void {
        if (mbind_set_environment_custom_sky == null) {
            mbind_set_environment_custom_sky = try api.createMethod("BakedLightmap", "set_environment_custom_sky");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_sky),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_custom_sky, base, cargs, result);
    }

    pub fn setEnvironmentCustomSkyRotationDegrees(self: *const Self, arg_rotation: *const godot.Vector3) !void {
        if (mbind_set_environment_custom_sky_rotation_degrees == null) {
            mbind_set_environment_custom_sky_rotation_degrees = try api.createMethod("BakedLightmap", "set_environment_custom_sky_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rotation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_custom_sky_rotation_degrees, base, cargs, result);
    }

    pub fn setEnvironmentMinLight(self: *const Self, arg_min_light: *const godot.Color) !void {
        if (mbind_set_environment_min_light == null) {
            mbind_set_environment_min_light = try api.createMethod("BakedLightmap", "set_environment_min_light");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_min_light),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_min_light, base, cargs, result);
    }

    pub fn setEnvironmentMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_environment_mode == null) {
            mbind_set_environment_mode = try api.createMethod("BakedLightmap", "set_environment_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment_mode, base, cargs, result);
    }

    pub fn setExtents(self: *const Self, arg_extents: *const godot.Vector3) !void {
        if (mbind_set_extents == null) {
            mbind_set_extents = try api.createMethod("BakedLightmap", "set_extents");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_extents),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_extents, base, cargs, result);
    }

    pub fn setGenerateAtlas(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_generate_atlas == null) {
            mbind_set_generate_atlas = try api.createMethod("BakedLightmap", "set_generate_atlas");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_generate_atlas, base, cargs, result);
    }

    pub fn setImagePath(self: *const Self, arg_image_path: *const godot.String) !void {
        if (mbind_set_image_path == null) {
            mbind_set_image_path = try api.createMethod("BakedLightmap", "set_image_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_image_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_image_path, base, cargs, result);
    }

    pub fn setLightData(self: *const Self, arg_data: *const godot.BakedLightmapData) !void {
        if (mbind_set_light_data == null) {
            mbind_set_light_data = try api.createMethod("BakedLightmap", "set_light_data");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_light_data, base, cargs, result);
    }

    pub fn setMaxAtlasSize(self: *const Self, arg_max_atlas_size: i32) !void {
        if (mbind_set_max_atlas_size == null) {
            mbind_set_max_atlas_size = try api.createMethod("BakedLightmap", "set_max_atlas_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_max_atlas_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_max_atlas_size, base, cargs, result);
    }

    pub fn setUseColor(self: *const Self, arg_use_denoiser: bool) !void {
        if (mbind_set_use_color == null) {
            mbind_set_use_color = try api.createMethod("BakedLightmap", "set_use_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_denoiser),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_color, base, cargs, result);
    }

    pub fn setUseDenoiser(self: *const Self, arg_use_denoiser: bool) !void {
        if (mbind_set_use_denoiser == null) {
            mbind_set_use_denoiser = try api.createMethod("BakedLightmap", "set_use_denoiser");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_denoiser),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_denoiser, base, cargs, result);
    }

    pub fn setUseHdr(self: *const Self, arg_use_denoiser: bool) !void {
        if (mbind_set_use_hdr == null) {
            mbind_set_use_hdr = try api.createMethod("BakedLightmap", "set_use_hdr");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use_denoiser),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_hdr, base, cargs, result);
    }
};