// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_add_child: ?*c_api.godot_method_bind = null;
var mbind_add_child_below_node: ?*c_api.godot_method_bind = null;
var mbind_add_to_group: ?*c_api.godot_method_bind = null;
var mbind_can_process: ?*c_api.godot_method_bind = null;
var mbind_duplicate: ?*c_api.godot_method_bind = null;
var mbind_find_node: ?*c_api.godot_method_bind = null;
var mbind_find_parent: ?*c_api.godot_method_bind = null;
var mbind_get_child: ?*c_api.godot_method_bind = null;
var mbind_get_child_count: ?*c_api.godot_method_bind = null;
var mbind_get_children: ?*c_api.godot_method_bind = null;
var mbind_get_custom_multiplayer: ?*c_api.godot_method_bind = null;
var mbind_get_filename: ?*c_api.godot_method_bind = null;
var mbind_get_groups: ?*c_api.godot_method_bind = null;
var mbind_get_index: ?*c_api.godot_method_bind = null;
var mbind_get_multiplayer: ?*c_api.godot_method_bind = null;
var mbind_get_name: ?*c_api.godot_method_bind = null;
var mbind_get_network_master: ?*c_api.godot_method_bind = null;
var mbind_get_node: ?*c_api.godot_method_bind = null;
var mbind_get_node_and_resource: ?*c_api.godot_method_bind = null;
var mbind_get_node_or_null: ?*c_api.godot_method_bind = null;
var mbind_get_owner: ?*c_api.godot_method_bind = null;
var mbind_get_parent: ?*c_api.godot_method_bind = null;
var mbind_get_path: ?*c_api.godot_method_bind = null;
var mbind_get_path_to: ?*c_api.godot_method_bind = null;
var mbind_get_pause_mode: ?*c_api.godot_method_bind = null;
var mbind_get_physics_process_delta_time: ?*c_api.godot_method_bind = null;
var mbind_get_position_in_parent: ?*c_api.godot_method_bind = null;
var mbind_get_process_delta_time: ?*c_api.godot_method_bind = null;
var mbind_get_process_priority: ?*c_api.godot_method_bind = null;
var mbind_get_scene_instance_load_placeholder: ?*c_api.godot_method_bind = null;
var mbind_get_tree: ?*c_api.godot_method_bind = null;
var mbind_get_viewport: ?*c_api.godot_method_bind = null;
var mbind_has_node: ?*c_api.godot_method_bind = null;
var mbind_has_node_and_resource: ?*c_api.godot_method_bind = null;
var mbind_is_a_parent_of: ?*c_api.godot_method_bind = null;
var mbind_is_displayed_folded: ?*c_api.godot_method_bind = null;
var mbind_is_greater_than: ?*c_api.godot_method_bind = null;
var mbind_is_in_group: ?*c_api.godot_method_bind = null;
var mbind_is_inside_tree: ?*c_api.godot_method_bind = null;
var mbind_is_network_master: ?*c_api.godot_method_bind = null;
var mbind_is_physics_processing: ?*c_api.godot_method_bind = null;
var mbind_is_physics_processing_internal: ?*c_api.godot_method_bind = null;
var mbind_is_processing: ?*c_api.godot_method_bind = null;
var mbind_is_processing_input: ?*c_api.godot_method_bind = null;
var mbind_is_processing_internal: ?*c_api.godot_method_bind = null;
var mbind_is_processing_unhandled_input: ?*c_api.godot_method_bind = null;
var mbind_is_processing_unhandled_key_input: ?*c_api.godot_method_bind = null;
var mbind_move_child: ?*c_api.godot_method_bind = null;
var mbind_print_stray_nodes: ?*c_api.godot_method_bind = null;
var mbind_print_tree: ?*c_api.godot_method_bind = null;
var mbind_print_tree_pretty: ?*c_api.godot_method_bind = null;
var mbind_propagate_call: ?*c_api.godot_method_bind = null;
var mbind_propagate_notification: ?*c_api.godot_method_bind = null;
var mbind_queue_free: ?*c_api.godot_method_bind = null;
var mbind_raise: ?*c_api.godot_method_bind = null;
var mbind_remove_and_skip: ?*c_api.godot_method_bind = null;
var mbind_remove_child: ?*c_api.godot_method_bind = null;
var mbind_remove_from_group: ?*c_api.godot_method_bind = null;
var mbind_replace_by: ?*c_api.godot_method_bind = null;
var mbind_request_ready: ?*c_api.godot_method_bind = null;
var mbind_rpc: ?*c_api.godot_method_bind = null;
var mbind_rpc_config: ?*c_api.godot_method_bind = null;
var mbind_rpc_id: ?*c_api.godot_method_bind = null;
var mbind_rpc_unreliable: ?*c_api.godot_method_bind = null;
var mbind_rpc_unreliable_id: ?*c_api.godot_method_bind = null;
var mbind_rset: ?*c_api.godot_method_bind = null;
var mbind_rset_config: ?*c_api.godot_method_bind = null;
var mbind_rset_id: ?*c_api.godot_method_bind = null;
var mbind_rset_unreliable: ?*c_api.godot_method_bind = null;
var mbind_rset_unreliable_id: ?*c_api.godot_method_bind = null;
var mbind_set_custom_multiplayer: ?*c_api.godot_method_bind = null;
var mbind_set_display_folded: ?*c_api.godot_method_bind = null;
var mbind_set_filename: ?*c_api.godot_method_bind = null;
var mbind_set_name: ?*c_api.godot_method_bind = null;
var mbind_set_network_master: ?*c_api.godot_method_bind = null;
var mbind_set_owner: ?*c_api.godot_method_bind = null;
var mbind_set_pause_mode: ?*c_api.godot_method_bind = null;
var mbind_set_physics_process: ?*c_api.godot_method_bind = null;
var mbind_set_physics_process_internal: ?*c_api.godot_method_bind = null;
var mbind_set_process: ?*c_api.godot_method_bind = null;
var mbind_set_process_input: ?*c_api.godot_method_bind = null;
var mbind_set_process_internal: ?*c_api.godot_method_bind = null;
var mbind_set_process_priority: ?*c_api.godot_method_bind = null;
var mbind_set_process_unhandled_input: ?*c_api.godot_method_bind = null;
var mbind_set_process_unhandled_key_input: ?*c_api.godot_method_bind = null;
var mbind_set_scene_instance_load_placeholder: ?*c_api.godot_method_bind = null;
var mbind_update_configuration_warning: ?*c_api.godot_method_bind = null;
var mbind_node_constructor: ?fn () ?*c_api.godot_object = null;

pub const Node = struct {
    const Self = @This();
    pub const BaseClass = godot.Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_node_constructor == null) {
            mbind_node_constructor = try api.createConstructor("Node");
        }
        return api.createObject(Self, mbind_node_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addChild(self: *const Self, arg_node: *const godot.Node, arg_legible_unique_name: bool) !void {
        if (mbind_add_child == null) {
            mbind_add_child = try api.createMethod("Node", "add_child");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
            @ptrCast(*const anyopaque, *arg_legible_unique_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_child, base, cargs, result);
    }

    pub fn addChildBelowNode(self: *const Self, arg_node: *const godot.Node, arg_child_node: *const godot.Node, arg_legible_unique_name: bool) !void {
        if (mbind_add_child_below_node == null) {
            mbind_add_child_below_node = try api.createMethod("Node", "add_child_below_node");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
            @ptrCast(*const anyopaque, arg_child_node),
            @ptrCast(*const anyopaque, *arg_legible_unique_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_child_below_node, base, cargs, result);
    }

    pub fn addToGroup(self: *const Self, arg_group: *const godot.String, arg_persistent: bool) !void {
        if (mbind_add_to_group == null) {
            mbind_add_to_group = try api.createMethod("Node", "add_to_group");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
            @ptrCast(*const anyopaque, *arg_persistent),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_to_group, base, cargs, result);
    }

    pub fn canProcess(self: *const Self) !bool {
        if (mbind_can_process == null) {
            mbind_can_process = try api.createMethod("Node", "can_process");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_can_process, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn duplicate(self: *const Self, arg_flags: i32) !godot.Node {
        if (mbind_duplicate == null) {
            mbind_duplicate = try api.createMethod("Node", "duplicate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_duplicate, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn findNode(self: *const Self, arg_mask: *const godot.String, arg_recursive: bool, arg_owned: bool) !godot.Node {
        if (mbind_find_node == null) {
            mbind_find_node = try api.createMethod("Node", "find_node");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mask),
            @ptrCast(*const anyopaque, *arg_recursive),
            @ptrCast(*const anyopaque, *arg_owned),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_node, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn findParent(self: *const Self, arg_mask: *const godot.String) !godot.Node {
        if (mbind_find_parent == null) {
            mbind_find_parent = try api.createMethod("Node", "find_parent");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_parent, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getChild(self: *const Self, arg_idx: i32) !godot.Node {
        if (mbind_get_child == null) {
            mbind_get_child = try api.createMethod("Node", "get_child");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_child, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getChildCount(self: *const Self) !i32 {
        if (mbind_get_child_count == null) {
            mbind_get_child_count = try api.createMethod("Node", "get_child_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_child_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getChildren(self: *const Self) !godot.Array {
        if (mbind_get_children == null) {
            mbind_get_children = try api.createMethod("Node", "get_children");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_children, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getCustomMultiplayer(self: *const Self) !godot.MultiplayerAPI {
        if (mbind_get_custom_multiplayer == null) {
            mbind_get_custom_multiplayer = try api.createMethod("Node", "get_custom_multiplayer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_custom_multiplayer, base, cargs, result);
        return @ptrCast(*godot.MultiplayerAPI, @alignCast(@alignOf(&godot.MultiplayerAPI), result)).*;
    }

    pub fn getFilename(self: *const Self) !godot.String {
        if (mbind_get_filename == null) {
            mbind_get_filename = try api.createMethod("Node", "get_filename");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_filename, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getGroups(self: *const Self) !godot.Array {
        if (mbind_get_groups == null) {
            mbind_get_groups = try api.createMethod("Node", "get_groups");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_groups, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getIndex(self: *const Self) !i32 {
        if (mbind_get_index == null) {
            mbind_get_index = try api.createMethod("Node", "get_index");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_index, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMultiplayer(self: *const Self) !godot.MultiplayerAPI {
        if (mbind_get_multiplayer == null) {
            mbind_get_multiplayer = try api.createMethod("Node", "get_multiplayer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_multiplayer, base, cargs, result);
        return @ptrCast(*godot.MultiplayerAPI, @alignCast(@alignOf(&godot.MultiplayerAPI), result)).*;
    }

    pub fn getName(self: *const Self) !godot.String {
        if (mbind_get_name == null) {
            mbind_get_name = try api.createMethod("Node", "get_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNetworkMaster(self: *const Self) !i32 {
        if (mbind_get_network_master == null) {
            mbind_get_network_master = try api.createMethod("Node", "get_network_master");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_network_master, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNode(self: *const Self, arg_path: *const godot.NodePath) !godot.Node {
        if (mbind_get_node == null) {
            mbind_get_node = try api.createMethod("Node", "get_node");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getNodeAndResource(self: *const Self, arg_path: *const godot.NodePath) !godot.Array {
        if (mbind_get_node_and_resource == null) {
            mbind_get_node_and_resource = try api.createMethod("Node", "get_node_and_resource");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_and_resource, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getNodeOrNull(self: *const Self, arg_path: *const godot.NodePath) !godot.Node {
        if (mbind_get_node_or_null == null) {
            mbind_get_node_or_null = try api.createMethod("Node", "get_node_or_null");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_or_null, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getOwner(self: *const Self) !godot.Node {
        if (mbind_get_owner == null) {
            mbind_get_owner = try api.createMethod("Node", "get_owner");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_owner, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getParent(self: *const Self) !godot.Node {
        if (mbind_get_parent == null) {
            mbind_get_parent = try api.createMethod("Node", "get_parent");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_parent, base, cargs, result);
        return @ptrCast(*godot.Node, @alignCast(@alignOf(&godot.Node), result)).*;
    }

    pub fn getPath(self: *const Self) !godot.NodePath {
        if (mbind_get_path == null) {
            mbind_get_path = try api.createMethod("Node", "get_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_path, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getPathTo(self: *const Self, arg_node: *const godot.Node) !godot.NodePath {
        if (mbind_get_path_to == null) {
            mbind_get_path_to = try api.createMethod("Node", "get_path_to");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_path_to, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getPauseMode(self: *const Self) !i32 {
        if (mbind_get_pause_mode == null) {
            mbind_get_pause_mode = try api.createMethod("Node", "get_pause_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pause_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPhysicsProcessDeltaTime(self: *const Self) !f32 {
        if (mbind_get_physics_process_delta_time == null) {
            mbind_get_physics_process_delta_time = try api.createMethod("Node", "get_physics_process_delta_time");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_physics_process_delta_time, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getPositionInParent(self: *const Self) !i32 {
        if (mbind_get_position_in_parent == null) {
            mbind_get_position_in_parent = try api.createMethod("Node", "get_position_in_parent");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_position_in_parent, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getProcessDeltaTime(self: *const Self) !f32 {
        if (mbind_get_process_delta_time == null) {
            mbind_get_process_delta_time = try api.createMethod("Node", "get_process_delta_time");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_process_delta_time, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getProcessPriority(self: *const Self) !i32 {
        if (mbind_get_process_priority == null) {
            mbind_get_process_priority = try api.createMethod("Node", "get_process_priority");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_process_priority, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSceneInstanceLoadPlaceholder(self: *const Self) !bool {
        if (mbind_get_scene_instance_load_placeholder == null) {
            mbind_get_scene_instance_load_placeholder = try api.createMethod("Node", "get_scene_instance_load_placeholder");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_scene_instance_load_placeholder, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getTree(self: *const Self) !godot.SceneTree {
        if (mbind_get_tree == null) {
            mbind_get_tree = try api.createMethod("Node", "get_tree");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tree, base, cargs, result);
        return @ptrCast(*godot.SceneTree, @alignCast(@alignOf(&godot.SceneTree), result)).*;
    }

    pub fn getViewport(self: *const Self) !godot.Viewport {
        if (mbind_get_viewport == null) {
            mbind_get_viewport = try api.createMethod("Node", "get_viewport");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_viewport, base, cargs, result);
        return @ptrCast(*godot.Viewport, @alignCast(@alignOf(&godot.Viewport), result)).*;
    }

    pub fn hasNode(self: *const Self, arg_path: *const godot.NodePath) !bool {
        if (mbind_has_node == null) {
            mbind_has_node = try api.createMethod("Node", "has_node");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_node, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasNodeAndResource(self: *const Self, arg_path: *const godot.NodePath) !bool {
        if (mbind_has_node_and_resource == null) {
            mbind_has_node_and_resource = try api.createMethod("Node", "has_node_and_resource");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_node_and_resource, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isAParentOf(self: *const Self, arg_node: *const godot.Node) !bool {
        if (mbind_is_a_parent_of == null) {
            mbind_is_a_parent_of = try api.createMethod("Node", "is_a_parent_of");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_a_parent_of, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDisplayedFolded(self: *const Self) !bool {
        if (mbind_is_displayed_folded == null) {
            mbind_is_displayed_folded = try api.createMethod("Node", "is_displayed_folded");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_displayed_folded, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isGreaterThan(self: *const Self, arg_node: *const godot.Node) !bool {
        if (mbind_is_greater_than == null) {
            mbind_is_greater_than = try api.createMethod("Node", "is_greater_than");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_greater_than, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInGroup(self: *const Self, arg_group: *const godot.String) !bool {
        if (mbind_is_in_group == null) {
            mbind_is_in_group = try api.createMethod("Node", "is_in_group");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_in_group, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInsideTree(self: *const Self) !bool {
        if (mbind_is_inside_tree == null) {
            mbind_is_inside_tree = try api.createMethod("Node", "is_inside_tree");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_inside_tree, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isNetworkMaster(self: *const Self) !bool {
        if (mbind_is_network_master == null) {
            mbind_is_network_master = try api.createMethod("Node", "is_network_master");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_network_master, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPhysicsProcessing(self: *const Self) !bool {
        if (mbind_is_physics_processing == null) {
            mbind_is_physics_processing = try api.createMethod("Node", "is_physics_processing");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_physics_processing, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPhysicsProcessingInternal(self: *const Self) !bool {
        if (mbind_is_physics_processing_internal == null) {
            mbind_is_physics_processing_internal = try api.createMethod("Node", "is_physics_processing_internal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_physics_processing_internal, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProcessing(self: *const Self) !bool {
        if (mbind_is_processing == null) {
            mbind_is_processing = try api.createMethod("Node", "is_processing");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_processing, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProcessingInput(self: *const Self) !bool {
        if (mbind_is_processing_input == null) {
            mbind_is_processing_input = try api.createMethod("Node", "is_processing_input");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_processing_input, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProcessingInternal(self: *const Self) !bool {
        if (mbind_is_processing_internal == null) {
            mbind_is_processing_internal = try api.createMethod("Node", "is_processing_internal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_processing_internal, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProcessingUnhandledInput(self: *const Self) !bool {
        if (mbind_is_processing_unhandled_input == null) {
            mbind_is_processing_unhandled_input = try api.createMethod("Node", "is_processing_unhandled_input");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_processing_unhandled_input, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProcessingUnhandledKeyInput(self: *const Self) !bool {
        if (mbind_is_processing_unhandled_key_input == null) {
            mbind_is_processing_unhandled_key_input = try api.createMethod("Node", "is_processing_unhandled_key_input");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_processing_unhandled_key_input, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn moveChild(self: *const Self, arg_child_node: *const godot.Node, arg_to_position: i32) !void {
        if (mbind_move_child == null) {
            mbind_move_child = try api.createMethod("Node", "move_child");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_child_node),
            @ptrCast(*const anyopaque, *arg_to_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_child, base, cargs, result);
    }

    pub fn printStrayNodes(self: *const Self) !void {
        if (mbind_print_stray_nodes == null) {
            mbind_print_stray_nodes = try api.createMethod("Node", "print_stray_nodes");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_stray_nodes, base, cargs, result);
    }

    pub fn printTree(self: *const Self) !void {
        if (mbind_print_tree == null) {
            mbind_print_tree = try api.createMethod("Node", "print_tree");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_tree, base, cargs, result);
    }

    pub fn printTreePretty(self: *const Self) !void {
        if (mbind_print_tree_pretty == null) {
            mbind_print_tree_pretty = try api.createMethod("Node", "print_tree_pretty");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_tree_pretty, base, cargs, result);
    }

    pub fn propagateCall(self: *const Self, arg_method: *const godot.String, arg_args: *const godot.Array, arg_parent_first: bool) !void {
        if (mbind_propagate_call == null) {
            mbind_propagate_call = try api.createMethod("Node", "propagate_call");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_args),
            @ptrCast(*const anyopaque, *arg_parent_first),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_propagate_call, base, cargs, result);
    }

    pub fn propagateNotification(self: *const Self, arg_what: i32) !void {
        if (mbind_propagate_notification == null) {
            mbind_propagate_notification = try api.createMethod("Node", "propagate_notification");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_what),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_propagate_notification, base, cargs, result);
    }

    pub fn queueFree(self: *const Self) !void {
        if (mbind_queue_free == null) {
            mbind_queue_free = try api.createMethod("Node", "queue_free");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_queue_free, base, cargs, result);
    }

    pub fn raise(self: *const Self) !void {
        if (mbind_raise == null) {
            mbind_raise = try api.createMethod("Node", "raise");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_raise, base, cargs, result);
    }

    pub fn removeAndSkip(self: *const Self) !void {
        if (mbind_remove_and_skip == null) {
            mbind_remove_and_skip = try api.createMethod("Node", "remove_and_skip");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_and_skip, base, cargs, result);
    }

    pub fn removeChild(self: *const Self, arg_node: *const godot.Node) !void {
        if (mbind_remove_child == null) {
            mbind_remove_child = try api.createMethod("Node", "remove_child");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_child, base, cargs, result);
    }

    pub fn removeFromGroup(self: *const Self, arg_group: *const godot.String) !void {
        if (mbind_remove_from_group == null) {
            mbind_remove_from_group = try api.createMethod("Node", "remove_from_group");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_group),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_from_group, base, cargs, result);
    }

    pub fn replaceBy(self: *const Self, arg_node: *const godot.Node, arg_keep_data: bool) !void {
        if (mbind_replace_by == null) {
            mbind_replace_by = try api.createMethod("Node", "replace_by");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
            @ptrCast(*const anyopaque, *arg_keep_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_replace_by, base, cargs, result);
    }

    pub fn requestReady(self: *const Self) !void {
        if (mbind_request_ready == null) {
            mbind_request_ready = try api.createMethod("Node", "request_ready");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_request_ready, base, cargs, result);
    }

    pub fn rpc(self: *const Self, arg_method: *const godot.String) !godot.Variant {
        if (mbind_rpc == null) {
            mbind_rpc = try api.createMethod("Node", "rpc");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rpc, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn rpcConfig(self: *const Self, arg_method: *const godot.String, arg_mode: i32) !void {
        if (mbind_rpc_config == null) {
            mbind_rpc_config = try api.createMethod("Node", "rpc_config");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rpc_config, base, cargs, result);
    }

    pub fn rpcId(self: *const Self, arg_peer_id: i32, arg_method: *const godot.String) !godot.Variant {
        if (mbind_rpc_id == null) {
            mbind_rpc_id = try api.createMethod("Node", "rpc_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_peer_id),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rpc_id, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn rpcUnreliable(self: *const Self, arg_method: *const godot.String) !godot.Variant {
        if (mbind_rpc_unreliable == null) {
            mbind_rpc_unreliable = try api.createMethod("Node", "rpc_unreliable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rpc_unreliable, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn rpcUnreliableId(self: *const Self, arg_peer_id: i32, arg_method: *const godot.String) !godot.Variant {
        if (mbind_rpc_unreliable_id == null) {
            mbind_rpc_unreliable_id = try api.createMethod("Node", "rpc_unreliable_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_peer_id),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rpc_unreliable_id, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn rset(self: *const Self, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_rset == null) {
            mbind_rset = try api.createMethod("Node", "rset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rset, base, cargs, result);
    }

    pub fn rsetConfig(self: *const Self, arg_property: *const godot.String, arg_mode: i32) !void {
        if (mbind_rset_config == null) {
            mbind_rset_config = try api.createMethod("Node", "rset_config");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rset_config, base, cargs, result);
    }

    pub fn rsetId(self: *const Self, arg_peer_id: i32, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_rset_id == null) {
            mbind_rset_id = try api.createMethod("Node", "rset_id");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_peer_id),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rset_id, base, cargs, result);
    }

    pub fn rsetUnreliable(self: *const Self, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_rset_unreliable == null) {
            mbind_rset_unreliable = try api.createMethod("Node", "rset_unreliable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rset_unreliable, base, cargs, result);
    }

    pub fn rsetUnreliableId(self: *const Self, arg_peer_id: i32, arg_property: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_rset_unreliable_id == null) {
            mbind_rset_unreliable_id = try api.createMethod("Node", "rset_unreliable_id");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_peer_id),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rset_unreliable_id, base, cargs, result);
    }

    pub fn setCustomMultiplayer(self: *const Self, arg_api: *const godot.MultiplayerAPI) !void {
        if (mbind_set_custom_multiplayer == null) {
            mbind_set_custom_multiplayer = try api.createMethod("Node", "set_custom_multiplayer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_api),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_custom_multiplayer, base, cargs, result);
    }

    pub fn setDisplayFolded(self: *const Self, arg_fold: bool) !void {
        if (mbind_set_display_folded == null) {
            mbind_set_display_folded = try api.createMethod("Node", "set_display_folded");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_fold),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_display_folded, base, cargs, result);
    }

    pub fn setFilename(self: *const Self, arg_filename: *const godot.String) !void {
        if (mbind_set_filename == null) {
            mbind_set_filename = try api.createMethod("Node", "set_filename");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_filename),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_filename, base, cargs, result);
    }

    pub fn setName(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_name == null) {
            mbind_set_name = try api.createMethod("Node", "set_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_name, base, cargs, result);
    }

    pub fn setNetworkMaster(self: *const Self, arg_id: i32, arg_recursive: bool) !void {
        if (mbind_set_network_master == null) {
            mbind_set_network_master = try api.createMethod("Node", "set_network_master");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_id),
            @ptrCast(*const anyopaque, *arg_recursive),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_network_master, base, cargs, result);
    }

    pub fn setOwner(self: *const Self, arg_owner: *const godot.Node) !void {
        if (mbind_set_owner == null) {
            mbind_set_owner = try api.createMethod("Node", "set_owner");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_owner),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_owner, base, cargs, result);
    }

    pub fn setPauseMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_pause_mode == null) {
            mbind_set_pause_mode = try api.createMethod("Node", "set_pause_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pause_mode, base, cargs, result);
    }

    pub fn setPhysicsProcess(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_physics_process == null) {
            mbind_set_physics_process = try api.createMethod("Node", "set_physics_process");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_physics_process, base, cargs, result);
    }

    pub fn setPhysicsProcessInternal(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_physics_process_internal == null) {
            mbind_set_physics_process_internal = try api.createMethod("Node", "set_physics_process_internal");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_physics_process_internal, base, cargs, result);
    }

    pub fn setProcess(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_process == null) {
            mbind_set_process = try api.createMethod("Node", "set_process");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process, base, cargs, result);
    }

    pub fn setProcessInput(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_process_input == null) {
            mbind_set_process_input = try api.createMethod("Node", "set_process_input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process_input, base, cargs, result);
    }

    pub fn setProcessInternal(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_process_internal == null) {
            mbind_set_process_internal = try api.createMethod("Node", "set_process_internal");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process_internal, base, cargs, result);
    }

    pub fn setProcessPriority(self: *const Self, arg_priority: i32) !void {
        if (mbind_set_process_priority == null) {
            mbind_set_process_priority = try api.createMethod("Node", "set_process_priority");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process_priority, base, cargs, result);
    }

    pub fn setProcessUnhandledInput(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_process_unhandled_input == null) {
            mbind_set_process_unhandled_input = try api.createMethod("Node", "set_process_unhandled_input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process_unhandled_input, base, cargs, result);
    }

    pub fn setProcessUnhandledKeyInput(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_process_unhandled_key_input == null) {
            mbind_set_process_unhandled_key_input = try api.createMethod("Node", "set_process_unhandled_key_input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_process_unhandled_key_input, base, cargs, result);
    }

    pub fn setSceneInstanceLoadPlaceholder(self: *const Self, arg_load_placeholder: bool) !void {
        if (mbind_set_scene_instance_load_placeholder == null) {
            mbind_set_scene_instance_load_placeholder = try api.createMethod("Node", "set_scene_instance_load_placeholder");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_load_placeholder),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_scene_instance_load_placeholder, base, cargs, result);
    }

    pub fn updateConfigurationWarning(self: *const Self) !void {
        if (mbind_update_configuration_warning == null) {
            mbind_update_configuration_warning = try api.createMethod("Node", "update_configuration_warning");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_configuration_warning, base, cargs, result);
    }
};