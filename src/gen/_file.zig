// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Reference = @import("reference.zig").Reference;

// method bindings
var mbind_close: ?*c_api.godot_method_bind = null;
var mbind_eof_reached: ?*c_api.godot_method_bind = null;
var mbind_file_exists: ?*c_api.godot_method_bind = null;
var mbind_flush: ?*c_api.godot_method_bind = null;
var mbind_get_16: ?*c_api.godot_method_bind = null;
var mbind_get_32: ?*c_api.godot_method_bind = null;
var mbind_get_64: ?*c_api.godot_method_bind = null;
var mbind_get_8: ?*c_api.godot_method_bind = null;
var mbind_get_as_text: ?*c_api.godot_method_bind = null;
var mbind_get_buffer: ?*c_api.godot_method_bind = null;
var mbind_get_csv_line: ?*c_api.godot_method_bind = null;
var mbind_get_double: ?*c_api.godot_method_bind = null;
var mbind_get_endian_swap: ?*c_api.godot_method_bind = null;
var mbind_get_error: ?*c_api.godot_method_bind = null;
var mbind_get_float: ?*c_api.godot_method_bind = null;
var mbind_get_len: ?*c_api.godot_method_bind = null;
var mbind_get_line: ?*c_api.godot_method_bind = null;
var mbind_get_md5: ?*c_api.godot_method_bind = null;
var mbind_get_modified_time: ?*c_api.godot_method_bind = null;
var mbind_get_pascal_string: ?*c_api.godot_method_bind = null;
var mbind_get_path: ?*c_api.godot_method_bind = null;
var mbind_get_path_absolute: ?*c_api.godot_method_bind = null;
var mbind_get_position: ?*c_api.godot_method_bind = null;
var mbind_get_real: ?*c_api.godot_method_bind = null;
var mbind_get_sha256: ?*c_api.godot_method_bind = null;
var mbind_get_var: ?*c_api.godot_method_bind = null;
var mbind_is_open: ?*c_api.godot_method_bind = null;
var mbind_open: ?*c_api.godot_method_bind = null;
var mbind_open_compressed: ?*c_api.godot_method_bind = null;
var mbind_open_encrypted: ?*c_api.godot_method_bind = null;
var mbind_open_encrypted_with_pass: ?*c_api.godot_method_bind = null;
var mbind_seek: ?*c_api.godot_method_bind = null;
var mbind_seek_end: ?*c_api.godot_method_bind = null;
var mbind_set_endian_swap: ?*c_api.godot_method_bind = null;
var mbind_store_16: ?*c_api.godot_method_bind = null;
var mbind_store_32: ?*c_api.godot_method_bind = null;
var mbind_store_64: ?*c_api.godot_method_bind = null;
var mbind_store_8: ?*c_api.godot_method_bind = null;
var mbind_store_buffer: ?*c_api.godot_method_bind = null;
var mbind_store_csv_line: ?*c_api.godot_method_bind = null;
var mbind_store_double: ?*c_api.godot_method_bind = null;
var mbind_store_float: ?*c_api.godot_method_bind = null;
var mbind_store_line: ?*c_api.godot_method_bind = null;
var mbind_store_pascal_string: ?*c_api.godot_method_bind = null;
var mbind_store_real: ?*c_api.godot_method_bind = null;
var mbind_store_string: ?*c_api.godot_method_bind = null;
var mbind_store_var: ?*c_api.godot_method_bind = null;
var mbind__file_constructor: ?fn () ?*c_api.godot_object = null;

pub const _File = struct {
    const Self = @This();
    const BaseClass = Reference;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind__file_constructor == null) {
            mbind__file_constructor = try api.createConstructor("_File");
        }
        return api.createObject(Self, mbind__file_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn close(self: *const Self) !void {
        if (mbind_close == null) {
            mbind_close = try api.createMethod("_File", "close");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_close, base, cargs, result);
    }

    pub fn eofReached(self: *const Self) !bool {
        if (mbind_eof_reached == null) {
            mbind_eof_reached = try api.createMethod("_File", "eof_reached");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_eof_reached, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn fileExists(self: *const Self, arg_path: *const godot.String) !bool {
        if (mbind_file_exists == null) {
            mbind_file_exists = try api.createMethod("_File", "file_exists");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_file_exists, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn flush(self: *const Self) !void {
        if (mbind_flush == null) {
            mbind_flush = try api.createMethod("_File", "flush");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_flush, base, cargs, result);
    }

    pub fn get16(self: *const Self) !i32 {
        if (mbind_get_16 == null) {
            mbind_get_16 = try api.createMethod("_File", "get_16");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_16, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn get32(self: *const Self) !i32 {
        if (mbind_get_32 == null) {
            mbind_get_32 = try api.createMethod("_File", "get_32");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_32, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn get64(self: *const Self) !i32 {
        if (mbind_get_64 == null) {
            mbind_get_64 = try api.createMethod("_File", "get_64");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_64, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn get8(self: *const Self) !i32 {
        if (mbind_get_8 == null) {
            mbind_get_8 = try api.createMethod("_File", "get_8");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_8, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getAsText(self: *const Self) !godot.String {
        if (mbind_get_as_text == null) {
            mbind_get_as_text = try api.createMethod("_File", "get_as_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_as_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getBuffer(self: *const Self, arg_len: i32) !godot.PoolByteArray {
        if (mbind_get_buffer == null) {
            mbind_get_buffer = try api.createMethod("_File", "get_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_len),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_buffer, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn getCsvLine(self: *const Self, arg_delim: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_csv_line == null) {
            mbind_get_csv_line = try api.createMethod("_File", "get_csv_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_delim),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_csv_line, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getDouble(self: *const Self) !f32 {
        if (mbind_get_double == null) {
            mbind_get_double = try api.createMethod("_File", "get_double");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_double, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEndianSwap(self: *const Self) !bool {
        if (mbind_get_endian_swap == null) {
            mbind_get_endian_swap = try api.createMethod("_File", "get_endian_swap");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_endian_swap, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getError(self: *const Self) !i32 {
        if (mbind_get_error == null) {
            mbind_get_error = try api.createMethod("_File", "get_error");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_error, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getFloat(self: *const Self) !f32 {
        if (mbind_get_float == null) {
            mbind_get_float = try api.createMethod("_File", "get_float");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_float, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getLen(self: *const Self) !i32 {
        if (mbind_get_len == null) {
            mbind_get_len = try api.createMethod("_File", "get_len");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_len, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLine(self: *const Self) !godot.String {
        if (mbind_get_line == null) {
            mbind_get_line = try api.createMethod("_File", "get_line");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getMd5(self: *const Self, arg_path: *const godot.String) !godot.String {
        if (mbind_get_md5 == null) {
            mbind_get_md5 = try api.createMethod("_File", "get_md5");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_md5, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getModifiedTime(self: *const Self, arg_file: *const godot.String) !i32 {
        if (mbind_get_modified_time == null) {
            mbind_get_modified_time = try api.createMethod("_File", "get_modified_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_file),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_modified_time, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPascalString(self: *const Self) !godot.String {
        if (mbind_get_pascal_string == null) {
            mbind_get_pascal_string = try api.createMethod("_File", "get_pascal_string");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pascal_string, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getPath(self: *const Self) !godot.String {
        if (mbind_get_path == null) {
            mbind_get_path = try api.createMethod("_File", "get_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getPathAbsolute(self: *const Self) !godot.String {
        if (mbind_get_path_absolute == null) {
            mbind_get_path_absolute = try api.createMethod("_File", "get_path_absolute");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_path_absolute, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getPosition(self: *const Self) !i32 {
        if (mbind_get_position == null) {
            mbind_get_position = try api.createMethod("_File", "get_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_position, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getReal(self: *const Self) !f32 {
        if (mbind_get_real == null) {
            mbind_get_real = try api.createMethod("_File", "get_real");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_real, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSha256(self: *const Self, arg_path: *const godot.String) !godot.String {
        if (mbind_get_sha256 == null) {
            mbind_get_sha256 = try api.createMethod("_File", "get_sha256");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_sha256, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVar(self: *const Self, arg_allow_objects: bool) !godot.Variant {
        if (mbind_get_var == null) {
            mbind_get_var = try api.createMethod("_File", "get_var");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_allow_objects),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_var, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn isOpen(self: *const Self) !bool {
        if (mbind_is_open == null) {
            mbind_is_open = try api.createMethod("_File", "is_open");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_open, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn open(self: *const Self, arg_path: *const godot.String, arg_flags: i32) !i32 {
        if (mbind_open == null) {
            mbind_open = try api.createMethod("_File", "open");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn openCompressed(self: *const Self, arg_path: *const godot.String, arg_mode_flags: i32, arg_compression_mode: i32) !i32 {
        if (mbind_open_compressed == null) {
            mbind_open_compressed = try api.createMethod("_File", "open_compressed");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_mode_flags),
            @ptrCast(*const anyopaque, *arg_compression_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_compressed, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn openEncrypted(self: *const Self, arg_path: *const godot.String, arg_mode_flags: i32, arg_key: *const godot.PoolByteArray) !i32 {
        if (mbind_open_encrypted == null) {
            mbind_open_encrypted = try api.createMethod("_File", "open_encrypted");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_mode_flags),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_encrypted, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn openEncryptedWithPass(self: *const Self, arg_path: *const godot.String, arg_mode_flags: i32, arg_pass: *const godot.String) !i32 {
        if (mbind_open_encrypted_with_pass == null) {
            mbind_open_encrypted_with_pass = try api.createMethod("_File", "open_encrypted_with_pass");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_mode_flags),
            @ptrCast(*const anyopaque, arg_pass),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_encrypted_with_pass, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn seek(self: *const Self, arg_position: i32) !void {
        if (mbind_seek == null) {
            mbind_seek = try api.createMethod("_File", "seek");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_seek, base, cargs, result);
    }

    pub fn seekEnd(self: *const Self, arg_position: i32) !void {
        if (mbind_seek_end == null) {
            mbind_seek_end = try api.createMethod("_File", "seek_end");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_seek_end, base, cargs, result);
    }

    pub fn setEndianSwap(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_endian_swap == null) {
            mbind_set_endian_swap = try api.createMethod("_File", "set_endian_swap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_endian_swap, base, cargs, result);
    }

    pub fn store16(self: *const Self, arg_value: i32) !void {
        if (mbind_store_16 == null) {
            mbind_store_16 = try api.createMethod("_File", "store_16");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_16, base, cargs, result);
    }

    pub fn store32(self: *const Self, arg_value: i32) !void {
        if (mbind_store_32 == null) {
            mbind_store_32 = try api.createMethod("_File", "store_32");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_32, base, cargs, result);
    }

    pub fn store64(self: *const Self, arg_value: i32) !void {
        if (mbind_store_64 == null) {
            mbind_store_64 = try api.createMethod("_File", "store_64");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_64, base, cargs, result);
    }

    pub fn store8(self: *const Self, arg_value: i32) !void {
        if (mbind_store_8 == null) {
            mbind_store_8 = try api.createMethod("_File", "store_8");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_8, base, cargs, result);
    }

    pub fn storeBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !void {
        if (mbind_store_buffer == null) {
            mbind_store_buffer = try api.createMethod("_File", "store_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_buffer, base, cargs, result);
    }

    pub fn storeCsvLine(self: *const Self, arg_values: *const godot.PoolStringArray, arg_delim: *const godot.String) !void {
        if (mbind_store_csv_line == null) {
            mbind_store_csv_line = try api.createMethod("_File", "store_csv_line");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_values),
            @ptrCast(*const anyopaque, arg_delim),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_csv_line, base, cargs, result);
    }

    pub fn storeDouble(self: *const Self, arg_value: f32) !void {
        if (mbind_store_double == null) {
            mbind_store_double = try api.createMethod("_File", "store_double");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_double, base, cargs, result);
    }

    pub fn storeFloat(self: *const Self, arg_value: f32) !void {
        if (mbind_store_float == null) {
            mbind_store_float = try api.createMethod("_File", "store_float");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_float, base, cargs, result);
    }

    pub fn storeLine(self: *const Self, arg_line: *const godot.String) !void {
        if (mbind_store_line == null) {
            mbind_store_line = try api.createMethod("_File", "store_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_line, base, cargs, result);
    }

    pub fn storePascalString(self: *const Self, arg_string: *const godot.String) !void {
        if (mbind_store_pascal_string == null) {
            mbind_store_pascal_string = try api.createMethod("_File", "store_pascal_string");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_string),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_pascal_string, base, cargs, result);
    }

    pub fn storeReal(self: *const Self, arg_value: f32) !void {
        if (mbind_store_real == null) {
            mbind_store_real = try api.createMethod("_File", "store_real");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_real, base, cargs, result);
    }

    pub fn storeString(self: *const Self, arg_string: *const godot.String) !void {
        if (mbind_store_string == null) {
            mbind_store_string = try api.createMethod("_File", "store_string");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_string),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_string, base, cargs, result);
    }

    pub fn storeVar(self: *const Self, arg_value: *const godot.Variant, arg_full_objects: bool) !void {
        if (mbind_store_var == null) {
            mbind_store_var = try api.createMethod("_File", "store_var");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_value),
            @ptrCast(*const anyopaque, *arg_full_objects),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_store_var, base, cargs, result);
    }
};