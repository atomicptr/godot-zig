// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Range = @import("range.zig").Range;

// method bindings
var mbind_get_fill_degrees: ?*c_api.godot_method_bind = null;
var mbind_get_fill_mode: ?*c_api.godot_method_bind = null;
var mbind_get_nine_patch_stretch: ?*c_api.godot_method_bind = null;
var mbind_get_over_texture: ?*c_api.godot_method_bind = null;
var mbind_get_progress_texture: ?*c_api.godot_method_bind = null;
var mbind_get_radial_center_offset: ?*c_api.godot_method_bind = null;
var mbind_get_radial_initial_angle: ?*c_api.godot_method_bind = null;
var mbind_get_stretch_margin: ?*c_api.godot_method_bind = null;
var mbind_get_texture_progress_offset: ?*c_api.godot_method_bind = null;
var mbind_get_tint_over: ?*c_api.godot_method_bind = null;
var mbind_get_tint_progress: ?*c_api.godot_method_bind = null;
var mbind_get_tint_under: ?*c_api.godot_method_bind = null;
var mbind_get_under_texture: ?*c_api.godot_method_bind = null;
var mbind_set_fill_degrees: ?*c_api.godot_method_bind = null;
var mbind_set_fill_mode: ?*c_api.godot_method_bind = null;
var mbind_set_nine_patch_stretch: ?*c_api.godot_method_bind = null;
var mbind_set_over_texture: ?*c_api.godot_method_bind = null;
var mbind_set_progress_texture: ?*c_api.godot_method_bind = null;
var mbind_set_radial_center_offset: ?*c_api.godot_method_bind = null;
var mbind_set_radial_initial_angle: ?*c_api.godot_method_bind = null;
var mbind_set_stretch_margin: ?*c_api.godot_method_bind = null;
var mbind_set_texture_progress_offset: ?*c_api.godot_method_bind = null;
var mbind_set_tint_over: ?*c_api.godot_method_bind = null;
var mbind_set_tint_progress: ?*c_api.godot_method_bind = null;
var mbind_set_tint_under: ?*c_api.godot_method_bind = null;
var mbind_set_under_texture: ?*c_api.godot_method_bind = null;
var mbind_texture_progress_constructor: ?fn () ?*c_api.godot_object = null;

pub const TextureProgress = struct {
    const Self = @This();
    const BaseClass = Range;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_texture_progress_constructor == null) {
            mbind_texture_progress_constructor = try api.createConstructor("TextureProgress");
        }
        return api.createObject(Self, mbind_texture_progress_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getFillDegrees(self: *const Self) !f32 {
        if (mbind_get_fill_degrees == null) {
            mbind_get_fill_degrees = try api.createMethod("TextureProgress", "get_fill_degrees");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_fill_degrees, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getFillMode(self: *const Self) !i32 {
        if (mbind_get_fill_mode == null) {
            mbind_get_fill_mode = try api.createMethod("TextureProgress", "get_fill_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_fill_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNinePatchStretch(self: *const Self) !bool {
        if (mbind_get_nine_patch_stretch == null) {
            mbind_get_nine_patch_stretch = try api.createMethod("TextureProgress", "get_nine_patch_stretch");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_nine_patch_stretch, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getOverTexture(self: *const Self) !godot.Texture {
        if (mbind_get_over_texture == null) {
            mbind_get_over_texture = try api.createMethod("TextureProgress", "get_over_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_over_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getProgressTexture(self: *const Self) !godot.Texture {
        if (mbind_get_progress_texture == null) {
            mbind_get_progress_texture = try api.createMethod("TextureProgress", "get_progress_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_progress_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getRadialCenterOffset(self: *const Self) !godot.Vector2 {
        if (mbind_get_radial_center_offset == null) {
            mbind_get_radial_center_offset = try api.createMethod("TextureProgress", "get_radial_center_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_radial_center_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getRadialInitialAngle(self: *const Self) !f32 {
        if (mbind_get_radial_initial_angle == null) {
            mbind_get_radial_initial_angle = try api.createMethod("TextureProgress", "get_radial_initial_angle");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_radial_initial_angle, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getStretchMargin(self: *const Self, arg_margin: i32) !i32 {
        if (mbind_get_stretch_margin == null) {
            mbind_get_stretch_margin = try api.createMethod("TextureProgress", "get_stretch_margin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stretch_margin, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTextureProgressOffset(self: *const Self) !godot.Vector2 {
        if (mbind_get_texture_progress_offset == null) {
            mbind_get_texture_progress_offset = try api.createMethod("TextureProgress", "get_texture_progress_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture_progress_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getTintOver(self: *const Self) !godot.Color {
        if (mbind_get_tint_over == null) {
            mbind_get_tint_over = try api.createMethod("TextureProgress", "get_tint_over");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tint_over, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getTintProgress(self: *const Self) !godot.Color {
        if (mbind_get_tint_progress == null) {
            mbind_get_tint_progress = try api.createMethod("TextureProgress", "get_tint_progress");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tint_progress, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getTintUnder(self: *const Self) !godot.Color {
        if (mbind_get_tint_under == null) {
            mbind_get_tint_under = try api.createMethod("TextureProgress", "get_tint_under");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tint_under, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getUnderTexture(self: *const Self) !godot.Texture {
        if (mbind_get_under_texture == null) {
            mbind_get_under_texture = try api.createMethod("TextureProgress", "get_under_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_under_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn setFillDegrees(self: *const Self, arg_mode: f32) !void {
        if (mbind_set_fill_degrees == null) {
            mbind_set_fill_degrees = try api.createMethod("TextureProgress", "set_fill_degrees");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_fill_degrees, base, cargs, result);
    }

    pub fn setFillMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_fill_mode == null) {
            mbind_set_fill_mode = try api.createMethod("TextureProgress", "set_fill_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_fill_mode, base, cargs, result);
    }

    pub fn setNinePatchStretch(self: *const Self, arg_stretch: bool) !void {
        if (mbind_set_nine_patch_stretch == null) {
            mbind_set_nine_patch_stretch = try api.createMethod("TextureProgress", "set_nine_patch_stretch");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_stretch),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_nine_patch_stretch, base, cargs, result);
    }

    pub fn setOverTexture(self: *const Self, arg_tex: *const godot.Texture) !void {
        if (mbind_set_over_texture == null) {
            mbind_set_over_texture = try api.createMethod("TextureProgress", "set_over_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tex),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_over_texture, base, cargs, result);
    }

    pub fn setProgressTexture(self: *const Self, arg_tex: *const godot.Texture) !void {
        if (mbind_set_progress_texture == null) {
            mbind_set_progress_texture = try api.createMethod("TextureProgress", "set_progress_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tex),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_progress_texture, base, cargs, result);
    }

    pub fn setRadialCenterOffset(self: *const Self, arg_mode: *const godot.Vector2) !void {
        if (mbind_set_radial_center_offset == null) {
            mbind_set_radial_center_offset = try api.createMethod("TextureProgress", "set_radial_center_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_radial_center_offset, base, cargs, result);
    }

    pub fn setRadialInitialAngle(self: *const Self, arg_mode: f32) !void {
        if (mbind_set_radial_initial_angle == null) {
            mbind_set_radial_initial_angle = try api.createMethod("TextureProgress", "set_radial_initial_angle");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_radial_initial_angle, base, cargs, result);
    }

    pub fn setStretchMargin(self: *const Self, arg_margin: i32, arg_value: i32) !void {
        if (mbind_set_stretch_margin == null) {
            mbind_set_stretch_margin = try api.createMethod("TextureProgress", "set_stretch_margin");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_stretch_margin, base, cargs, result);
    }

    pub fn setTextureProgressOffset(self: *const Self, arg_offset: *const godot.Vector2) !void {
        if (mbind_set_texture_progress_offset == null) {
            mbind_set_texture_progress_offset = try api.createMethod("TextureProgress", "set_texture_progress_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture_progress_offset, base, cargs, result);
    }

    pub fn setTintOver(self: *const Self, arg_tint: *const godot.Color) !void {
        if (mbind_set_tint_over == null) {
            mbind_set_tint_over = try api.createMethod("TextureProgress", "set_tint_over");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tint_over, base, cargs, result);
    }

    pub fn setTintProgress(self: *const Self, arg_tint: *const godot.Color) !void {
        if (mbind_set_tint_progress == null) {
            mbind_set_tint_progress = try api.createMethod("TextureProgress", "set_tint_progress");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tint_progress, base, cargs, result);
    }

    pub fn setTintUnder(self: *const Self, arg_tint: *const godot.Color) !void {
        if (mbind_set_tint_under == null) {
            mbind_set_tint_under = try api.createMethod("TextureProgress", "set_tint_under");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tint_under, base, cargs, result);
    }

    pub fn setUnderTexture(self: *const Self, arg_tex: *const godot.Texture) !void {
        if (mbind_set_under_texture == null) {
            mbind_set_under_texture = try api.createMethod("TextureProgress", "set_under_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tex),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_under_texture, base, cargs, result);
    }
};