// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Reference = @import("reference.zig").Reference;

// method bindings
var mbind_get_collider: ?*c_api.godot_method_bind = null;
var mbind_get_collider_id: ?*c_api.godot_method_bind = null;
var mbind_get_collider_rid: ?*c_api.godot_method_bind = null;
var mbind_get_collider_shape: ?*c_api.godot_method_bind = null;
var mbind_get_collider_velocity: ?*c_api.godot_method_bind = null;
var mbind_get_collision_depth: ?*c_api.godot_method_bind = null;
var mbind_get_collision_normal: ?*c_api.godot_method_bind = null;
var mbind_get_collision_point: ?*c_api.godot_method_bind = null;
var mbind_get_collision_safe_fraction: ?*c_api.godot_method_bind = null;
var mbind_get_collision_unsafe_fraction: ?*c_api.godot_method_bind = null;
var mbind_get_motion: ?*c_api.godot_method_bind = null;
var mbind_get_motion_remainder: ?*c_api.godot_method_bind = null;
var mbind_physics_2dtest_motion_result_constructor: ?fn () ?*c_api.godot_object = null;

pub const Physics2DTestMotionResult = struct {
    const Self = @This();
    const BaseClass = Reference;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_physics_2dtest_motion_result_constructor == null) {
            mbind_physics_2dtest_motion_result_constructor = try api.createConstructor("Physics2DTestMotionResult");
        }
        return api.createObject(Self, mbind_physics_2dtest_motion_result_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getCollider(self: *const Self) !godot.Object {
        if (mbind_get_collider == null) {
            mbind_get_collider = try api.createMethod("Physics2DTestMotionResult", "get_collider");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider, base, cargs, result);
        return @ptrCast(*godot.Object, @alignCast(@alignOf(&godot.Object), result)).*;
    }

    pub fn getColliderId(self: *const Self) !i32 {
        if (mbind_get_collider_id == null) {
            mbind_get_collider_id = try api.createMethod("Physics2DTestMotionResult", "get_collider_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getColliderRid(self: *const Self) !godot.RID {
        if (mbind_get_collider_rid == null) {
            mbind_get_collider_rid = try api.createMethod("Physics2DTestMotionResult", "get_collider_rid");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_rid, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getColliderShape(self: *const Self) !i32 {
        if (mbind_get_collider_shape == null) {
            mbind_get_collider_shape = try api.createMethod("Physics2DTestMotionResult", "get_collider_shape");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_shape, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getColliderVelocity(self: *const Self) !godot.Vector2 {
        if (mbind_get_collider_velocity == null) {
            mbind_get_collider_velocity = try api.createMethod("Physics2DTestMotionResult", "get_collider_velocity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collider_velocity, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getCollisionDepth(self: *const Self) !f32 {
        if (mbind_get_collision_depth == null) {
            mbind_get_collision_depth = try api.createMethod("Physics2DTestMotionResult", "get_collision_depth");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_depth, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollisionNormal(self: *const Self) !godot.Vector2 {
        if (mbind_get_collision_normal == null) {
            mbind_get_collision_normal = try api.createMethod("Physics2DTestMotionResult", "get_collision_normal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_normal, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getCollisionPoint(self: *const Self) !godot.Vector2 {
        if (mbind_get_collision_point == null) {
            mbind_get_collision_point = try api.createMethod("Physics2DTestMotionResult", "get_collision_point");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_point, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getCollisionSafeFraction(self: *const Self) !f32 {
        if (mbind_get_collision_safe_fraction == null) {
            mbind_get_collision_safe_fraction = try api.createMethod("Physics2DTestMotionResult", "get_collision_safe_fraction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_safe_fraction, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCollisionUnsafeFraction(self: *const Self) !f32 {
        if (mbind_get_collision_unsafe_fraction == null) {
            mbind_get_collision_unsafe_fraction = try api.createMethod("Physics2DTestMotionResult", "get_collision_unsafe_fraction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_collision_unsafe_fraction, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getMotion(self: *const Self) !godot.Vector2 {
        if (mbind_get_motion == null) {
            mbind_get_motion = try api.createMethod("Physics2DTestMotionResult", "get_motion");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_motion, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getMotionRemainder(self: *const Self) !godot.Vector2 {
        if (mbind_get_motion_remainder == null) {
            mbind_get_motion_remainder = try api.createMethod("Physics2DTestMotionResult", "get_motion_remainder");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_motion_remainder, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }
};