// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Control = @import("control.zig").Control;

// method bindings
var mbind_add_icon_item: ?*c_api.godot_method_bind = null;
var mbind_add_item: ?*c_api.godot_method_bind = null;
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_ensure_current_is_visible: ?*c_api.godot_method_bind = null;
var mbind_get_allow_reselect: ?*c_api.godot_method_bind = null;
var mbind_get_allow_rmb_select: ?*c_api.godot_method_bind = null;
var mbind_get_fixed_column_width: ?*c_api.godot_method_bind = null;
var mbind_get_fixed_icon_size: ?*c_api.godot_method_bind = null;
var mbind_get_icon_mode: ?*c_api.godot_method_bind = null;
var mbind_get_icon_scale: ?*c_api.godot_method_bind = null;
var mbind_get_item_at_position: ?*c_api.godot_method_bind = null;
var mbind_get_item_count: ?*c_api.godot_method_bind = null;
var mbind_get_item_custom_bg_color: ?*c_api.godot_method_bind = null;
var mbind_get_item_custom_fg_color: ?*c_api.godot_method_bind = null;
var mbind_get_item_icon: ?*c_api.godot_method_bind = null;
var mbind_get_item_icon_modulate: ?*c_api.godot_method_bind = null;
var mbind_get_item_icon_region: ?*c_api.godot_method_bind = null;
var mbind_get_item_metadata: ?*c_api.godot_method_bind = null;
var mbind_get_item_text: ?*c_api.godot_method_bind = null;
var mbind_get_item_tooltip: ?*c_api.godot_method_bind = null;
var mbind_get_max_columns: ?*c_api.godot_method_bind = null;
var mbind_get_max_text_lines: ?*c_api.godot_method_bind = null;
var mbind_get_select_mode: ?*c_api.godot_method_bind = null;
var mbind_get_selected_items: ?*c_api.godot_method_bind = null;
var mbind_get_v_scroll: ?*c_api.godot_method_bind = null;
var mbind_has_auto_height: ?*c_api.godot_method_bind = null;
var mbind_is_anything_selected: ?*c_api.godot_method_bind = null;
var mbind_is_item_disabled: ?*c_api.godot_method_bind = null;
var mbind_is_item_icon_transposed: ?*c_api.godot_method_bind = null;
var mbind_is_item_selectable: ?*c_api.godot_method_bind = null;
var mbind_is_item_tooltip_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_same_column_width: ?*c_api.godot_method_bind = null;
var mbind_is_selected: ?*c_api.godot_method_bind = null;
var mbind_move_item: ?*c_api.godot_method_bind = null;
var mbind_remove_item: ?*c_api.godot_method_bind = null;
var mbind_select: ?*c_api.godot_method_bind = null;
var mbind_set_allow_reselect: ?*c_api.godot_method_bind = null;
var mbind_set_allow_rmb_select: ?*c_api.godot_method_bind = null;
var mbind_set_auto_height: ?*c_api.godot_method_bind = null;
var mbind_set_fixed_column_width: ?*c_api.godot_method_bind = null;
var mbind_set_fixed_icon_size: ?*c_api.godot_method_bind = null;
var mbind_set_icon_mode: ?*c_api.godot_method_bind = null;
var mbind_set_icon_scale: ?*c_api.godot_method_bind = null;
var mbind_set_item_custom_bg_color: ?*c_api.godot_method_bind = null;
var mbind_set_item_custom_fg_color: ?*c_api.godot_method_bind = null;
var mbind_set_item_disabled: ?*c_api.godot_method_bind = null;
var mbind_set_item_icon: ?*c_api.godot_method_bind = null;
var mbind_set_item_icon_modulate: ?*c_api.godot_method_bind = null;
var mbind_set_item_icon_region: ?*c_api.godot_method_bind = null;
var mbind_set_item_icon_transposed: ?*c_api.godot_method_bind = null;
var mbind_set_item_metadata: ?*c_api.godot_method_bind = null;
var mbind_set_item_selectable: ?*c_api.godot_method_bind = null;
var mbind_set_item_text: ?*c_api.godot_method_bind = null;
var mbind_set_item_tooltip: ?*c_api.godot_method_bind = null;
var mbind_set_item_tooltip_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_max_columns: ?*c_api.godot_method_bind = null;
var mbind_set_max_text_lines: ?*c_api.godot_method_bind = null;
var mbind_set_same_column_width: ?*c_api.godot_method_bind = null;
var mbind_set_select_mode: ?*c_api.godot_method_bind = null;
var mbind_sort_items_by_text: ?*c_api.godot_method_bind = null;
var mbind_unselect: ?*c_api.godot_method_bind = null;
var mbind_unselect_all: ?*c_api.godot_method_bind = null;
var mbind_item_list_constructor: ?fn () ?*c_api.godot_object = null;

pub const ItemList = struct {
    const Self = @This();
    const BaseClass = Control;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_item_list_constructor == null) {
            mbind_item_list_constructor = try api.createConstructor("ItemList");
        }
        return api.createObject(Self, mbind_item_list_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addIconItem(self: *const Self, arg_icon: *const godot.Texture, arg_selectable: bool) !void {
        if (mbind_add_icon_item == null) {
            mbind_add_icon_item = try api.createMethod("ItemList", "add_icon_item");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_icon),
            @ptrCast(*const anyopaque, *arg_selectable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_item, base, cargs, result);
    }

    pub fn addItem(self: *const Self, arg_text: *const godot.String, arg_icon: *const godot.Texture, arg_selectable: bool) !void {
        if (mbind_add_item == null) {
            mbind_add_item = try api.createMethod("ItemList", "add_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
            @ptrCast(*const anyopaque, arg_icon),
            @ptrCast(*const anyopaque, *arg_selectable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_item, base, cargs, result);
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("ItemList", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn ensureCurrentIsVisible(self: *const Self) !void {
        if (mbind_ensure_current_is_visible == null) {
            mbind_ensure_current_is_visible = try api.createMethod("ItemList", "ensure_current_is_visible");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_ensure_current_is_visible, base, cargs, result);
    }

    pub fn getAllowReselect(self: *const Self) !bool {
        if (mbind_get_allow_reselect == null) {
            mbind_get_allow_reselect = try api.createMethod("ItemList", "get_allow_reselect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_allow_reselect, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getAllowRmbSelect(self: *const Self) !bool {
        if (mbind_get_allow_rmb_select == null) {
            mbind_get_allow_rmb_select = try api.createMethod("ItemList", "get_allow_rmb_select");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_allow_rmb_select, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getFixedColumnWidth(self: *const Self) !i32 {
        if (mbind_get_fixed_column_width == null) {
            mbind_get_fixed_column_width = try api.createMethod("ItemList", "get_fixed_column_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_fixed_column_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getFixedIconSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_fixed_icon_size == null) {
            mbind_get_fixed_icon_size = try api.createMethod("ItemList", "get_fixed_icon_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_fixed_icon_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getIconMode(self: *const Self) !i32 {
        if (mbind_get_icon_mode == null) {
            mbind_get_icon_mode = try api.createMethod("ItemList", "get_icon_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getIconScale(self: *const Self) !f32 {
        if (mbind_get_icon_scale == null) {
            mbind_get_icon_scale = try api.createMethod("ItemList", "get_icon_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getItemAtPosition(self: *const Self, arg_position: *const godot.Vector2, arg_exact: bool) !i32 {
        if (mbind_get_item_at_position == null) {
            mbind_get_item_at_position = try api.createMethod("ItemList", "get_item_at_position");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_exact),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_at_position, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemCount(self: *const Self) !i32 {
        if (mbind_get_item_count == null) {
            mbind_get_item_count = try api.createMethod("ItemList", "get_item_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getItemCustomBgColor(self: *const Self, arg_idx: i32) !godot.Color {
        if (mbind_get_item_custom_bg_color == null) {
            mbind_get_item_custom_bg_color = try api.createMethod("ItemList", "get_item_custom_bg_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_custom_bg_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getItemCustomFgColor(self: *const Self, arg_idx: i32) !godot.Color {
        if (mbind_get_item_custom_fg_color == null) {
            mbind_get_item_custom_fg_color = try api.createMethod("ItemList", "get_item_custom_fg_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_custom_fg_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getItemIcon(self: *const Self, arg_idx: i32) !godot.Texture {
        if (mbind_get_item_icon == null) {
            mbind_get_item_icon = try api.createMethod("ItemList", "get_item_icon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_icon, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getItemIconModulate(self: *const Self, arg_idx: i32) !godot.Color {
        if (mbind_get_item_icon_modulate == null) {
            mbind_get_item_icon_modulate = try api.createMethod("ItemList", "get_item_icon_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_icon_modulate, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getItemIconRegion(self: *const Self, arg_idx: i32) !godot.Rect2 {
        if (mbind_get_item_icon_region == null) {
            mbind_get_item_icon_region = try api.createMethod("ItemList", "get_item_icon_region");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_icon_region, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getItemMetadata(self: *const Self, arg_idx: i32) !godot.Variant {
        if (mbind_get_item_metadata == null) {
            mbind_get_item_metadata = try api.createMethod("ItemList", "get_item_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_metadata, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn getItemText(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_item_text == null) {
            mbind_get_item_text = try api.createMethod("ItemList", "get_item_text");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getItemTooltip(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_item_tooltip == null) {
            mbind_get_item_tooltip = try api.createMethod("ItemList", "get_item_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_item_tooltip, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getMaxColumns(self: *const Self) !i32 {
        if (mbind_get_max_columns == null) {
            mbind_get_max_columns = try api.createMethod("ItemList", "get_max_columns");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_max_columns, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMaxTextLines(self: *const Self) !i32 {
        if (mbind_get_max_text_lines == null) {
            mbind_get_max_text_lines = try api.createMethod("ItemList", "get_max_text_lines");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_max_text_lines, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSelectMode(self: *const Self) !i32 {
        if (mbind_get_select_mode == null) {
            mbind_get_select_mode = try api.createMethod("ItemList", "get_select_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_select_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSelectedItems(self: *const Self) !godot.PoolIntArray {
        if (mbind_get_selected_items == null) {
            mbind_get_selected_items = try api.createMethod("ItemList", "get_selected_items");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selected_items, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn getVScroll(self: *const Self) !godot.VScrollBar {
        if (mbind_get_v_scroll == null) {
            mbind_get_v_scroll = try api.createMethod("ItemList", "get_v_scroll");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_v_scroll, base, cargs, result);
        return @ptrCast(*godot.VScrollBar, @alignCast(@alignOf(&godot.VScrollBar), result)).*;
    }

    pub fn hasAutoHeight(self: *const Self) !bool {
        if (mbind_has_auto_height == null) {
            mbind_has_auto_height = try api.createMethod("ItemList", "has_auto_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_auto_height, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isAnythingSelected(self: *const Self) !bool {
        if (mbind_is_anything_selected == null) {
            mbind_is_anything_selected = try api.createMethod("ItemList", "is_anything_selected");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_anything_selected, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemDisabled(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_disabled == null) {
            mbind_is_item_disabled = try api.createMethod("ItemList", "is_item_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemIconTransposed(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_icon_transposed == null) {
            mbind_is_item_icon_transposed = try api.createMethod("ItemList", "is_item_icon_transposed");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_icon_transposed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemSelectable(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_selectable == null) {
            mbind_is_item_selectable = try api.createMethod("ItemList", "is_item_selectable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_selectable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isItemTooltipEnabled(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_item_tooltip_enabled == null) {
            mbind_is_item_tooltip_enabled = try api.createMethod("ItemList", "is_item_tooltip_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_item_tooltip_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSameColumnWidth(self: *const Self) !bool {
        if (mbind_is_same_column_width == null) {
            mbind_is_same_column_width = try api.createMethod("ItemList", "is_same_column_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_same_column_width, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSelected(self: *const Self, arg_idx: i32) !bool {
        if (mbind_is_selected == null) {
            mbind_is_selected = try api.createMethod("ItemList", "is_selected");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_selected, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn moveItem(self: *const Self, arg_from_idx: i32, arg_to_idx: i32) !void {
        if (mbind_move_item == null) {
            mbind_move_item = try api.createMethod("ItemList", "move_item");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_from_idx),
            @ptrCast(*const anyopaque, *arg_to_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_item, base, cargs, result);
    }

    pub fn removeItem(self: *const Self, arg_idx: i32) !void {
        if (mbind_remove_item == null) {
            mbind_remove_item = try api.createMethod("ItemList", "remove_item");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_item, base, cargs, result);
    }

    pub fn select(self: *const Self, arg_idx: i32, arg_single: bool) !void {
        if (mbind_select == null) {
            mbind_select = try api.createMethod("ItemList", "select");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_single),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_select, base, cargs, result);
    }

    pub fn setAllowReselect(self: *const Self, arg_allow: bool) !void {
        if (mbind_set_allow_reselect == null) {
            mbind_set_allow_reselect = try api.createMethod("ItemList", "set_allow_reselect");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_allow),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_allow_reselect, base, cargs, result);
    }

    pub fn setAllowRmbSelect(self: *const Self, arg_allow: bool) !void {
        if (mbind_set_allow_rmb_select == null) {
            mbind_set_allow_rmb_select = try api.createMethod("ItemList", "set_allow_rmb_select");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_allow),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_allow_rmb_select, base, cargs, result);
    }

    pub fn setAutoHeight(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_auto_height == null) {
            mbind_set_auto_height = try api.createMethod("ItemList", "set_auto_height");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_auto_height, base, cargs, result);
    }

    pub fn setFixedColumnWidth(self: *const Self, arg_width: i32) !void {
        if (mbind_set_fixed_column_width == null) {
            mbind_set_fixed_column_width = try api.createMethod("ItemList", "set_fixed_column_width");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_fixed_column_width, base, cargs, result);
    }

    pub fn setFixedIconSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_fixed_icon_size == null) {
            mbind_set_fixed_icon_size = try api.createMethod("ItemList", "set_fixed_icon_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_fixed_icon_size, base, cargs, result);
    }

    pub fn setIconMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_icon_mode == null) {
            mbind_set_icon_mode = try api.createMethod("ItemList", "set_icon_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_icon_mode, base, cargs, result);
    }

    pub fn setIconScale(self: *const Self, arg_scale: f32) !void {
        if (mbind_set_icon_scale == null) {
            mbind_set_icon_scale = try api.createMethod("ItemList", "set_icon_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_icon_scale, base, cargs, result);
    }

    pub fn setItemCustomBgColor(self: *const Self, arg_idx: i32, arg_custom_bg_color: *const godot.Color) !void {
        if (mbind_set_item_custom_bg_color == null) {
            mbind_set_item_custom_bg_color = try api.createMethod("ItemList", "set_item_custom_bg_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_custom_bg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_custom_bg_color, base, cargs, result);
    }

    pub fn setItemCustomFgColor(self: *const Self, arg_idx: i32, arg_custom_fg_color: *const godot.Color) !void {
        if (mbind_set_item_custom_fg_color == null) {
            mbind_set_item_custom_fg_color = try api.createMethod("ItemList", "set_item_custom_fg_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_custom_fg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_custom_fg_color, base, cargs, result);
    }

    pub fn setItemDisabled(self: *const Self, arg_idx: i32, arg_disabled: bool) !void {
        if (mbind_set_item_disabled == null) {
            mbind_set_item_disabled = try api.createMethod("ItemList", "set_item_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_disabled, base, cargs, result);
    }

    pub fn setItemIcon(self: *const Self, arg_idx: i32, arg_icon: *const godot.Texture) !void {
        if (mbind_set_item_icon == null) {
            mbind_set_item_icon = try api.createMethod("ItemList", "set_item_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_icon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_icon, base, cargs, result);
    }

    pub fn setItemIconModulate(self: *const Self, arg_idx: i32, arg_modulate: *const godot.Color) !void {
        if (mbind_set_item_icon_modulate == null) {
            mbind_set_item_icon_modulate = try api.createMethod("ItemList", "set_item_icon_modulate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_modulate),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_icon_modulate, base, cargs, result);
    }

    pub fn setItemIconRegion(self: *const Self, arg_idx: i32, arg_rect: *const godot.Rect2) !void {
        if (mbind_set_item_icon_region == null) {
            mbind_set_item_icon_region = try api.createMethod("ItemList", "set_item_icon_region");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_icon_region, base, cargs, result);
    }

    pub fn setItemIconTransposed(self: *const Self, arg_idx: i32, arg_transposed: bool) !void {
        if (mbind_set_item_icon_transposed == null) {
            mbind_set_item_icon_transposed = try api.createMethod("ItemList", "set_item_icon_transposed");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_transposed),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_icon_transposed, base, cargs, result);
    }

    pub fn setItemMetadata(self: *const Self, arg_idx: i32, arg_metadata: *const godot.Variant) !void {
        if (mbind_set_item_metadata == null) {
            mbind_set_item_metadata = try api.createMethod("ItemList", "set_item_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_metadata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_metadata, base, cargs, result);
    }

    pub fn setItemSelectable(self: *const Self, arg_idx: i32, arg_selectable: bool) !void {
        if (mbind_set_item_selectable == null) {
            mbind_set_item_selectable = try api.createMethod("ItemList", "set_item_selectable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_selectable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_selectable, base, cargs, result);
    }

    pub fn setItemText(self: *const Self, arg_idx: i32, arg_text: *const godot.String) !void {
        if (mbind_set_item_text == null) {
            mbind_set_item_text = try api.createMethod("ItemList", "set_item_text");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_text, base, cargs, result);
    }

    pub fn setItemTooltip(self: *const Self, arg_idx: i32, arg_tooltip: *const godot.String) !void {
        if (mbind_set_item_tooltip == null) {
            mbind_set_item_tooltip = try api.createMethod("ItemList", "set_item_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, arg_tooltip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_tooltip, base, cargs, result);
    }

    pub fn setItemTooltipEnabled(self: *const Self, arg_idx: i32, arg_enable: bool) !void {
        if (mbind_set_item_tooltip_enabled == null) {
            mbind_set_item_tooltip_enabled = try api.createMethod("ItemList", "set_item_tooltip_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_item_tooltip_enabled, base, cargs, result);
    }

    pub fn setMaxColumns(self: *const Self, arg_amount: i32) !void {
        if (mbind_set_max_columns == null) {
            mbind_set_max_columns = try api.createMethod("ItemList", "set_max_columns");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_max_columns, base, cargs, result);
    }

    pub fn setMaxTextLines(self: *const Self, arg_lines: i32) !void {
        if (mbind_set_max_text_lines == null) {
            mbind_set_max_text_lines = try api.createMethod("ItemList", "set_max_text_lines");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_lines),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_max_text_lines, base, cargs, result);
    }

    pub fn setSameColumnWidth(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_same_column_width == null) {
            mbind_set_same_column_width = try api.createMethod("ItemList", "set_same_column_width");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_same_column_width, base, cargs, result);
    }

    pub fn setSelectMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_select_mode == null) {
            mbind_set_select_mode = try api.createMethod("ItemList", "set_select_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_select_mode, base, cargs, result);
    }

    pub fn sortItemsByText(self: *const Self) !void {
        if (mbind_sort_items_by_text == null) {
            mbind_sort_items_by_text = try api.createMethod("ItemList", "sort_items_by_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_sort_items_by_text, base, cargs, result);
    }

    pub fn unselect(self: *const Self, arg_idx: i32) !void {
        if (mbind_unselect == null) {
            mbind_unselect = try api.createMethod("ItemList", "unselect");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unselect, base, cargs, result);
    }

    pub fn unselectAll(self: *const Self) !void {
        if (mbind_unselect_all == null) {
            mbind_unselect_all = try api.createMethod("ItemList", "unselect_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unselect_all, base, cargs, result);
    }
};