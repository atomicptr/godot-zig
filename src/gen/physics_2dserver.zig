// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Object = @import("object.zig").Object;

// method bindings
var mbind_area_add_shape: ?*c_api.godot_method_bind = null;
var mbind_area_attach_canvas_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_attach_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_clear_shapes: ?*c_api.godot_method_bind = null;
var mbind_area_create: ?*c_api.godot_method_bind = null;
var mbind_area_get_canvas_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_get_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_get_param: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape_count: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_area_get_space: ?*c_api.godot_method_bind = null;
var mbind_area_get_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_area_get_transform: ?*c_api.godot_method_bind = null;
var mbind_area_remove_shape: ?*c_api.godot_method_bind = null;
var mbind_area_set_area_monitor_callback: ?*c_api.godot_method_bind = null;
var mbind_area_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_area_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_area_set_monitor_callback: ?*c_api.godot_method_bind = null;
var mbind_area_set_monitorable: ?*c_api.godot_method_bind = null;
var mbind_area_set_param: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape_disabled: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_area_set_space: ?*c_api.godot_method_bind = null;
var mbind_area_set_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_area_set_transform: ?*c_api.godot_method_bind = null;
var mbind_body_add_central_force: ?*c_api.godot_method_bind = null;
var mbind_body_add_collision_exception: ?*c_api.godot_method_bind = null;
var mbind_body_add_force: ?*c_api.godot_method_bind = null;
var mbind_body_add_shape: ?*c_api.godot_method_bind = null;
var mbind_body_add_torque: ?*c_api.godot_method_bind = null;
var mbind_body_apply_central_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_apply_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_apply_torque_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_attach_canvas_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_attach_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_clear_shapes: ?*c_api.godot_method_bind = null;
var mbind_body_create: ?*c_api.godot_method_bind = null;
var mbind_body_get_canvas_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_get_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_body_get_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_body_get_continuous_collision_detection_mode: ?*c_api.godot_method_bind = null;
var mbind_body_get_direct_state: ?*c_api.godot_method_bind = null;
var mbind_body_get_max_contacts_reported: ?*c_api.godot_method_bind = null;
var mbind_body_get_mode: ?*c_api.godot_method_bind = null;
var mbind_body_get_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_get_param: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape_count: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape_metadata: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_body_get_space: ?*c_api.godot_method_bind = null;
var mbind_body_get_state: ?*c_api.godot_method_bind = null;
var mbind_body_is_omitting_force_integration: ?*c_api.godot_method_bind = null;
var mbind_body_remove_collision_exception: ?*c_api.godot_method_bind = null;
var mbind_body_remove_shape: ?*c_api.godot_method_bind = null;
var mbind_body_set_axis_velocity: ?*c_api.godot_method_bind = null;
var mbind_body_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_body_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_body_set_continuous_collision_detection_mode: ?*c_api.godot_method_bind = null;
var mbind_body_set_force_integration_callback: ?*c_api.godot_method_bind = null;
var mbind_body_set_max_contacts_reported: ?*c_api.godot_method_bind = null;
var mbind_body_set_mode: ?*c_api.godot_method_bind = null;
var mbind_body_set_omit_force_integration: ?*c_api.godot_method_bind = null;
var mbind_body_set_param: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_as_one_way_collision: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_disabled: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_metadata: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_body_set_space: ?*c_api.godot_method_bind = null;
var mbind_body_set_state: ?*c_api.godot_method_bind = null;
var mbind_body_test_motion: ?*c_api.godot_method_bind = null;
var mbind_capsule_shape_create: ?*c_api.godot_method_bind = null;
var mbind_circle_shape_create: ?*c_api.godot_method_bind = null;
var mbind_concave_polygon_shape_create: ?*c_api.godot_method_bind = null;
var mbind_convex_polygon_shape_create: ?*c_api.godot_method_bind = null;
var mbind_damped_spring_joint_create: ?*c_api.godot_method_bind = null;
var mbind_damped_string_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_damped_string_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_free_rid: ?*c_api.godot_method_bind = null;
var mbind_get_process_info: ?*c_api.godot_method_bind = null;
var mbind_groove_joint_create: ?*c_api.godot_method_bind = null;
var mbind_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_joint_get_type: ?*c_api.godot_method_bind = null;
var mbind_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_line_shape_create: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_create: ?*c_api.godot_method_bind = null;
var mbind_ray_shape_create: ?*c_api.godot_method_bind = null;
var mbind_rectangle_shape_create: ?*c_api.godot_method_bind = null;
var mbind_segment_shape_create: ?*c_api.godot_method_bind = null;
var mbind_set_active: ?*c_api.godot_method_bind = null;
var mbind_set_collision_iterations: ?*c_api.godot_method_bind = null;
var mbind_shape_get_data: ?*c_api.godot_method_bind = null;
var mbind_shape_get_type: ?*c_api.godot_method_bind = null;
var mbind_shape_set_data: ?*c_api.godot_method_bind = null;
var mbind_space_create: ?*c_api.godot_method_bind = null;
var mbind_space_get_direct_state: ?*c_api.godot_method_bind = null;
var mbind_space_get_param: ?*c_api.godot_method_bind = null;
var mbind_space_is_active: ?*c_api.godot_method_bind = null;
var mbind_space_set_active: ?*c_api.godot_method_bind = null;
var mbind_space_set_param: ?*c_api.godot_method_bind = null;
var mbind_physics_2dserver_constructor: ?fn () ?*c_api.godot_object = null;

pub const Physics2DServer = struct {
    const Self = @This();
    const BaseClass = Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_physics_2dserver_constructor == null) {
            mbind_physics_2dserver_constructor = try api.createConstructor("Physics2DServer");
        }
        return api.createObject(Self, mbind_physics_2dserver_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn areaAddShape(self: *const Self, arg_area: *const godot.RID, arg_shape: *const godot.RID, arg_transform: *const godot.Transform2D, arg_disabled: bool) !void {
        if (mbind_area_add_shape == null) {
            mbind_area_add_shape = try api.createMethod("Physics2DServer", "area_add_shape");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_add_shape, base, cargs, result);
    }

    pub fn areaAttachCanvasInstanceId(self: *const Self, arg_area: *const godot.RID, arg_id: i32) !void {
        if (mbind_area_attach_canvas_instance_id == null) {
            mbind_area_attach_canvas_instance_id = try api.createMethod("Physics2DServer", "area_attach_canvas_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_attach_canvas_instance_id, base, cargs, result);
    }

    pub fn areaAttachObjectInstanceId(self: *const Self, arg_area: *const godot.RID, arg_id: i32) !void {
        if (mbind_area_attach_object_instance_id == null) {
            mbind_area_attach_object_instance_id = try api.createMethod("Physics2DServer", "area_attach_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_attach_object_instance_id, base, cargs, result);
    }

    pub fn areaClearShapes(self: *const Self, arg_area: *const godot.RID) !void {
        if (mbind_area_clear_shapes == null) {
            mbind_area_clear_shapes = try api.createMethod("Physics2DServer", "area_clear_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_clear_shapes, base, cargs, result);
    }

    pub fn areaCreate(self: *const Self) !godot.RID {
        if (mbind_area_create == null) {
            mbind_area_create = try api.createMethod("Physics2DServer", "area_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetCanvasInstanceId(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_canvas_instance_id == null) {
            mbind_area_get_canvas_instance_id = try api.createMethod("Physics2DServer", "area_get_canvas_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_canvas_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetObjectInstanceId(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_object_instance_id == null) {
            mbind_area_get_object_instance_id = try api.createMethod("Physics2DServer", "area_get_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_object_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetParam(self: *const Self, arg_area: *const godot.RID, arg_param: i32) !godot.Variant {
        if (mbind_area_get_param == null) {
            mbind_area_get_param = try api.createMethod("Physics2DServer", "area_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_param, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn areaGetShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !godot.RID {
        if (mbind_area_get_shape == null) {
            mbind_area_get_shape = try api.createMethod("Physics2DServer", "area_get_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetShapeCount(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_shape_count == null) {
            mbind_area_get_shape_count = try api.createMethod("Physics2DServer", "area_get_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetShapeTransform(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !godot.Transform2D {
        if (mbind_area_get_shape_transform == null) {
            mbind_area_get_shape_transform = try api.createMethod("Physics2DServer", "area_get_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn areaGetSpace(self: *const Self, arg_area: *const godot.RID) !godot.RID {
        if (mbind_area_get_space == null) {
            mbind_area_get_space = try api.createMethod("Physics2DServer", "area_get_space");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_space, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetSpaceOverrideMode(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_space_override_mode == null) {
            mbind_area_get_space_override_mode = try api.createMethod("Physics2DServer", "area_get_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_space_override_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetTransform(self: *const Self, arg_area: *const godot.RID) !godot.Transform2D {
        if (mbind_area_get_transform == null) {
            mbind_area_get_transform = try api.createMethod("Physics2DServer", "area_get_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn areaRemoveShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !void {
        if (mbind_area_remove_shape == null) {
            mbind_area_remove_shape = try api.createMethod("Physics2DServer", "area_remove_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_remove_shape, base, cargs, result);
    }

    pub fn areaSetAreaMonitorCallback(self: *const Self, arg_area: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String) !void {
        if (mbind_area_set_area_monitor_callback == null) {
            mbind_area_set_area_monitor_callback = try api.createMethod("Physics2DServer", "area_set_area_monitor_callback");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_area_monitor_callback, base, cargs, result);
    }

    pub fn areaSetCollisionLayer(self: *const Self, arg_area: *const godot.RID, arg_layer: i32) !void {
        if (mbind_area_set_collision_layer == null) {
            mbind_area_set_collision_layer = try api.createMethod("Physics2DServer", "area_set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_collision_layer, base, cargs, result);
    }

    pub fn areaSetCollisionMask(self: *const Self, arg_area: *const godot.RID, arg_mask: i32) !void {
        if (mbind_area_set_collision_mask == null) {
            mbind_area_set_collision_mask = try api.createMethod("Physics2DServer", "area_set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_collision_mask, base, cargs, result);
    }

    pub fn areaSetMonitorCallback(self: *const Self, arg_area: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String) !void {
        if (mbind_area_set_monitor_callback == null) {
            mbind_area_set_monitor_callback = try api.createMethod("Physics2DServer", "area_set_monitor_callback");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_monitor_callback, base, cargs, result);
    }

    pub fn areaSetMonitorable(self: *const Self, arg_area: *const godot.RID, arg_monitorable: bool) !void {
        if (mbind_area_set_monitorable == null) {
            mbind_area_set_monitorable = try api.createMethod("Physics2DServer", "area_set_monitorable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_monitorable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_monitorable, base, cargs, result);
    }

    pub fn areaSetParam(self: *const Self, arg_area: *const godot.RID, arg_param: i32, arg_value: *const godot.Variant) !void {
        if (mbind_area_set_param == null) {
            mbind_area_set_param = try api.createMethod("Physics2DServer", "area_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_param, base, cargs, result);
    }

    pub fn areaSetShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_shape: *const godot.RID) !void {
        if (mbind_area_set_shape == null) {
            mbind_area_set_shape = try api.createMethod("Physics2DServer", "area_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape, base, cargs, result);
    }

    pub fn areaSetShapeDisabled(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_disabled: bool) !void {
        if (mbind_area_set_shape_disabled == null) {
            mbind_area_set_shape_disabled = try api.createMethod("Physics2DServer", "area_set_shape_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape_disabled, base, cargs, result);
    }

    pub fn areaSetShapeTransform(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_transform: *const godot.Transform2D) !void {
        if (mbind_area_set_shape_transform == null) {
            mbind_area_set_shape_transform = try api.createMethod("Physics2DServer", "area_set_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape_transform, base, cargs, result);
    }

    pub fn areaSetSpace(self: *const Self, arg_area: *const godot.RID, arg_space: *const godot.RID) !void {
        if (mbind_area_set_space == null) {
            mbind_area_set_space = try api.createMethod("Physics2DServer", "area_set_space");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_space, base, cargs, result);
    }

    pub fn areaSetSpaceOverrideMode(self: *const Self, arg_area: *const godot.RID, arg_mode: i32) !void {
        if (mbind_area_set_space_override_mode == null) {
            mbind_area_set_space_override_mode = try api.createMethod("Physics2DServer", "area_set_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_space_override_mode, base, cargs, result);
    }

    pub fn areaSetTransform(self: *const Self, arg_area: *const godot.RID, arg_transform: *const godot.Transform2D) !void {
        if (mbind_area_set_transform == null) {
            mbind_area_set_transform = try api.createMethod("Physics2DServer", "area_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_transform, base, cargs, result);
    }

    pub fn bodyAddCentralForce(self: *const Self, arg_body: *const godot.RID, arg_force: *const godot.Vector2) !void {
        if (mbind_body_add_central_force == null) {
            mbind_body_add_central_force = try api.createMethod("Physics2DServer", "body_add_central_force");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_force),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_central_force, base, cargs, result);
    }

    pub fn bodyAddCollisionException(self: *const Self, arg_body: *const godot.RID, arg_excepted_body: *const godot.RID) !void {
        if (mbind_body_add_collision_exception == null) {
            mbind_body_add_collision_exception = try api.createMethod("Physics2DServer", "body_add_collision_exception");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_excepted_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_collision_exception, base, cargs, result);
    }

    pub fn bodyAddForce(self: *const Self, arg_body: *const godot.RID, arg_offset: *const godot.Vector2, arg_force: *const godot.Vector2) !void {
        if (mbind_body_add_force == null) {
            mbind_body_add_force = try api.createMethod("Physics2DServer", "body_add_force");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_offset),
            @ptrCast(*const anyopaque, arg_force),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_force, base, cargs, result);
    }

    pub fn bodyAddShape(self: *const Self, arg_body: *const godot.RID, arg_shape: *const godot.RID, arg_transform: *const godot.Transform2D, arg_disabled: bool) !void {
        if (mbind_body_add_shape == null) {
            mbind_body_add_shape = try api.createMethod("Physics2DServer", "body_add_shape");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_shape, base, cargs, result);
    }

    pub fn bodyAddTorque(self: *const Self, arg_body: *const godot.RID, arg_torque: f32) !void {
        if (mbind_body_add_torque == null) {
            mbind_body_add_torque = try api.createMethod("Physics2DServer", "body_add_torque");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_torque),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_torque, base, cargs, result);
    }

    pub fn bodyApplyCentralImpulse(self: *const Self, arg_body: *const godot.RID, arg_impulse: *const godot.Vector2) !void {
        if (mbind_body_apply_central_impulse == null) {
            mbind_body_apply_central_impulse = try api.createMethod("Physics2DServer", "body_apply_central_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_central_impulse, base, cargs, result);
    }

    pub fn bodyApplyImpulse(self: *const Self, arg_body: *const godot.RID, arg_position: *const godot.Vector2, arg_impulse: *const godot.Vector2) !void {
        if (mbind_body_apply_impulse == null) {
            mbind_body_apply_impulse = try api.createMethod("Physics2DServer", "body_apply_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_impulse, base, cargs, result);
    }

    pub fn bodyApplyTorqueImpulse(self: *const Self, arg_body: *const godot.RID, arg_impulse: f32) !void {
        if (mbind_body_apply_torque_impulse == null) {
            mbind_body_apply_torque_impulse = try api.createMethod("Physics2DServer", "body_apply_torque_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_torque_impulse, base, cargs, result);
    }

    pub fn bodyAttachCanvasInstanceId(self: *const Self, arg_body: *const godot.RID, arg_id: i32) !void {
        if (mbind_body_attach_canvas_instance_id == null) {
            mbind_body_attach_canvas_instance_id = try api.createMethod("Physics2DServer", "body_attach_canvas_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_attach_canvas_instance_id, base, cargs, result);
    }

    pub fn bodyAttachObjectInstanceId(self: *const Self, arg_body: *const godot.RID, arg_id: i32) !void {
        if (mbind_body_attach_object_instance_id == null) {
            mbind_body_attach_object_instance_id = try api.createMethod("Physics2DServer", "body_attach_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_attach_object_instance_id, base, cargs, result);
    }

    pub fn bodyClearShapes(self: *const Self, arg_body: *const godot.RID) !void {
        if (mbind_body_clear_shapes == null) {
            mbind_body_clear_shapes = try api.createMethod("Physics2DServer", "body_clear_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_clear_shapes, base, cargs, result);
    }

    pub fn bodyCreate(self: *const Self) !godot.RID {
        if (mbind_body_create == null) {
            mbind_body_create = try api.createMethod("Physics2DServer", "body_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetCanvasInstanceId(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_canvas_instance_id == null) {
            mbind_body_get_canvas_instance_id = try api.createMethod("Physics2DServer", "body_get_canvas_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_canvas_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetCollisionLayer(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_collision_layer == null) {
            mbind_body_get_collision_layer = try api.createMethod("Physics2DServer", "body_get_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_collision_layer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetCollisionMask(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_collision_mask == null) {
            mbind_body_get_collision_mask = try api.createMethod("Physics2DServer", "body_get_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_collision_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetContinuousCollisionDetectionMode(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_continuous_collision_detection_mode == null) {
            mbind_body_get_continuous_collision_detection_mode = try api.createMethod("Physics2DServer", "body_get_continuous_collision_detection_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_continuous_collision_detection_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetDirectState(self: *const Self, arg_body: *const godot.RID) !godot.Physics2DDirectBodyState {
        if (mbind_body_get_direct_state == null) {
            mbind_body_get_direct_state = try api.createMethod("Physics2DServer", "body_get_direct_state");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_direct_state, base, cargs, result);
        return @ptrCast(*godot.Physics2DDirectBodyState, @alignCast(@alignOf(&godot.Physics2DDirectBodyState), result)).*;
    }

    pub fn bodyGetMaxContactsReported(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_max_contacts_reported == null) {
            mbind_body_get_max_contacts_reported = try api.createMethod("Physics2DServer", "body_get_max_contacts_reported");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_max_contacts_reported, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetMode(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_mode == null) {
            mbind_body_get_mode = try api.createMethod("Physics2DServer", "body_get_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetObjectInstanceId(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_object_instance_id == null) {
            mbind_body_get_object_instance_id = try api.createMethod("Physics2DServer", "body_get_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_object_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetParam(self: *const Self, arg_body: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_body_get_param == null) {
            mbind_body_get_param = try api.createMethod("Physics2DServer", "body_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn bodyGetShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !godot.RID {
        if (mbind_body_get_shape == null) {
            mbind_body_get_shape = try api.createMethod("Physics2DServer", "body_get_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetShapeCount(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_shape_count == null) {
            mbind_body_get_shape_count = try api.createMethod("Physics2DServer", "body_get_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetShapeMetadata(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !godot.Variant {
        if (mbind_body_get_shape_metadata == null) {
            mbind_body_get_shape_metadata = try api.createMethod("Physics2DServer", "body_get_shape_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape_metadata, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn bodyGetShapeTransform(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !godot.Transform2D {
        if (mbind_body_get_shape_transform == null) {
            mbind_body_get_shape_transform = try api.createMethod("Physics2DServer", "body_get_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn bodyGetSpace(self: *const Self, arg_body: *const godot.RID) !godot.RID {
        if (mbind_body_get_space == null) {
            mbind_body_get_space = try api.createMethod("Physics2DServer", "body_get_space");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_space, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetState(self: *const Self, arg_body: *const godot.RID, arg_state: i32) !godot.Variant {
        if (mbind_body_get_state == null) {
            mbind_body_get_state = try api.createMethod("Physics2DServer", "body_get_state");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_state),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_state, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn bodyIsOmittingForceIntegration(self: *const Self, arg_body: *const godot.RID) !bool {
        if (mbind_body_is_omitting_force_integration == null) {
            mbind_body_is_omitting_force_integration = try api.createMethod("Physics2DServer", "body_is_omitting_force_integration");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_is_omitting_force_integration, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn bodyRemoveCollisionException(self: *const Self, arg_body: *const godot.RID, arg_excepted_body: *const godot.RID) !void {
        if (mbind_body_remove_collision_exception == null) {
            mbind_body_remove_collision_exception = try api.createMethod("Physics2DServer", "body_remove_collision_exception");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_excepted_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_remove_collision_exception, base, cargs, result);
    }

    pub fn bodyRemoveShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !void {
        if (mbind_body_remove_shape == null) {
            mbind_body_remove_shape = try api.createMethod("Physics2DServer", "body_remove_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_remove_shape, base, cargs, result);
    }

    pub fn bodySetAxisVelocity(self: *const Self, arg_body: *const godot.RID, arg_axis_velocity: *const godot.Vector2) !void {
        if (mbind_body_set_axis_velocity == null) {
            mbind_body_set_axis_velocity = try api.createMethod("Physics2DServer", "body_set_axis_velocity");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_axis_velocity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_axis_velocity, base, cargs, result);
    }

    pub fn bodySetCollisionLayer(self: *const Self, arg_body: *const godot.RID, arg_layer: i32) !void {
        if (mbind_body_set_collision_layer == null) {
            mbind_body_set_collision_layer = try api.createMethod("Physics2DServer", "body_set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_collision_layer, base, cargs, result);
    }

    pub fn bodySetCollisionMask(self: *const Self, arg_body: *const godot.RID, arg_mask: i32) !void {
        if (mbind_body_set_collision_mask == null) {
            mbind_body_set_collision_mask = try api.createMethod("Physics2DServer", "body_set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_collision_mask, base, cargs, result);
    }

    pub fn bodySetContinuousCollisionDetectionMode(self: *const Self, arg_body: *const godot.RID, arg_mode: i32) !void {
        if (mbind_body_set_continuous_collision_detection_mode == null) {
            mbind_body_set_continuous_collision_detection_mode = try api.createMethod("Physics2DServer", "body_set_continuous_collision_detection_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_continuous_collision_detection_mode, base, cargs, result);
    }

    pub fn bodySetForceIntegrationCallback(self: *const Self, arg_body: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String, arg_userdata: *const godot.Variant) !void {
        if (mbind_body_set_force_integration_callback == null) {
            mbind_body_set_force_integration_callback = try api.createMethod("Physics2DServer", "body_set_force_integration_callback");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_userdata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_force_integration_callback, base, cargs, result);
    }

    pub fn bodySetMaxContactsReported(self: *const Self, arg_body: *const godot.RID, arg_amount: i32) !void {
        if (mbind_body_set_max_contacts_reported == null) {
            mbind_body_set_max_contacts_reported = try api.createMethod("Physics2DServer", "body_set_max_contacts_reported");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_max_contacts_reported, base, cargs, result);
    }

    pub fn bodySetMode(self: *const Self, arg_body: *const godot.RID, arg_mode: i32) !void {
        if (mbind_body_set_mode == null) {
            mbind_body_set_mode = try api.createMethod("Physics2DServer", "body_set_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_mode, base, cargs, result);
    }

    pub fn bodySetOmitForceIntegration(self: *const Self, arg_body: *const godot.RID, arg_enable: bool) !void {
        if (mbind_body_set_omit_force_integration == null) {
            mbind_body_set_omit_force_integration = try api.createMethod("Physics2DServer", "body_set_omit_force_integration");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_omit_force_integration, base, cargs, result);
    }

    pub fn bodySetParam(self: *const Self, arg_body: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_body_set_param == null) {
            mbind_body_set_param = try api.createMethod("Physics2DServer", "body_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_param, base, cargs, result);
    }

    pub fn bodySetShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_shape: *const godot.RID) !void {
        if (mbind_body_set_shape == null) {
            mbind_body_set_shape = try api.createMethod("Physics2DServer", "body_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape, base, cargs, result);
    }

    pub fn bodySetShapeAsOneWayCollision(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_enable: bool, arg_margin: f32) !void {
        if (mbind_body_set_shape_as_one_way_collision == null) {
            mbind_body_set_shape_as_one_way_collision = try api.createMethod("Physics2DServer", "body_set_shape_as_one_way_collision");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_as_one_way_collision, base, cargs, result);
    }

    pub fn bodySetShapeDisabled(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_disabled: bool) !void {
        if (mbind_body_set_shape_disabled == null) {
            mbind_body_set_shape_disabled = try api.createMethod("Physics2DServer", "body_set_shape_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_disabled, base, cargs, result);
    }

    pub fn bodySetShapeMetadata(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_metadata: *const godot.Variant) !void {
        if (mbind_body_set_shape_metadata == null) {
            mbind_body_set_shape_metadata = try api.createMethod("Physics2DServer", "body_set_shape_metadata");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_metadata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_metadata, base, cargs, result);
    }

    pub fn bodySetShapeTransform(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_transform: *const godot.Transform2D) !void {
        if (mbind_body_set_shape_transform == null) {
            mbind_body_set_shape_transform = try api.createMethod("Physics2DServer", "body_set_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_transform, base, cargs, result);
    }

    pub fn bodySetSpace(self: *const Self, arg_body: *const godot.RID, arg_space: *const godot.RID) !void {
        if (mbind_body_set_space == null) {
            mbind_body_set_space = try api.createMethod("Physics2DServer", "body_set_space");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_space, base, cargs, result);
    }

    pub fn bodySetState(self: *const Self, arg_body: *const godot.RID, arg_state: i32, arg_value: *const godot.Variant) !void {
        if (mbind_body_set_state == null) {
            mbind_body_set_state = try api.createMethod("Physics2DServer", "body_set_state");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_state),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_state, base, cargs, result);
    }

    pub fn bodyTestMotion(self: *const Self, arg_body: *const godot.RID, arg_from: *const godot.Transform2D, arg_motion: *const godot.Vector2, arg_infinite_inertia: bool, arg_margin: f32, arg_result: *const godot.Physics2DTestMotionResult, arg_exclude_raycast_shapes: bool, arg_exclude: *const godot.Array) !bool {
        if (mbind_body_test_motion == null) {
            mbind_body_test_motion = try api.createMethod("Physics2DServer", "body_test_motion");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_motion),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, arg_result),
            @ptrCast(*const anyopaque, *arg_exclude_raycast_shapes),
            @ptrCast(*const anyopaque, arg_exclude),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_test_motion, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn capsuleShapeCreate(self: *const Self) !godot.RID {
        if (mbind_capsule_shape_create == null) {
            mbind_capsule_shape_create = try api.createMethod("Physics2DServer", "capsule_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_capsule_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn circleShapeCreate(self: *const Self) !godot.RID {
        if (mbind_circle_shape_create == null) {
            mbind_circle_shape_create = try api.createMethod("Physics2DServer", "circle_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_circle_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn concavePolygonShapeCreate(self: *const Self) !godot.RID {
        if (mbind_concave_polygon_shape_create == null) {
            mbind_concave_polygon_shape_create = try api.createMethod("Physics2DServer", "concave_polygon_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_concave_polygon_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn convexPolygonShapeCreate(self: *const Self) !godot.RID {
        if (mbind_convex_polygon_shape_create == null) {
            mbind_convex_polygon_shape_create = try api.createMethod("Physics2DServer", "convex_polygon_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_convex_polygon_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn dampedSpringJointCreate(self: *const Self, arg_anchor_a: *const godot.Vector2, arg_anchor_b: *const godot.Vector2, arg_body_a: *const godot.RID, arg_body_b: *const godot.RID) !godot.RID {
        if (mbind_damped_spring_joint_create == null) {
            mbind_damped_spring_joint_create = try api.createMethod("Physics2DServer", "damped_spring_joint_create");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_anchor_a),
            @ptrCast(*const anyopaque, arg_anchor_b),
            @ptrCast(*const anyopaque, arg_body_a),
            @ptrCast(*const anyopaque, arg_body_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_damped_spring_joint_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn dampedStringJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_damped_string_joint_get_param == null) {
            mbind_damped_string_joint_get_param = try api.createMethod("Physics2DServer", "damped_string_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_damped_string_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn dampedStringJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_damped_string_joint_set_param == null) {
            mbind_damped_string_joint_set_param = try api.createMethod("Physics2DServer", "damped_string_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_damped_string_joint_set_param, base, cargs, result);
    }

    pub fn freeRid(self: *const Self, arg_rid: *const godot.RID) !void {
        if (mbind_free_rid == null) {
            mbind_free_rid = try api.createMethod("Physics2DServer", "free_rid");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rid),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_free_rid, base, cargs, result);
    }

    pub fn getProcessInfo(self: *const Self, arg_process_info: i32) !i32 {
        if (mbind_get_process_info == null) {
            mbind_get_process_info = try api.createMethod("Physics2DServer", "get_process_info");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_process_info),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_process_info, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn grooveJointCreate(self: *const Self, arg_groove1_a: *const godot.Vector2, arg_groove2_a: *const godot.Vector2, arg_anchor_b: *const godot.Vector2, arg_body_a: *const godot.RID, arg_body_b: *const godot.RID) !godot.RID {
        if (mbind_groove_joint_create == null) {
            mbind_groove_joint_create = try api.createMethod("Physics2DServer", "groove_joint_create");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_groove1_a),
            @ptrCast(*const anyopaque, arg_groove2_a),
            @ptrCast(*const anyopaque, arg_anchor_b),
            @ptrCast(*const anyopaque, arg_body_a),
            @ptrCast(*const anyopaque, arg_body_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_groove_joint_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_joint_get_param == null) {
            mbind_joint_get_param = try api.createMethod("Physics2DServer", "joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn jointGetType(self: *const Self, arg_joint: *const godot.RID) !i32 {
        if (mbind_joint_get_type == null) {
            mbind_joint_get_type = try api.createMethod("Physics2DServer", "joint_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn jointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_joint_set_param == null) {
            mbind_joint_set_param = try api.createMethod("Physics2DServer", "joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_set_param, base, cargs, result);
    }

    pub fn lineShapeCreate(self: *const Self) !godot.RID {
        if (mbind_line_shape_create == null) {
            mbind_line_shape_create = try api.createMethod("Physics2DServer", "line_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_line_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn pinJointCreate(self: *const Self, arg_anchor: *const godot.Vector2, arg_body_a: *const godot.RID, arg_body_b: *const godot.RID) !godot.RID {
        if (mbind_pin_joint_create == null) {
            mbind_pin_joint_create = try api.createMethod("Physics2DServer", "pin_joint_create");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_anchor),
            @ptrCast(*const anyopaque, arg_body_a),
            @ptrCast(*const anyopaque, arg_body_b),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn rayShapeCreate(self: *const Self) !godot.RID {
        if (mbind_ray_shape_create == null) {
            mbind_ray_shape_create = try api.createMethod("Physics2DServer", "ray_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_ray_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn rectangleShapeCreate(self: *const Self) !godot.RID {
        if (mbind_rectangle_shape_create == null) {
            mbind_rectangle_shape_create = try api.createMethod("Physics2DServer", "rectangle_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rectangle_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn segmentShapeCreate(self: *const Self) !godot.RID {
        if (mbind_segment_shape_create == null) {
            mbind_segment_shape_create = try api.createMethod("Physics2DServer", "segment_shape_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_segment_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn setActive(self: *const Self, arg_active: bool) !void {
        if (mbind_set_active == null) {
            mbind_set_active = try api.createMethod("Physics2DServer", "set_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_active, base, cargs, result);
    }

    pub fn setCollisionIterations(self: *const Self, arg_iterations: i32) !void {
        if (mbind_set_collision_iterations == null) {
            mbind_set_collision_iterations = try api.createMethod("Physics2DServer", "set_collision_iterations");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_iterations),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_iterations, base, cargs, result);
    }

    pub fn shapeGetData(self: *const Self, arg_shape: *const godot.RID) !godot.Variant {
        if (mbind_shape_get_data == null) {
            mbind_shape_get_data = try api.createMethod("Physics2DServer", "shape_get_data");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_get_data, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn shapeGetType(self: *const Self, arg_shape: *const godot.RID) !i32 {
        if (mbind_shape_get_type == null) {
            mbind_shape_get_type = try api.createMethod("Physics2DServer", "shape_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn shapeSetData(self: *const Self, arg_shape: *const godot.RID, arg_data: *const godot.Variant) !void {
        if (mbind_shape_set_data == null) {
            mbind_shape_set_data = try api.createMethod("Physics2DServer", "shape_set_data");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_set_data, base, cargs, result);
    }

    pub fn spaceCreate(self: *const Self) !godot.RID {
        if (mbind_space_create == null) {
            mbind_space_create = try api.createMethod("Physics2DServer", "space_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn spaceGetDirectState(self: *const Self, arg_space: *const godot.RID) !godot.Physics2DDirectSpaceState {
        if (mbind_space_get_direct_state == null) {
            mbind_space_get_direct_state = try api.createMethod("Physics2DServer", "space_get_direct_state");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_get_direct_state, base, cargs, result);
        return @ptrCast(*godot.Physics2DDirectSpaceState, @alignCast(@alignOf(&godot.Physics2DDirectSpaceState), result)).*;
    }

    pub fn spaceGetParam(self: *const Self, arg_space: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_space_get_param == null) {
            mbind_space_get_param = try api.createMethod("Physics2DServer", "space_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn spaceIsActive(self: *const Self, arg_space: *const godot.RID) !bool {
        if (mbind_space_is_active == null) {
            mbind_space_is_active = try api.createMethod("Physics2DServer", "space_is_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_is_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn spaceSetActive(self: *const Self, arg_space: *const godot.RID, arg_active: bool) !void {
        if (mbind_space_set_active == null) {
            mbind_space_set_active = try api.createMethod("Physics2DServer", "space_set_active");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_set_active, base, cargs, result);
    }

    pub fn spaceSetParam(self: *const Self, arg_space: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_space_set_param == null) {
            mbind_space_set_param = try api.createMethod("Physics2DServer", "space_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_set_param, base, cargs, result);
    }
};