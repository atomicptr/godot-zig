// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Reference = @import("reference.zig").Reference;

// method bindings
var mbind_constant_time_compare: ?*c_api.godot_method_bind = null;
var mbind_decrypt: ?*c_api.godot_method_bind = null;
var mbind_encrypt: ?*c_api.godot_method_bind = null;
var mbind_generate_random_bytes: ?*c_api.godot_method_bind = null;
var mbind_generate_rsa: ?*c_api.godot_method_bind = null;
var mbind_generate_self_signed_certificate: ?*c_api.godot_method_bind = null;
var mbind_hmac_digest: ?*c_api.godot_method_bind = null;
var mbind_sign: ?*c_api.godot_method_bind = null;
var mbind_verify: ?*c_api.godot_method_bind = null;
var mbind_crypto_constructor: ?fn () ?*c_api.godot_object = null;

pub const Crypto = struct {
    const Self = @This();
    const BaseClass = Reference;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_crypto_constructor == null) {
            mbind_crypto_constructor = try api.createConstructor("Crypto");
        }
        return api.createObject(Self, mbind_crypto_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn constantTimeCompare(self: *const Self, arg_trusted: *const godot.PoolByteArray, arg_received: *const godot.PoolByteArray) !bool {
        if (mbind_constant_time_compare == null) {
            mbind_constant_time_compare = try api.createMethod("Crypto", "constant_time_compare");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_trusted),
            @ptrCast(*const anyopaque, arg_received),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_constant_time_compare, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn decrypt(self: *const Self, arg_key: *const godot.CryptoKey, arg_ciphertext: *const godot.PoolByteArray) !godot.PoolByteArray {
        if (mbind_decrypt == null) {
            mbind_decrypt = try api.createMethod("Crypto", "decrypt");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_key),
            @ptrCast(*const anyopaque, arg_ciphertext),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_decrypt, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn encrypt(self: *const Self, arg_key: *const godot.CryptoKey, arg_plaintext: *const godot.PoolByteArray) !godot.PoolByteArray {
        if (mbind_encrypt == null) {
            mbind_encrypt = try api.createMethod("Crypto", "encrypt");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_key),
            @ptrCast(*const anyopaque, arg_plaintext),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_encrypt, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn generateRandomBytes(self: *const Self, arg_size: i32) !godot.PoolByteArray {
        if (mbind_generate_random_bytes == null) {
            mbind_generate_random_bytes = try api.createMethod("Crypto", "generate_random_bytes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generate_random_bytes, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn generateRsa(self: *const Self, arg_size: i32) !godot.CryptoKey {
        if (mbind_generate_rsa == null) {
            mbind_generate_rsa = try api.createMethod("Crypto", "generate_rsa");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generate_rsa, base, cargs, result);
        return @ptrCast(*godot.CryptoKey, @alignCast(@alignOf(&godot.CryptoKey), result)).*;
    }

    pub fn generateSelfSignedCertificate(self: *const Self, arg_key: *const godot.CryptoKey, arg_issuer_name: *const godot.String, arg_not_before: *const godot.String, arg_not_after: *const godot.String) !godot.X509Certificate {
        if (mbind_generate_self_signed_certificate == null) {
            mbind_generate_self_signed_certificate = try api.createMethod("Crypto", "generate_self_signed_certificate");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_key),
            @ptrCast(*const anyopaque, arg_issuer_name),
            @ptrCast(*const anyopaque, arg_not_before),
            @ptrCast(*const anyopaque, arg_not_after),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generate_self_signed_certificate, base, cargs, result);
        return @ptrCast(*godot.X509Certificate, @alignCast(@alignOf(&godot.X509Certificate), result)).*;
    }

    pub fn hmacDigest(self: *const Self, arg_hash_type: i32, arg_key: *const godot.PoolByteArray, arg_msg: *const godot.PoolByteArray) !godot.PoolByteArray {
        if (mbind_hmac_digest == null) {
            mbind_hmac_digest = try api.createMethod("Crypto", "hmac_digest");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_hash_type),
            @ptrCast(*const anyopaque, arg_key),
            @ptrCast(*const anyopaque, arg_msg),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hmac_digest, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn sign(self: *const Self, arg_hash_type: i32, arg_hash: *const godot.PoolByteArray, arg_key: *const godot.CryptoKey) !godot.PoolByteArray {
        if (mbind_sign == null) {
            mbind_sign = try api.createMethod("Crypto", "sign");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_hash_type),
            @ptrCast(*const anyopaque, arg_hash),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_sign, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn verify(self: *const Self, arg_hash_type: i32, arg_hash: *const godot.PoolByteArray, arg_signature: *const godot.PoolByteArray, arg_key: *const godot.CryptoKey) !bool {
        if (mbind_verify == null) {
            mbind_verify = try api.createMethod("Crypto", "verify");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_hash_type),
            @ptrCast(*const anyopaque, arg_hash),
            @ptrCast(*const anyopaque, arg_signature),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_verify, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }
};