// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_follow_method: ?*c_api.godot_method_bind = null;
var mbind_follow_property: ?*c_api.godot_method_bind = null;
var mbind_get_runtime: ?*c_api.godot_method_bind = null;
var mbind_get_speed_scale: ?*c_api.godot_method_bind = null;
var mbind_get_tween_process_mode: ?*c_api.godot_method_bind = null;
var mbind_interpolate_callback: ?*c_api.godot_method_bind = null;
var mbind_interpolate_deferred_callback: ?*c_api.godot_method_bind = null;
var mbind_interpolate_method: ?*c_api.godot_method_bind = null;
var mbind_interpolate_property: ?*c_api.godot_method_bind = null;
var mbind_is_active: ?*c_api.godot_method_bind = null;
var mbind_is_repeat: ?*c_api.godot_method_bind = null;
var mbind_remove: ?*c_api.godot_method_bind = null;
var mbind_remove_all: ?*c_api.godot_method_bind = null;
var mbind_reset: ?*c_api.godot_method_bind = null;
var mbind_reset_all: ?*c_api.godot_method_bind = null;
var mbind_resume: ?*c_api.godot_method_bind = null;
var mbind_resume_all: ?*c_api.godot_method_bind = null;
var mbind_seek: ?*c_api.godot_method_bind = null;
var mbind_set_active: ?*c_api.godot_method_bind = null;
var mbind_set_repeat: ?*c_api.godot_method_bind = null;
var mbind_set_speed_scale: ?*c_api.godot_method_bind = null;
var mbind_set_tween_process_mode: ?*c_api.godot_method_bind = null;
var mbind_start: ?*c_api.godot_method_bind = null;
var mbind_stop: ?*c_api.godot_method_bind = null;
var mbind_stop_all: ?*c_api.godot_method_bind = null;
var mbind_targeting_method: ?*c_api.godot_method_bind = null;
var mbind_targeting_property: ?*c_api.godot_method_bind = null;
var mbind_tell: ?*c_api.godot_method_bind = null;
var mbind_tween_constructor: ?fn () ?*c_api.godot_object = null;

pub const Tween = struct {
    const Self = @This();
    pub const BaseClass = godot.Node;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_tween_constructor == null) {
            mbind_tween_constructor = try api.createConstructor("Tween");
        }
        return api.createObject(Self, mbind_tween_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn followMethod(self: *const Self, arg_object: *const godot.Object, arg_method: *const godot.String, arg_initial_val: *const godot.Variant, arg_target: *const godot.Object, arg_target_method: *const godot.String, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_follow_method == null) {
            mbind_follow_method = try api.createMethod("Tween", "follow_method");
        }

        var result: ?*anyopaque = null;
        var args: [9]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_initial_val),
            @ptrCast(*const anyopaque, arg_target),
            @ptrCast(*const anyopaque, arg_target_method),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_follow_method, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn followProperty(self: *const Self, arg_object: *const godot.Object, arg_property: *const godot.NodePath, arg_initial_val: *const godot.Variant, arg_target: *const godot.Object, arg_target_property: *const godot.NodePath, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_follow_property == null) {
            mbind_follow_property = try api.createMethod("Tween", "follow_property");
        }

        var result: ?*anyopaque = null;
        var args: [9]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_initial_val),
            @ptrCast(*const anyopaque, arg_target),
            @ptrCast(*const anyopaque, arg_target_property),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_follow_property, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getRuntime(self: *const Self) !f32 {
        if (mbind_get_runtime == null) {
            mbind_get_runtime = try api.createMethod("Tween", "get_runtime");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_runtime, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSpeedScale(self: *const Self) !f32 {
        if (mbind_get_speed_scale == null) {
            mbind_get_speed_scale = try api.createMethod("Tween", "get_speed_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_speed_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getTweenProcessMode(self: *const Self) !i32 {
        if (mbind_get_tween_process_mode == null) {
            mbind_get_tween_process_mode = try api.createMethod("Tween", "get_tween_process_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tween_process_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn interpolateCallback(self: *const Self, arg_object: *const godot.Object, arg_duration: f32, arg_callback: *const godot.String, arg_arg1: *const godot.Variant, arg_arg2: *const godot.Variant, arg_arg3: *const godot.Variant, arg_arg4: *const godot.Variant, arg_arg5: *const godot.Variant) !bool {
        if (mbind_interpolate_callback == null) {
            mbind_interpolate_callback = try api.createMethod("Tween", "interpolate_callback");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, arg_callback),
            @ptrCast(*const anyopaque, arg_arg1),
            @ptrCast(*const anyopaque, arg_arg2),
            @ptrCast(*const anyopaque, arg_arg3),
            @ptrCast(*const anyopaque, arg_arg4),
            @ptrCast(*const anyopaque, arg_arg5),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_interpolate_callback, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn interpolateDeferredCallback(self: *const Self, arg_object: *const godot.Object, arg_duration: f32, arg_callback: *const godot.String, arg_arg1: *const godot.Variant, arg_arg2: *const godot.Variant, arg_arg3: *const godot.Variant, arg_arg4: *const godot.Variant, arg_arg5: *const godot.Variant) !bool {
        if (mbind_interpolate_deferred_callback == null) {
            mbind_interpolate_deferred_callback = try api.createMethod("Tween", "interpolate_deferred_callback");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, arg_callback),
            @ptrCast(*const anyopaque, arg_arg1),
            @ptrCast(*const anyopaque, arg_arg2),
            @ptrCast(*const anyopaque, arg_arg3),
            @ptrCast(*const anyopaque, arg_arg4),
            @ptrCast(*const anyopaque, arg_arg5),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_interpolate_deferred_callback, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn interpolateMethod(self: *const Self, arg_object: *const godot.Object, arg_method: *const godot.String, arg_initial_val: *const godot.Variant, arg_final_val: *const godot.Variant, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_interpolate_method == null) {
            mbind_interpolate_method = try api.createMethod("Tween", "interpolate_method");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_initial_val),
            @ptrCast(*const anyopaque, arg_final_val),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_interpolate_method, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn interpolateProperty(self: *const Self, arg_object: *const godot.Object, arg_property: *const godot.NodePath, arg_initial_val: *const godot.Variant, arg_final_val: *const godot.Variant, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_interpolate_property == null) {
            mbind_interpolate_property = try api.createMethod("Tween", "interpolate_property");
        }

        var result: ?*anyopaque = null;
        var args: [8]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_initial_val),
            @ptrCast(*const anyopaque, arg_final_val),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_interpolate_property, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isActive(self: *const Self) !bool {
        if (mbind_is_active == null) {
            mbind_is_active = try api.createMethod("Tween", "is_active");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isRepeat(self: *const Self) !bool {
        if (mbind_is_repeat == null) {
            mbind_is_repeat = try api.createMethod("Tween", "is_repeat");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_repeat, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn remove(self: *const Self, arg_object: *const godot.Object, arg_key: *const godot.String) !bool {
        if (mbind_remove == null) {
            mbind_remove = try api.createMethod("Tween", "remove");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn removeAll(self: *const Self) !bool {
        if (mbind_remove_all == null) {
            mbind_remove_all = try api.createMethod("Tween", "remove_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_all, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn reset(self: *const Self, arg_object: *const godot.Object, arg_key: *const godot.String) !bool {
        if (mbind_reset == null) {
            mbind_reset = try api.createMethod("Tween", "reset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reset, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn resetAll(self: *const Self) !bool {
        if (mbind_reset_all == null) {
            mbind_reset_all = try api.createMethod("Tween", "reset_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reset_all, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn resumeFn(self: *const Self, arg_object: *const godot.Object, arg_key: *const godot.String) !bool {
        if (mbind_resume == null) {
            mbind_resume = try api.createMethod("Tween", "resume");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_resume, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn resumeAll(self: *const Self) !bool {
        if (mbind_resume_all == null) {
            mbind_resume_all = try api.createMethod("Tween", "resume_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_resume_all, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn seek(self: *const Self, arg_time: f32) !bool {
        if (mbind_seek == null) {
            mbind_seek = try api.createMethod("Tween", "seek");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_time),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_seek, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setActive(self: *const Self, arg_active: bool) !void {
        if (mbind_set_active == null) {
            mbind_set_active = try api.createMethod("Tween", "set_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_active, base, cargs, result);
    }

    pub fn setRepeat(self: *const Self, arg_repeat: bool) !void {
        if (mbind_set_repeat == null) {
            mbind_set_repeat = try api.createMethod("Tween", "set_repeat");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_repeat),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_repeat, base, cargs, result);
    }

    pub fn setSpeedScale(self: *const Self, arg_speed: f32) !void {
        if (mbind_set_speed_scale == null) {
            mbind_set_speed_scale = try api.createMethod("Tween", "set_speed_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_speed),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_speed_scale, base, cargs, result);
    }

    pub fn setTweenProcessMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_tween_process_mode == null) {
            mbind_set_tween_process_mode = try api.createMethod("Tween", "set_tween_process_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tween_process_mode, base, cargs, result);
    }

    pub fn start(self: *const Self) !bool {
        if (mbind_start == null) {
            mbind_start = try api.createMethod("Tween", "start");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_start, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn stop(self: *const Self, arg_object: *const godot.Object, arg_key: *const godot.String) !bool {
        if (mbind_stop == null) {
            mbind_stop = try api.createMethod("Tween", "stop");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_key),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_stop, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn stopAll(self: *const Self) !bool {
        if (mbind_stop_all == null) {
            mbind_stop_all = try api.createMethod("Tween", "stop_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_stop_all, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn targetingMethod(self: *const Self, arg_object: *const godot.Object, arg_method: *const godot.String, arg_initial: *const godot.Object, arg_initial_method: *const godot.String, arg_final_val: *const godot.Variant, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_targeting_method == null) {
            mbind_targeting_method = try api.createMethod("Tween", "targeting_method");
        }

        var result: ?*anyopaque = null;
        var args: [9]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_initial),
            @ptrCast(*const anyopaque, arg_initial_method),
            @ptrCast(*const anyopaque, arg_final_val),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_targeting_method, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn targetingProperty(self: *const Self, arg_object: *const godot.Object, arg_property: *const godot.NodePath, arg_initial: *const godot.Object, arg_initial_val: *const godot.NodePath, arg_final_val: *const godot.Variant, arg_duration: f32, arg_trans_type: i32, arg_ease_type: i32, arg_delay: f32) !bool {
        if (mbind_targeting_property == null) {
            mbind_targeting_property = try api.createMethod("Tween", "targeting_property");
        }

        var result: ?*anyopaque = null;
        var args: [9]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_object),
            @ptrCast(*const anyopaque, arg_property),
            @ptrCast(*const anyopaque, arg_initial),
            @ptrCast(*const anyopaque, arg_initial_val),
            @ptrCast(*const anyopaque, arg_final_val),
            @ptrCast(*const anyopaque, *arg_duration),
            @ptrCast(*const anyopaque, *arg_trans_type),
            @ptrCast(*const anyopaque, *arg_ease_type),
            @ptrCast(*const anyopaque, *arg_delay),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_targeting_property, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn tell(self: *const Self) !f32 {
        if (mbind_tell == null) {
            mbind_tell = try api.createMethod("Tween", "tell");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_tell, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }
};