// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Resource = @import("resource.zig").Resource;

// method bindings
var mbind_accumulate: ?*c_api.godot_method_bind = null;
var mbind_as_text: ?*c_api.godot_method_bind = null;
var mbind_get_action_strength: ?*c_api.godot_method_bind = null;
var mbind_get_device: ?*c_api.godot_method_bind = null;
var mbind_is_action: ?*c_api.godot_method_bind = null;
var mbind_is_action_pressed: ?*c_api.godot_method_bind = null;
var mbind_is_action_released: ?*c_api.godot_method_bind = null;
var mbind_is_action_type: ?*c_api.godot_method_bind = null;
var mbind_is_echo: ?*c_api.godot_method_bind = null;
var mbind_is_pressed: ?*c_api.godot_method_bind = null;
var mbind_set_device: ?*c_api.godot_method_bind = null;
var mbind_shortcut_match: ?*c_api.godot_method_bind = null;
var mbind_xformed_by: ?*c_api.godot_method_bind = null;
var mbind_input_event_constructor: ?fn () ?*c_api.godot_object = null;

pub const InputEvent = struct {
    const Self = @This();
    const BaseClass = Resource;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_input_event_constructor == null) {
            mbind_input_event_constructor = try api.createConstructor("InputEvent");
        }
        return api.createObject(Self, mbind_input_event_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn accumulate(self: *const Self, arg_with_event: *const godot.InputEvent) !bool {
        if (mbind_accumulate == null) {
            mbind_accumulate = try api.createMethod("InputEvent", "accumulate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_with_event),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_accumulate, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn asText(self: *const Self) !godot.String {
        if (mbind_as_text == null) {
            mbind_as_text = try api.createMethod("InputEvent", "as_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_as_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getActionStrength(self: *const Self, arg_action: *const godot.String, arg_exact_match: bool) !f32 {
        if (mbind_get_action_strength == null) {
            mbind_get_action_strength = try api.createMethod("InputEvent", "get_action_strength");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
            @ptrCast(*const anyopaque, *arg_exact_match),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_action_strength, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getDevice(self: *const Self) !i32 {
        if (mbind_get_device == null) {
            mbind_get_device = try api.createMethod("InputEvent", "get_device");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_device, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn isAction(self: *const Self, arg_action: *const godot.String, arg_exact_match: bool) !bool {
        if (mbind_is_action == null) {
            mbind_is_action = try api.createMethod("InputEvent", "is_action");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
            @ptrCast(*const anyopaque, *arg_exact_match),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_action, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isActionPressed(self: *const Self, arg_action: *const godot.String, arg_allow_echo: bool, arg_exact_match: bool) !bool {
        if (mbind_is_action_pressed == null) {
            mbind_is_action_pressed = try api.createMethod("InputEvent", "is_action_pressed");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
            @ptrCast(*const anyopaque, *arg_allow_echo),
            @ptrCast(*const anyopaque, *arg_exact_match),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_action_pressed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isActionReleased(self: *const Self, arg_action: *const godot.String, arg_exact_match: bool) !bool {
        if (mbind_is_action_released == null) {
            mbind_is_action_released = try api.createMethod("InputEvent", "is_action_released");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_action),
            @ptrCast(*const anyopaque, *arg_exact_match),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_action_released, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isActionType(self: *const Self) !bool {
        if (mbind_is_action_type == null) {
            mbind_is_action_type = try api.createMethod("InputEvent", "is_action_type");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_action_type, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isEcho(self: *const Self) !bool {
        if (mbind_is_echo == null) {
            mbind_is_echo = try api.createMethod("InputEvent", "is_echo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_echo, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isPressed(self: *const Self) !bool {
        if (mbind_is_pressed == null) {
            mbind_is_pressed = try api.createMethod("InputEvent", "is_pressed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_pressed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setDevice(self: *const Self, arg_device: i32) !void {
        if (mbind_set_device == null) {
            mbind_set_device = try api.createMethod("InputEvent", "set_device");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_device),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_device, base, cargs, result);
    }

    pub fn shortcutMatch(self: *const Self, arg_event: *const godot.InputEvent, arg_exact_match: bool) !bool {
        if (mbind_shortcut_match == null) {
            mbind_shortcut_match = try api.createMethod("InputEvent", "shortcut_match");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_event),
            @ptrCast(*const anyopaque, *arg_exact_match),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shortcut_match, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn xformedBy(self: *const Self, arg_xform: *const godot.Transform2D, arg_local_ofs: *const godot.Vector2) !godot.InputEvent {
        if (mbind_xformed_by == null) {
            mbind_xformed_by = try api.createMethod("InputEvent", "xformed_by");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_xform),
            @ptrCast(*const anyopaque, arg_local_ofs),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_xformed_by, base, cargs, result);
        return @ptrCast(*godot.InputEvent, @alignCast(@alignOf(&godot.InputEvent), result)).*;
    }
};