// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Material = @import("material.zig").Material;

// method bindings
var mbind_get_albedo: ?*c_api.godot_method_bind = null;
var mbind_get_alpha_scissor_threshold: ?*c_api.godot_method_bind = null;
var mbind_get_anisotropy: ?*c_api.godot_method_bind = null;
var mbind_get_ao_light_affect: ?*c_api.godot_method_bind = null;
var mbind_get_ao_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_get_billboard_mode: ?*c_api.godot_method_bind = null;
var mbind_get_blend_mode: ?*c_api.godot_method_bind = null;
var mbind_get_clearcoat: ?*c_api.godot_method_bind = null;
var mbind_get_clearcoat_gloss: ?*c_api.godot_method_bind = null;
var mbind_get_cull_mode: ?*c_api.godot_method_bind = null;
var mbind_get_depth_deep_parallax_flip_binormal: ?*c_api.godot_method_bind = null;
var mbind_get_depth_deep_parallax_flip_tangent: ?*c_api.godot_method_bind = null;
var mbind_get_depth_deep_parallax_max_layers: ?*c_api.godot_method_bind = null;
var mbind_get_depth_deep_parallax_min_layers: ?*c_api.godot_method_bind = null;
var mbind_get_depth_draw_mode: ?*c_api.godot_method_bind = null;
var mbind_get_depth_scale: ?*c_api.godot_method_bind = null;
var mbind_get_detail_blend_mode: ?*c_api.godot_method_bind = null;
var mbind_get_detail_uv: ?*c_api.godot_method_bind = null;
var mbind_get_diffuse_mode: ?*c_api.godot_method_bind = null;
var mbind_get_distance_fade: ?*c_api.godot_method_bind = null;
var mbind_get_distance_fade_max_distance: ?*c_api.godot_method_bind = null;
var mbind_get_distance_fade_min_distance: ?*c_api.godot_method_bind = null;
var mbind_get_emission: ?*c_api.godot_method_bind = null;
var mbind_get_emission_energy: ?*c_api.godot_method_bind = null;
var mbind_get_emission_operator: ?*c_api.godot_method_bind = null;
var mbind_get_feature: ?*c_api.godot_method_bind = null;
var mbind_get_flag: ?*c_api.godot_method_bind = null;
var mbind_get_grow: ?*c_api.godot_method_bind = null;
var mbind_get_line_width: ?*c_api.godot_method_bind = null;
var mbind_get_metallic: ?*c_api.godot_method_bind = null;
var mbind_get_metallic_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_get_normal_scale: ?*c_api.godot_method_bind = null;
var mbind_get_particles_anim_h_frames: ?*c_api.godot_method_bind = null;
var mbind_get_particles_anim_loop: ?*c_api.godot_method_bind = null;
var mbind_get_particles_anim_v_frames: ?*c_api.godot_method_bind = null;
var mbind_get_point_size: ?*c_api.godot_method_bind = null;
var mbind_get_proximity_fade_distance: ?*c_api.godot_method_bind = null;
var mbind_get_refraction: ?*c_api.godot_method_bind = null;
var mbind_get_refraction_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_get_rim: ?*c_api.godot_method_bind = null;
var mbind_get_rim_tint: ?*c_api.godot_method_bind = null;
var mbind_get_roughness: ?*c_api.godot_method_bind = null;
var mbind_get_roughness_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_get_specular: ?*c_api.godot_method_bind = null;
var mbind_get_specular_mode: ?*c_api.godot_method_bind = null;
var mbind_get_subsurface_scattering_strength: ?*c_api.godot_method_bind = null;
var mbind_get_texture: ?*c_api.godot_method_bind = null;
var mbind_get_transmission: ?*c_api.godot_method_bind = null;
var mbind_get_uv1_offset: ?*c_api.godot_method_bind = null;
var mbind_get_uv1_scale: ?*c_api.godot_method_bind = null;
var mbind_get_uv1_triplanar_blend_sharpness: ?*c_api.godot_method_bind = null;
var mbind_get_uv2_offset: ?*c_api.godot_method_bind = null;
var mbind_get_uv2_scale: ?*c_api.godot_method_bind = null;
var mbind_get_uv2_triplanar_blend_sharpness: ?*c_api.godot_method_bind = null;
var mbind_is_depth_deep_parallax_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_grow_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_proximity_fade_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_albedo: ?*c_api.godot_method_bind = null;
var mbind_set_alpha_scissor_threshold: ?*c_api.godot_method_bind = null;
var mbind_set_anisotropy: ?*c_api.godot_method_bind = null;
var mbind_set_ao_light_affect: ?*c_api.godot_method_bind = null;
var mbind_set_ao_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_set_billboard_mode: ?*c_api.godot_method_bind = null;
var mbind_set_blend_mode: ?*c_api.godot_method_bind = null;
var mbind_set_clearcoat: ?*c_api.godot_method_bind = null;
var mbind_set_clearcoat_gloss: ?*c_api.godot_method_bind = null;
var mbind_set_cull_mode: ?*c_api.godot_method_bind = null;
var mbind_set_depth_deep_parallax: ?*c_api.godot_method_bind = null;
var mbind_set_depth_deep_parallax_flip_binormal: ?*c_api.godot_method_bind = null;
var mbind_set_depth_deep_parallax_flip_tangent: ?*c_api.godot_method_bind = null;
var mbind_set_depth_deep_parallax_max_layers: ?*c_api.godot_method_bind = null;
var mbind_set_depth_deep_parallax_min_layers: ?*c_api.godot_method_bind = null;
var mbind_set_depth_draw_mode: ?*c_api.godot_method_bind = null;
var mbind_set_depth_scale: ?*c_api.godot_method_bind = null;
var mbind_set_detail_blend_mode: ?*c_api.godot_method_bind = null;
var mbind_set_detail_uv: ?*c_api.godot_method_bind = null;
var mbind_set_diffuse_mode: ?*c_api.godot_method_bind = null;
var mbind_set_distance_fade: ?*c_api.godot_method_bind = null;
var mbind_set_distance_fade_max_distance: ?*c_api.godot_method_bind = null;
var mbind_set_distance_fade_min_distance: ?*c_api.godot_method_bind = null;
var mbind_set_emission: ?*c_api.godot_method_bind = null;
var mbind_set_emission_energy: ?*c_api.godot_method_bind = null;
var mbind_set_emission_operator: ?*c_api.godot_method_bind = null;
var mbind_set_feature: ?*c_api.godot_method_bind = null;
var mbind_set_flag: ?*c_api.godot_method_bind = null;
var mbind_set_grow: ?*c_api.godot_method_bind = null;
var mbind_set_grow_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_line_width: ?*c_api.godot_method_bind = null;
var mbind_set_metallic: ?*c_api.godot_method_bind = null;
var mbind_set_metallic_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_set_normal_scale: ?*c_api.godot_method_bind = null;
var mbind_set_particles_anim_h_frames: ?*c_api.godot_method_bind = null;
var mbind_set_particles_anim_loop: ?*c_api.godot_method_bind = null;
var mbind_set_particles_anim_v_frames: ?*c_api.godot_method_bind = null;
var mbind_set_point_size: ?*c_api.godot_method_bind = null;
var mbind_set_proximity_fade: ?*c_api.godot_method_bind = null;
var mbind_set_proximity_fade_distance: ?*c_api.godot_method_bind = null;
var mbind_set_refraction: ?*c_api.godot_method_bind = null;
var mbind_set_refraction_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_set_rim: ?*c_api.godot_method_bind = null;
var mbind_set_rim_tint: ?*c_api.godot_method_bind = null;
var mbind_set_roughness: ?*c_api.godot_method_bind = null;
var mbind_set_roughness_texture_channel: ?*c_api.godot_method_bind = null;
var mbind_set_specular: ?*c_api.godot_method_bind = null;
var mbind_set_specular_mode: ?*c_api.godot_method_bind = null;
var mbind_set_subsurface_scattering_strength: ?*c_api.godot_method_bind = null;
var mbind_set_texture: ?*c_api.godot_method_bind = null;
var mbind_set_transmission: ?*c_api.godot_method_bind = null;
var mbind_set_uv1_offset: ?*c_api.godot_method_bind = null;
var mbind_set_uv1_scale: ?*c_api.godot_method_bind = null;
var mbind_set_uv1_triplanar_blend_sharpness: ?*c_api.godot_method_bind = null;
var mbind_set_uv2_offset: ?*c_api.godot_method_bind = null;
var mbind_set_uv2_scale: ?*c_api.godot_method_bind = null;
var mbind_set_uv2_triplanar_blend_sharpness: ?*c_api.godot_method_bind = null;
var mbind_spatial_material_constructor: ?fn () ?*c_api.godot_object = null;

pub const SpatialMaterial = struct {
    const Self = @This();
    const BaseClass = Material;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_spatial_material_constructor == null) {
            mbind_spatial_material_constructor = try api.createConstructor("SpatialMaterial");
        }
        return api.createObject(Self, mbind_spatial_material_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getAlbedo(self: *const Self) !godot.Color {
        if (mbind_get_albedo == null) {
            mbind_get_albedo = try api.createMethod("SpatialMaterial", "get_albedo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_albedo, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getAlphaScissorThreshold(self: *const Self) !f32 {
        if (mbind_get_alpha_scissor_threshold == null) {
            mbind_get_alpha_scissor_threshold = try api.createMethod("SpatialMaterial", "get_alpha_scissor_threshold");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_alpha_scissor_threshold, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAnisotropy(self: *const Self) !f32 {
        if (mbind_get_anisotropy == null) {
            mbind_get_anisotropy = try api.createMethod("SpatialMaterial", "get_anisotropy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_anisotropy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAoLightAffect(self: *const Self) !f32 {
        if (mbind_get_ao_light_affect == null) {
            mbind_get_ao_light_affect = try api.createMethod("SpatialMaterial", "get_ao_light_affect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ao_light_affect, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getAoTextureChannel(self: *const Self) !i32 {
        if (mbind_get_ao_texture_channel == null) {
            mbind_get_ao_texture_channel = try api.createMethod("SpatialMaterial", "get_ao_texture_channel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ao_texture_channel, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBillboardMode(self: *const Self) !i32 {
        if (mbind_get_billboard_mode == null) {
            mbind_get_billboard_mode = try api.createMethod("SpatialMaterial", "get_billboard_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_billboard_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBlendMode(self: *const Self) !i32 {
        if (mbind_get_blend_mode == null) {
            mbind_get_blend_mode = try api.createMethod("SpatialMaterial", "get_blend_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_blend_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getClearcoat(self: *const Self) !f32 {
        if (mbind_get_clearcoat == null) {
            mbind_get_clearcoat = try api.createMethod("SpatialMaterial", "get_clearcoat");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_clearcoat, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getClearcoatGloss(self: *const Self) !f32 {
        if (mbind_get_clearcoat_gloss == null) {
            mbind_get_clearcoat_gloss = try api.createMethod("SpatialMaterial", "get_clearcoat_gloss");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_clearcoat_gloss, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getCullMode(self: *const Self) !i32 {
        if (mbind_get_cull_mode == null) {
            mbind_get_cull_mode = try api.createMethod("SpatialMaterial", "get_cull_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cull_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDepthDeepParallaxFlipBinormal(self: *const Self) !bool {
        if (mbind_get_depth_deep_parallax_flip_binormal == null) {
            mbind_get_depth_deep_parallax_flip_binormal = try api.createMethod("SpatialMaterial", "get_depth_deep_parallax_flip_binormal");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_deep_parallax_flip_binormal, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getDepthDeepParallaxFlipTangent(self: *const Self) !bool {
        if (mbind_get_depth_deep_parallax_flip_tangent == null) {
            mbind_get_depth_deep_parallax_flip_tangent = try api.createMethod("SpatialMaterial", "get_depth_deep_parallax_flip_tangent");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_deep_parallax_flip_tangent, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getDepthDeepParallaxMaxLayers(self: *const Self) !i32 {
        if (mbind_get_depth_deep_parallax_max_layers == null) {
            mbind_get_depth_deep_parallax_max_layers = try api.createMethod("SpatialMaterial", "get_depth_deep_parallax_max_layers");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_deep_parallax_max_layers, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDepthDeepParallaxMinLayers(self: *const Self) !i32 {
        if (mbind_get_depth_deep_parallax_min_layers == null) {
            mbind_get_depth_deep_parallax_min_layers = try api.createMethod("SpatialMaterial", "get_depth_deep_parallax_min_layers");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_deep_parallax_min_layers, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDepthDrawMode(self: *const Self) !i32 {
        if (mbind_get_depth_draw_mode == null) {
            mbind_get_depth_draw_mode = try api.createMethod("SpatialMaterial", "get_depth_draw_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_draw_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDepthScale(self: *const Self) !f32 {
        if (mbind_get_depth_scale == null) {
            mbind_get_depth_scale = try api.createMethod("SpatialMaterial", "get_depth_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_depth_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getDetailBlendMode(self: *const Self) !i32 {
        if (mbind_get_detail_blend_mode == null) {
            mbind_get_detail_blend_mode = try api.createMethod("SpatialMaterial", "get_detail_blend_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_detail_blend_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDetailUv(self: *const Self) !i32 {
        if (mbind_get_detail_uv == null) {
            mbind_get_detail_uv = try api.createMethod("SpatialMaterial", "get_detail_uv");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_detail_uv, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDiffuseMode(self: *const Self) !i32 {
        if (mbind_get_diffuse_mode == null) {
            mbind_get_diffuse_mode = try api.createMethod("SpatialMaterial", "get_diffuse_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_diffuse_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDistanceFade(self: *const Self) !i32 {
        if (mbind_get_distance_fade == null) {
            mbind_get_distance_fade = try api.createMethod("SpatialMaterial", "get_distance_fade");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_distance_fade, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDistanceFadeMaxDistance(self: *const Self) !f32 {
        if (mbind_get_distance_fade_max_distance == null) {
            mbind_get_distance_fade_max_distance = try api.createMethod("SpatialMaterial", "get_distance_fade_max_distance");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_distance_fade_max_distance, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getDistanceFadeMinDistance(self: *const Self) !f32 {
        if (mbind_get_distance_fade_min_distance == null) {
            mbind_get_distance_fade_min_distance = try api.createMethod("SpatialMaterial", "get_distance_fade_min_distance");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_distance_fade_min_distance, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEmission(self: *const Self) !godot.Color {
        if (mbind_get_emission == null) {
            mbind_get_emission = try api.createMethod("SpatialMaterial", "get_emission");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_emission, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getEmissionEnergy(self: *const Self) !f32 {
        if (mbind_get_emission_energy == null) {
            mbind_get_emission_energy = try api.createMethod("SpatialMaterial", "get_emission_energy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_emission_energy, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getEmissionOperator(self: *const Self) !i32 {
        if (mbind_get_emission_operator == null) {
            mbind_get_emission_operator = try api.createMethod("SpatialMaterial", "get_emission_operator");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_emission_operator, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getFeature(self: *const Self, arg_feature: i32) !bool {
        if (mbind_get_feature == null) {
            mbind_get_feature = try api.createMethod("SpatialMaterial", "get_feature");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_feature),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_feature, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getFlag(self: *const Self, arg_flag: i32) !bool {
        if (mbind_get_flag == null) {
            mbind_get_flag = try api.createMethod("SpatialMaterial", "get_flag");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flag),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_flag, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getGrow(self: *const Self) !f32 {
        if (mbind_get_grow == null) {
            mbind_get_grow = try api.createMethod("SpatialMaterial", "get_grow");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_grow, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getLineWidth(self: *const Self) !f32 {
        if (mbind_get_line_width == null) {
            mbind_get_line_width = try api.createMethod("SpatialMaterial", "get_line_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_width, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getMetallic(self: *const Self) !f32 {
        if (mbind_get_metallic == null) {
            mbind_get_metallic = try api.createMethod("SpatialMaterial", "get_metallic");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_metallic, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getMetallicTextureChannel(self: *const Self) !i32 {
        if (mbind_get_metallic_texture_channel == null) {
            mbind_get_metallic_texture_channel = try api.createMethod("SpatialMaterial", "get_metallic_texture_channel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_metallic_texture_channel, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNormalScale(self: *const Self) !f32 {
        if (mbind_get_normal_scale == null) {
            mbind_get_normal_scale = try api.createMethod("SpatialMaterial", "get_normal_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_normal_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getParticlesAnimHFrames(self: *const Self) !i32 {
        if (mbind_get_particles_anim_h_frames == null) {
            mbind_get_particles_anim_h_frames = try api.createMethod("SpatialMaterial", "get_particles_anim_h_frames");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_particles_anim_h_frames, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getParticlesAnimLoop(self: *const Self) !bool {
        if (mbind_get_particles_anim_loop == null) {
            mbind_get_particles_anim_loop = try api.createMethod("SpatialMaterial", "get_particles_anim_loop");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_particles_anim_loop, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getParticlesAnimVFrames(self: *const Self) !i32 {
        if (mbind_get_particles_anim_v_frames == null) {
            mbind_get_particles_anim_v_frames = try api.createMethod("SpatialMaterial", "get_particles_anim_v_frames");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_particles_anim_v_frames, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPointSize(self: *const Self) !f32 {
        if (mbind_get_point_size == null) {
            mbind_get_point_size = try api.createMethod("SpatialMaterial", "get_point_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_point_size, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getProximityFadeDistance(self: *const Self) !f32 {
        if (mbind_get_proximity_fade_distance == null) {
            mbind_get_proximity_fade_distance = try api.createMethod("SpatialMaterial", "get_proximity_fade_distance");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_proximity_fade_distance, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRefraction(self: *const Self) !f32 {
        if (mbind_get_refraction == null) {
            mbind_get_refraction = try api.createMethod("SpatialMaterial", "get_refraction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_refraction, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRefractionTextureChannel(self: *const Self) !i32 {
        if (mbind_get_refraction_texture_channel == null) {
            mbind_get_refraction_texture_channel = try api.createMethod("SpatialMaterial", "get_refraction_texture_channel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_refraction_texture_channel, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getRim(self: *const Self) !f32 {
        if (mbind_get_rim == null) {
            mbind_get_rim = try api.createMethod("SpatialMaterial", "get_rim");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rim, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRimTint(self: *const Self) !f32 {
        if (mbind_get_rim_tint == null) {
            mbind_get_rim_tint = try api.createMethod("SpatialMaterial", "get_rim_tint");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rim_tint, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRoughness(self: *const Self) !f32 {
        if (mbind_get_roughness == null) {
            mbind_get_roughness = try api.createMethod("SpatialMaterial", "get_roughness");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_roughness, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRoughnessTextureChannel(self: *const Self) !i32 {
        if (mbind_get_roughness_texture_channel == null) {
            mbind_get_roughness_texture_channel = try api.createMethod("SpatialMaterial", "get_roughness_texture_channel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_roughness_texture_channel, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSpecular(self: *const Self) !f32 {
        if (mbind_get_specular == null) {
            mbind_get_specular = try api.createMethod("SpatialMaterial", "get_specular");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_specular, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSpecularMode(self: *const Self) !i32 {
        if (mbind_get_specular_mode == null) {
            mbind_get_specular_mode = try api.createMethod("SpatialMaterial", "get_specular_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_specular_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSubsurfaceScatteringStrength(self: *const Self) !f32 {
        if (mbind_get_subsurface_scattering_strength == null) {
            mbind_get_subsurface_scattering_strength = try api.createMethod("SpatialMaterial", "get_subsurface_scattering_strength");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_subsurface_scattering_strength, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getTexture(self: *const Self, arg_param: i32) !godot.Texture {
        if (mbind_get_texture == null) {
            mbind_get_texture = try api.createMethod("SpatialMaterial", "get_texture");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getTransmission(self: *const Self) !godot.Color {
        if (mbind_get_transmission == null) {
            mbind_get_transmission = try api.createMethod("SpatialMaterial", "get_transmission");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_transmission, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getUv1Offset(self: *const Self) !godot.Vector3 {
        if (mbind_get_uv1_offset == null) {
            mbind_get_uv1_offset = try api.createMethod("SpatialMaterial", "get_uv1_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv1_offset, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getUv1Scale(self: *const Self) !godot.Vector3 {
        if (mbind_get_uv1_scale == null) {
            mbind_get_uv1_scale = try api.createMethod("SpatialMaterial", "get_uv1_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv1_scale, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getUv1TriplanarBlendSharpness(self: *const Self) !f32 {
        if (mbind_get_uv1_triplanar_blend_sharpness == null) {
            mbind_get_uv1_triplanar_blend_sharpness = try api.createMethod("SpatialMaterial", "get_uv1_triplanar_blend_sharpness");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv1_triplanar_blend_sharpness, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getUv2Offset(self: *const Self) !godot.Vector3 {
        if (mbind_get_uv2_offset == null) {
            mbind_get_uv2_offset = try api.createMethod("SpatialMaterial", "get_uv2_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv2_offset, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getUv2Scale(self: *const Self) !godot.Vector3 {
        if (mbind_get_uv2_scale == null) {
            mbind_get_uv2_scale = try api.createMethod("SpatialMaterial", "get_uv2_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv2_scale, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getUv2TriplanarBlendSharpness(self: *const Self) !f32 {
        if (mbind_get_uv2_triplanar_blend_sharpness == null) {
            mbind_get_uv2_triplanar_blend_sharpness = try api.createMethod("SpatialMaterial", "get_uv2_triplanar_blend_sharpness");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_uv2_triplanar_blend_sharpness, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn isDepthDeepParallaxEnabled(self: *const Self) !bool {
        if (mbind_is_depth_deep_parallax_enabled == null) {
            mbind_is_depth_deep_parallax_enabled = try api.createMethod("SpatialMaterial", "is_depth_deep_parallax_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_depth_deep_parallax_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isGrowEnabled(self: *const Self) !bool {
        if (mbind_is_grow_enabled == null) {
            mbind_is_grow_enabled = try api.createMethod("SpatialMaterial", "is_grow_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_grow_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isProximityFadeEnabled(self: *const Self) !bool {
        if (mbind_is_proximity_fade_enabled == null) {
            mbind_is_proximity_fade_enabled = try api.createMethod("SpatialMaterial", "is_proximity_fade_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_proximity_fade_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setAlbedo(self: *const Self, arg_albedo: *const godot.Color) !void {
        if (mbind_set_albedo == null) {
            mbind_set_albedo = try api.createMethod("SpatialMaterial", "set_albedo");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_albedo),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_albedo, base, cargs, result);
    }

    pub fn setAlphaScissorThreshold(self: *const Self, arg_threshold: f32) !void {
        if (mbind_set_alpha_scissor_threshold == null) {
            mbind_set_alpha_scissor_threshold = try api.createMethod("SpatialMaterial", "set_alpha_scissor_threshold");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_threshold),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_alpha_scissor_threshold, base, cargs, result);
    }

    pub fn setAnisotropy(self: *const Self, arg_anisotropy: f32) !void {
        if (mbind_set_anisotropy == null) {
            mbind_set_anisotropy = try api.createMethod("SpatialMaterial", "set_anisotropy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_anisotropy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_anisotropy, base, cargs, result);
    }

    pub fn setAoLightAffect(self: *const Self, arg_amount: f32) !void {
        if (mbind_set_ao_light_affect == null) {
            mbind_set_ao_light_affect = try api.createMethod("SpatialMaterial", "set_ao_light_affect");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_ao_light_affect, base, cargs, result);
    }

    pub fn setAoTextureChannel(self: *const Self, arg_channel: i32) !void {
        if (mbind_set_ao_texture_channel == null) {
            mbind_set_ao_texture_channel = try api.createMethod("SpatialMaterial", "set_ao_texture_channel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_channel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_ao_texture_channel, base, cargs, result);
    }

    pub fn setBillboardMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_billboard_mode == null) {
            mbind_set_billboard_mode = try api.createMethod("SpatialMaterial", "set_billboard_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_billboard_mode, base, cargs, result);
    }

    pub fn setBlendMode(self: *const Self, arg_blend_mode: i32) !void {
        if (mbind_set_blend_mode == null) {
            mbind_set_blend_mode = try api.createMethod("SpatialMaterial", "set_blend_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_blend_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_blend_mode, base, cargs, result);
    }

    pub fn setClearcoat(self: *const Self, arg_clearcoat: f32) !void {
        if (mbind_set_clearcoat == null) {
            mbind_set_clearcoat = try api.createMethod("SpatialMaterial", "set_clearcoat");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_clearcoat),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clearcoat, base, cargs, result);
    }

    pub fn setClearcoatGloss(self: *const Self, arg_clearcoat_gloss: f32) !void {
        if (mbind_set_clearcoat_gloss == null) {
            mbind_set_clearcoat_gloss = try api.createMethod("SpatialMaterial", "set_clearcoat_gloss");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_clearcoat_gloss),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clearcoat_gloss, base, cargs, result);
    }

    pub fn setCullMode(self: *const Self, arg_cull_mode: i32) !void {
        if (mbind_set_cull_mode == null) {
            mbind_set_cull_mode = try api.createMethod("SpatialMaterial", "set_cull_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_cull_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_cull_mode, base, cargs, result);
    }

    pub fn setDepthDeepParallax(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_depth_deep_parallax == null) {
            mbind_set_depth_deep_parallax = try api.createMethod("SpatialMaterial", "set_depth_deep_parallax");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_deep_parallax, base, cargs, result);
    }

    pub fn setDepthDeepParallaxFlipBinormal(self: *const Self, arg_flip: bool) !void {
        if (mbind_set_depth_deep_parallax_flip_binormal == null) {
            mbind_set_depth_deep_parallax_flip_binormal = try api.createMethod("SpatialMaterial", "set_depth_deep_parallax_flip_binormal");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_deep_parallax_flip_binormal, base, cargs, result);
    }

    pub fn setDepthDeepParallaxFlipTangent(self: *const Self, arg_flip: bool) !void {
        if (mbind_set_depth_deep_parallax_flip_tangent == null) {
            mbind_set_depth_deep_parallax_flip_tangent = try api.createMethod("SpatialMaterial", "set_depth_deep_parallax_flip_tangent");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_deep_parallax_flip_tangent, base, cargs, result);
    }

    pub fn setDepthDeepParallaxMaxLayers(self: *const Self, arg_layer: i32) !void {
        if (mbind_set_depth_deep_parallax_max_layers == null) {
            mbind_set_depth_deep_parallax_max_layers = try api.createMethod("SpatialMaterial", "set_depth_deep_parallax_max_layers");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_deep_parallax_max_layers, base, cargs, result);
    }

    pub fn setDepthDeepParallaxMinLayers(self: *const Self, arg_layer: i32) !void {
        if (mbind_set_depth_deep_parallax_min_layers == null) {
            mbind_set_depth_deep_parallax_min_layers = try api.createMethod("SpatialMaterial", "set_depth_deep_parallax_min_layers");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_deep_parallax_min_layers, base, cargs, result);
    }

    pub fn setDepthDrawMode(self: *const Self, arg_depth_draw_mode: i32) !void {
        if (mbind_set_depth_draw_mode == null) {
            mbind_set_depth_draw_mode = try api.createMethod("SpatialMaterial", "set_depth_draw_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_depth_draw_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_draw_mode, base, cargs, result);
    }

    pub fn setDepthScale(self: *const Self, arg_depth_scale: f32) !void {
        if (mbind_set_depth_scale == null) {
            mbind_set_depth_scale = try api.createMethod("SpatialMaterial", "set_depth_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_depth_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_depth_scale, base, cargs, result);
    }

    pub fn setDetailBlendMode(self: *const Self, arg_detail_blend_mode: i32) !void {
        if (mbind_set_detail_blend_mode == null) {
            mbind_set_detail_blend_mode = try api.createMethod("SpatialMaterial", "set_detail_blend_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_detail_blend_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_detail_blend_mode, base, cargs, result);
    }

    pub fn setDetailUv(self: *const Self, arg_detail_uv: i32) !void {
        if (mbind_set_detail_uv == null) {
            mbind_set_detail_uv = try api.createMethod("SpatialMaterial", "set_detail_uv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_detail_uv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_detail_uv, base, cargs, result);
    }

    pub fn setDiffuseMode(self: *const Self, arg_diffuse_mode: i32) !void {
        if (mbind_set_diffuse_mode == null) {
            mbind_set_diffuse_mode = try api.createMethod("SpatialMaterial", "set_diffuse_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_diffuse_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_diffuse_mode, base, cargs, result);
    }

    pub fn setDistanceFade(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_distance_fade == null) {
            mbind_set_distance_fade = try api.createMethod("SpatialMaterial", "set_distance_fade");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_distance_fade, base, cargs, result);
    }

    pub fn setDistanceFadeMaxDistance(self: *const Self, arg_distance: f32) !void {
        if (mbind_set_distance_fade_max_distance == null) {
            mbind_set_distance_fade_max_distance = try api.createMethod("SpatialMaterial", "set_distance_fade_max_distance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_distance),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_distance_fade_max_distance, base, cargs, result);
    }

    pub fn setDistanceFadeMinDistance(self: *const Self, arg_distance: f32) !void {
        if (mbind_set_distance_fade_min_distance == null) {
            mbind_set_distance_fade_min_distance = try api.createMethod("SpatialMaterial", "set_distance_fade_min_distance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_distance),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_distance_fade_min_distance, base, cargs, result);
    }

    pub fn setEmission(self: *const Self, arg_emission: *const godot.Color) !void {
        if (mbind_set_emission == null) {
            mbind_set_emission = try api.createMethod("SpatialMaterial", "set_emission");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_emission),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_emission, base, cargs, result);
    }

    pub fn setEmissionEnergy(self: *const Self, arg_emission_energy: f32) !void {
        if (mbind_set_emission_energy == null) {
            mbind_set_emission_energy = try api.createMethod("SpatialMaterial", "set_emission_energy");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_emission_energy),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_emission_energy, base, cargs, result);
    }

    pub fn setEmissionOperator(self: *const Self, arg_operator: i32) !void {
        if (mbind_set_emission_operator == null) {
            mbind_set_emission_operator = try api.createMethod("SpatialMaterial", "set_emission_operator");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_operator),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_emission_operator, base, cargs, result);
    }

    pub fn setFeature(self: *const Self, arg_feature: i32, arg_enable: bool) !void {
        if (mbind_set_feature == null) {
            mbind_set_feature = try api.createMethod("SpatialMaterial", "set_feature");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_feature),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_feature, base, cargs, result);
    }

    pub fn setFlag(self: *const Self, arg_flag: i32, arg_enable: bool) !void {
        if (mbind_set_flag == null) {
            mbind_set_flag = try api.createMethod("SpatialMaterial", "set_flag");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flag),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_flag, base, cargs, result);
    }

    pub fn setGrow(self: *const Self, arg_amount: f32) !void {
        if (mbind_set_grow == null) {
            mbind_set_grow = try api.createMethod("SpatialMaterial", "set_grow");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_grow, base, cargs, result);
    }

    pub fn setGrowEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_grow_enabled == null) {
            mbind_set_grow_enabled = try api.createMethod("SpatialMaterial", "set_grow_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_grow_enabled, base, cargs, result);
    }

    pub fn setLineWidth(self: *const Self, arg_line_width: f32) !void {
        if (mbind_set_line_width == null) {
            mbind_set_line_width = try api.createMethod("SpatialMaterial", "set_line_width");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line_width),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line_width, base, cargs, result);
    }

    pub fn setMetallic(self: *const Self, arg_metallic: f32) !void {
        if (mbind_set_metallic == null) {
            mbind_set_metallic = try api.createMethod("SpatialMaterial", "set_metallic");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_metallic),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_metallic, base, cargs, result);
    }

    pub fn setMetallicTextureChannel(self: *const Self, arg_channel: i32) !void {
        if (mbind_set_metallic_texture_channel == null) {
            mbind_set_metallic_texture_channel = try api.createMethod("SpatialMaterial", "set_metallic_texture_channel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_channel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_metallic_texture_channel, base, cargs, result);
    }

    pub fn setNormalScale(self: *const Self, arg_normal_scale: f32) !void {
        if (mbind_set_normal_scale == null) {
            mbind_set_normal_scale = try api.createMethod("SpatialMaterial", "set_normal_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_normal_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_normal_scale, base, cargs, result);
    }

    pub fn setParticlesAnimHFrames(self: *const Self, arg_frames: i32) !void {
        if (mbind_set_particles_anim_h_frames == null) {
            mbind_set_particles_anim_h_frames = try api.createMethod("SpatialMaterial", "set_particles_anim_h_frames");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_frames),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_particles_anim_h_frames, base, cargs, result);
    }

    pub fn setParticlesAnimLoop(self: *const Self, arg_loop: bool) !void {
        if (mbind_set_particles_anim_loop == null) {
            mbind_set_particles_anim_loop = try api.createMethod("SpatialMaterial", "set_particles_anim_loop");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_loop),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_particles_anim_loop, base, cargs, result);
    }

    pub fn setParticlesAnimVFrames(self: *const Self, arg_frames: i32) !void {
        if (mbind_set_particles_anim_v_frames == null) {
            mbind_set_particles_anim_v_frames = try api.createMethod("SpatialMaterial", "set_particles_anim_v_frames");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_frames),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_particles_anim_v_frames, base, cargs, result);
    }

    pub fn setPointSize(self: *const Self, arg_point_size: f32) !void {
        if (mbind_set_point_size == null) {
            mbind_set_point_size = try api.createMethod("SpatialMaterial", "set_point_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_point_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_point_size, base, cargs, result);
    }

    pub fn setProximityFade(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_proximity_fade == null) {
            mbind_set_proximity_fade = try api.createMethod("SpatialMaterial", "set_proximity_fade");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_proximity_fade, base, cargs, result);
    }

    pub fn setProximityFadeDistance(self: *const Self, arg_distance: f32) !void {
        if (mbind_set_proximity_fade_distance == null) {
            mbind_set_proximity_fade_distance = try api.createMethod("SpatialMaterial", "set_proximity_fade_distance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_distance),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_proximity_fade_distance, base, cargs, result);
    }

    pub fn setRefraction(self: *const Self, arg_refraction: f32) !void {
        if (mbind_set_refraction == null) {
            mbind_set_refraction = try api.createMethod("SpatialMaterial", "set_refraction");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_refraction),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_refraction, base, cargs, result);
    }

    pub fn setRefractionTextureChannel(self: *const Self, arg_channel: i32) !void {
        if (mbind_set_refraction_texture_channel == null) {
            mbind_set_refraction_texture_channel = try api.createMethod("SpatialMaterial", "set_refraction_texture_channel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_channel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_refraction_texture_channel, base, cargs, result);
    }

    pub fn setRim(self: *const Self, arg_rim: f32) !void {
        if (mbind_set_rim == null) {
            mbind_set_rim = try api.createMethod("SpatialMaterial", "set_rim");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_rim),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rim, base, cargs, result);
    }

    pub fn setRimTint(self: *const Self, arg_rim_tint: f32) !void {
        if (mbind_set_rim_tint == null) {
            mbind_set_rim_tint = try api.createMethod("SpatialMaterial", "set_rim_tint");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_rim_tint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rim_tint, base, cargs, result);
    }

    pub fn setRoughness(self: *const Self, arg_roughness: f32) !void {
        if (mbind_set_roughness == null) {
            mbind_set_roughness = try api.createMethod("SpatialMaterial", "set_roughness");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_roughness),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_roughness, base, cargs, result);
    }

    pub fn setRoughnessTextureChannel(self: *const Self, arg_channel: i32) !void {
        if (mbind_set_roughness_texture_channel == null) {
            mbind_set_roughness_texture_channel = try api.createMethod("SpatialMaterial", "set_roughness_texture_channel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_channel),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_roughness_texture_channel, base, cargs, result);
    }

    pub fn setSpecular(self: *const Self, arg_specular: f32) !void {
        if (mbind_set_specular == null) {
            mbind_set_specular = try api.createMethod("SpatialMaterial", "set_specular");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_specular),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_specular, base, cargs, result);
    }

    pub fn setSpecularMode(self: *const Self, arg_specular_mode: i32) !void {
        if (mbind_set_specular_mode == null) {
            mbind_set_specular_mode = try api.createMethod("SpatialMaterial", "set_specular_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_specular_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_specular_mode, base, cargs, result);
    }

    pub fn setSubsurfaceScatteringStrength(self: *const Self, arg_strength: f32) !void {
        if (mbind_set_subsurface_scattering_strength == null) {
            mbind_set_subsurface_scattering_strength = try api.createMethod("SpatialMaterial", "set_subsurface_scattering_strength");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_strength),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_subsurface_scattering_strength, base, cargs, result);
    }

    pub fn setTexture(self: *const Self, arg_param: i32, arg_texture: *const godot.Texture) !void {
        if (mbind_set_texture == null) {
            mbind_set_texture = try api.createMethod("SpatialMaterial", "set_texture");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_texture, base, cargs, result);
    }

    pub fn setTransmission(self: *const Self, arg_transmission: *const godot.Color) !void {
        if (mbind_set_transmission == null) {
            mbind_set_transmission = try api.createMethod("SpatialMaterial", "set_transmission");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_transmission),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_transmission, base, cargs, result);
    }

    pub fn setUv1Offset(self: *const Self, arg_offset: *const godot.Vector3) !void {
        if (mbind_set_uv1_offset == null) {
            mbind_set_uv1_offset = try api.createMethod("SpatialMaterial", "set_uv1_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv1_offset, base, cargs, result);
    }

    pub fn setUv1Scale(self: *const Self, arg_scale: *const godot.Vector3) !void {
        if (mbind_set_uv1_scale == null) {
            mbind_set_uv1_scale = try api.createMethod("SpatialMaterial", "set_uv1_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv1_scale, base, cargs, result);
    }

    pub fn setUv1TriplanarBlendSharpness(self: *const Self, arg_sharpness: f32) !void {
        if (mbind_set_uv1_triplanar_blend_sharpness == null) {
            mbind_set_uv1_triplanar_blend_sharpness = try api.createMethod("SpatialMaterial", "set_uv1_triplanar_blend_sharpness");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_sharpness),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv1_triplanar_blend_sharpness, base, cargs, result);
    }

    pub fn setUv2Offset(self: *const Self, arg_offset: *const godot.Vector3) !void {
        if (mbind_set_uv2_offset == null) {
            mbind_set_uv2_offset = try api.createMethod("SpatialMaterial", "set_uv2_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv2_offset, base, cargs, result);
    }

    pub fn setUv2Scale(self: *const Self, arg_scale: *const godot.Vector3) !void {
        if (mbind_set_uv2_scale == null) {
            mbind_set_uv2_scale = try api.createMethod("SpatialMaterial", "set_uv2_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv2_scale, base, cargs, result);
    }

    pub fn setUv2TriplanarBlendSharpness(self: *const Self, arg_sharpness: f32) !void {
        if (mbind_set_uv2_triplanar_blend_sharpness == null) {
            mbind_set_uv2_triplanar_blend_sharpness = try api.createMethod("SpatialMaterial", "set_uv2_triplanar_blend_sharpness");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_sharpness),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_uv2_triplanar_blend_sharpness, base, cargs, result);
    }
};