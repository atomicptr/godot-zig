// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_add_color_region: ?*c_api.godot_method_bind = null;
var mbind_add_keyword_color: ?*c_api.godot_method_bind = null;
var mbind_can_fold: ?*c_api.godot_method_bind = null;
var mbind_center_viewport_to_cursor: ?*c_api.godot_method_bind = null;
var mbind_clear_colors: ?*c_api.godot_method_bind = null;
var mbind_clear_undo_history: ?*c_api.godot_method_bind = null;
var mbind_copy: ?*c_api.godot_method_bind = null;
var mbind_cursor_get_blink_enabled: ?*c_api.godot_method_bind = null;
var mbind_cursor_get_blink_speed: ?*c_api.godot_method_bind = null;
var mbind_cursor_get_column: ?*c_api.godot_method_bind = null;
var mbind_cursor_get_line: ?*c_api.godot_method_bind = null;
var mbind_cursor_is_block_mode: ?*c_api.godot_method_bind = null;
var mbind_cursor_set_blink_enabled: ?*c_api.godot_method_bind = null;
var mbind_cursor_set_blink_speed: ?*c_api.godot_method_bind = null;
var mbind_cursor_set_block_mode: ?*c_api.godot_method_bind = null;
var mbind_cursor_set_column: ?*c_api.godot_method_bind = null;
var mbind_cursor_set_line: ?*c_api.godot_method_bind = null;
var mbind_cut: ?*c_api.godot_method_bind = null;
var mbind_deselect: ?*c_api.godot_method_bind = null;
var mbind_draw_minimap: ?*c_api.godot_method_bind = null;
var mbind_fold_all_lines: ?*c_api.godot_method_bind = null;
var mbind_fold_line: ?*c_api.godot_method_bind = null;
var mbind_get_breakpoints: ?*c_api.godot_method_bind = null;
var mbind_get_h_scroll: ?*c_api.godot_method_bind = null;
var mbind_get_keyword_color: ?*c_api.godot_method_bind = null;
var mbind_get_line: ?*c_api.godot_method_bind = null;
var mbind_get_line_column_at_pos: ?*c_api.godot_method_bind = null;
var mbind_get_line_count: ?*c_api.godot_method_bind = null;
var mbind_get_line_height: ?*c_api.godot_method_bind = null;
var mbind_get_line_width: ?*c_api.godot_method_bind = null;
var mbind_get_line_wrap_count: ?*c_api.godot_method_bind = null;
var mbind_get_line_wrapped_text: ?*c_api.godot_method_bind = null;
var mbind_get_menu: ?*c_api.godot_method_bind = null;
var mbind_get_minimap_width: ?*c_api.godot_method_bind = null;
var mbind_get_pos_at_line_column: ?*c_api.godot_method_bind = null;
var mbind_get_rect_at_line_column: ?*c_api.godot_method_bind = null;
var mbind_get_selection_from_column: ?*c_api.godot_method_bind = null;
var mbind_get_selection_from_line: ?*c_api.godot_method_bind = null;
var mbind_get_selection_text: ?*c_api.godot_method_bind = null;
var mbind_get_selection_to_column: ?*c_api.godot_method_bind = null;
var mbind_get_selection_to_line: ?*c_api.godot_method_bind = null;
var mbind_get_text: ?*c_api.godot_method_bind = null;
var mbind_get_total_gutter_width: ?*c_api.godot_method_bind = null;
var mbind_get_v_scroll: ?*c_api.godot_method_bind = null;
var mbind_get_v_scroll_speed: ?*c_api.godot_method_bind = null;
var mbind_get_word_under_cursor: ?*c_api.godot_method_bind = null;
var mbind_has_keyword_color: ?*c_api.godot_method_bind = null;
var mbind_has_redo: ?*c_api.godot_method_bind = null;
var mbind_has_undo: ?*c_api.godot_method_bind = null;
var mbind_insert_text_at_cursor: ?*c_api.godot_method_bind = null;
var mbind_is_bookmark_gutter_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_breakpoint_gutter_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_context_menu_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_drawing_fold_gutter: ?*c_api.godot_method_bind = null;
var mbind_is_drawing_minimap: ?*c_api.godot_method_bind = null;
var mbind_is_drawing_spaces: ?*c_api.godot_method_bind = null;
var mbind_is_drawing_tabs: ?*c_api.godot_method_bind = null;
var mbind_is_folded: ?*c_api.godot_method_bind = null;
var mbind_is_hiding_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_highlight_all_occurrences_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_highlight_current_line_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_line_hidden: ?*c_api.godot_method_bind = null;
var mbind_is_line_set_as_bookmark: ?*c_api.godot_method_bind = null;
var mbind_is_line_set_as_breakpoint: ?*c_api.godot_method_bind = null;
var mbind_is_line_set_as_safe: ?*c_api.godot_method_bind = null;
var mbind_is_line_wrapped: ?*c_api.godot_method_bind = null;
var mbind_is_overriding_selected_font_color: ?*c_api.godot_method_bind = null;
var mbind_is_readonly: ?*c_api.godot_method_bind = null;
var mbind_is_right_click_moving_caret: ?*c_api.godot_method_bind = null;
var mbind_is_selecting_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_selection_active: ?*c_api.godot_method_bind = null;
var mbind_is_shortcut_keys_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_show_line_numbers_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_smooth_scroll_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_syntax_coloring_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_virtual_keyboard_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_wrap_enabled: ?*c_api.godot_method_bind = null;
var mbind_menu_option: ?*c_api.godot_method_bind = null;
var mbind_paste: ?*c_api.godot_method_bind = null;
var mbind_redo: ?*c_api.godot_method_bind = null;
var mbind_remove_breakpoints: ?*c_api.godot_method_bind = null;
var mbind_search: ?*c_api.godot_method_bind = null;
var mbind_select: ?*c_api.godot_method_bind = null;
var mbind_select_all: ?*c_api.godot_method_bind = null;
var mbind_set_bookmark_gutter_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_breakpoint_gutter_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_context_menu_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_draw_fold_gutter: ?*c_api.godot_method_bind = null;
var mbind_set_draw_spaces: ?*c_api.godot_method_bind = null;
var mbind_set_draw_tabs: ?*c_api.godot_method_bind = null;
var mbind_set_h_scroll: ?*c_api.godot_method_bind = null;
var mbind_set_hiding_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_highlight_all_occurrences: ?*c_api.godot_method_bind = null;
var mbind_set_highlight_current_line: ?*c_api.godot_method_bind = null;
var mbind_set_line: ?*c_api.godot_method_bind = null;
var mbind_set_line_as_bookmark: ?*c_api.godot_method_bind = null;
var mbind_set_line_as_breakpoint: ?*c_api.godot_method_bind = null;
var mbind_set_line_as_hidden: ?*c_api.godot_method_bind = null;
var mbind_set_line_as_safe: ?*c_api.godot_method_bind = null;
var mbind_set_minimap_width: ?*c_api.godot_method_bind = null;
var mbind_set_override_selected_font_color: ?*c_api.godot_method_bind = null;
var mbind_set_readonly: ?*c_api.godot_method_bind = null;
var mbind_set_right_click_moves_caret: ?*c_api.godot_method_bind = null;
var mbind_set_selecting_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_shortcut_keys_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_show_line_numbers: ?*c_api.godot_method_bind = null;
var mbind_set_smooth_scroll_enable: ?*c_api.godot_method_bind = null;
var mbind_set_syntax_coloring: ?*c_api.godot_method_bind = null;
var mbind_set_text: ?*c_api.godot_method_bind = null;
var mbind_set_v_scroll: ?*c_api.godot_method_bind = null;
var mbind_set_v_scroll_speed: ?*c_api.godot_method_bind = null;
var mbind_set_virtual_keyboard_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_wrap_enabled: ?*c_api.godot_method_bind = null;
var mbind_toggle_fold_line: ?*c_api.godot_method_bind = null;
var mbind_undo: ?*c_api.godot_method_bind = null;
var mbind_unfold_line: ?*c_api.godot_method_bind = null;
var mbind_unhide_all_lines: ?*c_api.godot_method_bind = null;
var mbind_text_edit_constructor: ?fn () ?*c_api.godot_object = null;

pub const TextEdit = struct {
    const Self = @This();
    pub const BaseClass = godot.Control;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_text_edit_constructor == null) {
            mbind_text_edit_constructor = try api.createConstructor("TextEdit");
        }
        return api.createObject(Self, mbind_text_edit_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addColorRegion(self: *const Self, arg_begin_key: *const godot.String, arg_end_key: *const godot.String, arg_color: *const godot.Color, arg_line_only: bool) !void {
        if (mbind_add_color_region == null) {
            mbind_add_color_region = try api.createMethod("TextEdit", "add_color_region");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_begin_key),
            @ptrCast(*const anyopaque, arg_end_key),
            @ptrCast(*const anyopaque, arg_color),
            @ptrCast(*const anyopaque, *arg_line_only),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_color_region, base, cargs, result);
    }

    pub fn addKeywordColor(self: *const Self, arg_keyword: *const godot.String, arg_color: *const godot.Color) !void {
        if (mbind_add_keyword_color == null) {
            mbind_add_keyword_color = try api.createMethod("TextEdit", "add_keyword_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_keyword),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_keyword_color, base, cargs, result);
    }

    pub fn canFold(self: *const Self, arg_line: i32) !bool {
        if (mbind_can_fold == null) {
            mbind_can_fold = try api.createMethod("TextEdit", "can_fold");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_can_fold, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn centerViewportToCursor(self: *const Self) !void {
        if (mbind_center_viewport_to_cursor == null) {
            mbind_center_viewport_to_cursor = try api.createMethod("TextEdit", "center_viewport_to_cursor");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_center_viewport_to_cursor, base, cargs, result);
    }

    pub fn clearColors(self: *const Self) !void {
        if (mbind_clear_colors == null) {
            mbind_clear_colors = try api.createMethod("TextEdit", "clear_colors");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_colors, base, cargs, result);
    }

    pub fn clearUndoHistory(self: *const Self) !void {
        if (mbind_clear_undo_history == null) {
            mbind_clear_undo_history = try api.createMethod("TextEdit", "clear_undo_history");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_undo_history, base, cargs, result);
    }

    pub fn copy(self: *const Self) !void {
        if (mbind_copy == null) {
            mbind_copy = try api.createMethod("TextEdit", "copy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_copy, base, cargs, result);
    }

    pub fn cursorGetBlinkEnabled(self: *const Self) !bool {
        if (mbind_cursor_get_blink_enabled == null) {
            mbind_cursor_get_blink_enabled = try api.createMethod("TextEdit", "cursor_get_blink_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_get_blink_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn cursorGetBlinkSpeed(self: *const Self) !f32 {
        if (mbind_cursor_get_blink_speed == null) {
            mbind_cursor_get_blink_speed = try api.createMethod("TextEdit", "cursor_get_blink_speed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_get_blink_speed, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn cursorGetColumn(self: *const Self) !i32 {
        if (mbind_cursor_get_column == null) {
            mbind_cursor_get_column = try api.createMethod("TextEdit", "cursor_get_column");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_get_column, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn cursorGetLine(self: *const Self) !i32 {
        if (mbind_cursor_get_line == null) {
            mbind_cursor_get_line = try api.createMethod("TextEdit", "cursor_get_line");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_get_line, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn cursorIsBlockMode(self: *const Self) !bool {
        if (mbind_cursor_is_block_mode == null) {
            mbind_cursor_is_block_mode = try api.createMethod("TextEdit", "cursor_is_block_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_is_block_mode, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn cursorSetBlinkEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_cursor_set_blink_enabled == null) {
            mbind_cursor_set_blink_enabled = try api.createMethod("TextEdit", "cursor_set_blink_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_set_blink_enabled, base, cargs, result);
    }

    pub fn cursorSetBlinkSpeed(self: *const Self, arg_blink_speed: f32) !void {
        if (mbind_cursor_set_blink_speed == null) {
            mbind_cursor_set_blink_speed = try api.createMethod("TextEdit", "cursor_set_blink_speed");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_blink_speed),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_set_blink_speed, base, cargs, result);
    }

    pub fn cursorSetBlockMode(self: *const Self, arg_enable: bool) !void {
        if (mbind_cursor_set_block_mode == null) {
            mbind_cursor_set_block_mode = try api.createMethod("TextEdit", "cursor_set_block_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_set_block_mode, base, cargs, result);
    }

    pub fn cursorSetColumn(self: *const Self, arg_column: i32, arg_adjust_viewport: bool) !void {
        if (mbind_cursor_set_column == null) {
            mbind_cursor_set_column = try api.createMethod("TextEdit", "cursor_set_column");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_column),
            @ptrCast(*const anyopaque, *arg_adjust_viewport),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_set_column, base, cargs, result);
    }

    pub fn cursorSetLine(self: *const Self, arg_line: i32, arg_adjust_viewport: bool, arg_can_be_hidden: bool, arg_wrap_index: i32) !void {
        if (mbind_cursor_set_line == null) {
            mbind_cursor_set_line = try api.createMethod("TextEdit", "cursor_set_line");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_adjust_viewport),
            @ptrCast(*const anyopaque, *arg_can_be_hidden),
            @ptrCast(*const anyopaque, *arg_wrap_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cursor_set_line, base, cargs, result);
    }

    pub fn cut(self: *const Self) !void {
        if (mbind_cut == null) {
            mbind_cut = try api.createMethod("TextEdit", "cut");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cut, base, cargs, result);
    }

    pub fn deselect(self: *const Self) !void {
        if (mbind_deselect == null) {
            mbind_deselect = try api.createMethod("TextEdit", "deselect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_deselect, base, cargs, result);
    }

    pub fn drawMinimap(self: *const Self, arg_draw: bool) !void {
        if (mbind_draw_minimap == null) {
            mbind_draw_minimap = try api.createMethod("TextEdit", "draw_minimap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_draw),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_draw_minimap, base, cargs, result);
    }

    pub fn foldAllLines(self: *const Self) !void {
        if (mbind_fold_all_lines == null) {
            mbind_fold_all_lines = try api.createMethod("TextEdit", "fold_all_lines");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_fold_all_lines, base, cargs, result);
    }

    pub fn foldLine(self: *const Self, arg_line: i32) !void {
        if (mbind_fold_line == null) {
            mbind_fold_line = try api.createMethod("TextEdit", "fold_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_fold_line, base, cargs, result);
    }

    pub fn getBreakpoints(self: *const Self) !godot.Array {
        if (mbind_get_breakpoints == null) {
            mbind_get_breakpoints = try api.createMethod("TextEdit", "get_breakpoints");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_breakpoints, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getHScroll(self: *const Self) !i32 {
        if (mbind_get_h_scroll == null) {
            mbind_get_h_scroll = try api.createMethod("TextEdit", "get_h_scroll");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_h_scroll, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getKeywordColor(self: *const Self, arg_keyword: *const godot.String) !godot.Color {
        if (mbind_get_keyword_color == null) {
            mbind_get_keyword_color = try api.createMethod("TextEdit", "get_keyword_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_keyword),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_keyword_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getLine(self: *const Self, arg_line: i32) !godot.String {
        if (mbind_get_line == null) {
            mbind_get_line = try api.createMethod("TextEdit", "get_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLineColumnAtPos(self: *const Self, arg_position: *const godot.Vector2) !godot.Vector2 {
        if (mbind_get_line_column_at_pos == null) {
            mbind_get_line_column_at_pos = try api.createMethod("TextEdit", "get_line_column_at_pos");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_column_at_pos, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getLineCount(self: *const Self) !i32 {
        if (mbind_get_line_count == null) {
            mbind_get_line_count = try api.createMethod("TextEdit", "get_line_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLineHeight(self: *const Self) !i32 {
        if (mbind_get_line_height == null) {
            mbind_get_line_height = try api.createMethod("TextEdit", "get_line_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_height, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLineWidth(self: *const Self, arg_line: i32, arg_wrap_index: i32) !i32 {
        if (mbind_get_line_width == null) {
            mbind_get_line_width = try api.createMethod("TextEdit", "get_line_width");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_wrap_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLineWrapCount(self: *const Self, arg_line: i32) !i32 {
        if (mbind_get_line_wrap_count == null) {
            mbind_get_line_wrap_count = try api.createMethod("TextEdit", "get_line_wrap_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_wrap_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getLineWrappedText(self: *const Self, arg_line: i32) !godot.PoolStringArray {
        if (mbind_get_line_wrapped_text == null) {
            mbind_get_line_wrapped_text = try api.createMethod("TextEdit", "get_line_wrapped_text");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_line_wrapped_text, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getMenu(self: *const Self) !godot.PopupMenu {
        if (mbind_get_menu == null) {
            mbind_get_menu = try api.createMethod("TextEdit", "get_menu");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_menu, base, cargs, result);
        return @ptrCast(*godot.PopupMenu, @alignCast(@alignOf(&godot.PopupMenu), result)).*;
    }

    pub fn getMinimapWidth(self: *const Self) !i32 {
        if (mbind_get_minimap_width == null) {
            mbind_get_minimap_width = try api.createMethod("TextEdit", "get_minimap_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_minimap_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPosAtLineColumn(self: *const Self, arg_line: i32, arg_column: i32) !godot.Vector2 {
        if (mbind_get_pos_at_line_column == null) {
            mbind_get_pos_at_line_column = try api.createMethod("TextEdit", "get_pos_at_line_column");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_column),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pos_at_line_column, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getRectAtLineColumn(self: *const Self, arg_line: i32, arg_column: i32) !godot.Rect2 {
        if (mbind_get_rect_at_line_column == null) {
            mbind_get_rect_at_line_column = try api.createMethod("TextEdit", "get_rect_at_line_column");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_column),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rect_at_line_column, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getSelectionFromColumn(self: *const Self) !i32 {
        if (mbind_get_selection_from_column == null) {
            mbind_get_selection_from_column = try api.createMethod("TextEdit", "get_selection_from_column");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection_from_column, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSelectionFromLine(self: *const Self) !i32 {
        if (mbind_get_selection_from_line == null) {
            mbind_get_selection_from_line = try api.createMethod("TextEdit", "get_selection_from_line");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection_from_line, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSelectionText(self: *const Self) !godot.String {
        if (mbind_get_selection_text == null) {
            mbind_get_selection_text = try api.createMethod("TextEdit", "get_selection_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getSelectionToColumn(self: *const Self) !i32 {
        if (mbind_get_selection_to_column == null) {
            mbind_get_selection_to_column = try api.createMethod("TextEdit", "get_selection_to_column");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection_to_column, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSelectionToLine(self: *const Self) !i32 {
        if (mbind_get_selection_to_line == null) {
            mbind_get_selection_to_line = try api.createMethod("TextEdit", "get_selection_to_line");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_selection_to_line, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getText(self: *const Self) !godot.String {
        if (mbind_get_text == null) {
            mbind_get_text = try api.createMethod("TextEdit", "get_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getTotalGutterWidth(self: *const Self) !i32 {
        if (mbind_get_total_gutter_width == null) {
            mbind_get_total_gutter_width = try api.createMethod("TextEdit", "get_total_gutter_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_total_gutter_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getVScroll(self: *const Self) !f32 {
        if (mbind_get_v_scroll == null) {
            mbind_get_v_scroll = try api.createMethod("TextEdit", "get_v_scroll");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_v_scroll, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getVScrollSpeed(self: *const Self) !f32 {
        if (mbind_get_v_scroll_speed == null) {
            mbind_get_v_scroll_speed = try api.createMethod("TextEdit", "get_v_scroll_speed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_v_scroll_speed, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getWordUnderCursor(self: *const Self) !godot.String {
        if (mbind_get_word_under_cursor == null) {
            mbind_get_word_under_cursor = try api.createMethod("TextEdit", "get_word_under_cursor");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_word_under_cursor, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn hasKeywordColor(self: *const Self, arg_keyword: *const godot.String) !bool {
        if (mbind_has_keyword_color == null) {
            mbind_has_keyword_color = try api.createMethod("TextEdit", "has_keyword_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_keyword),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_keyword_color, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasRedo(self: *const Self) !bool {
        if (mbind_has_redo == null) {
            mbind_has_redo = try api.createMethod("TextEdit", "has_redo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_redo, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasUndo(self: *const Self) !bool {
        if (mbind_has_undo == null) {
            mbind_has_undo = try api.createMethod("TextEdit", "has_undo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_undo, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn insertTextAtCursor(self: *const Self, arg_text: *const godot.String) !void {
        if (mbind_insert_text_at_cursor == null) {
            mbind_insert_text_at_cursor = try api.createMethod("TextEdit", "insert_text_at_cursor");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_insert_text_at_cursor, base, cargs, result);
    }

    pub fn isBookmarkGutterEnabled(self: *const Self) !bool {
        if (mbind_is_bookmark_gutter_enabled == null) {
            mbind_is_bookmark_gutter_enabled = try api.createMethod("TextEdit", "is_bookmark_gutter_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_bookmark_gutter_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isBreakpointGutterEnabled(self: *const Self) !bool {
        if (mbind_is_breakpoint_gutter_enabled == null) {
            mbind_is_breakpoint_gutter_enabled = try api.createMethod("TextEdit", "is_breakpoint_gutter_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_breakpoint_gutter_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isContextMenuEnabled(self: *const Self) !bool {
        if (mbind_is_context_menu_enabled == null) {
            mbind_is_context_menu_enabled = try api.createMethod("TextEdit", "is_context_menu_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_context_menu_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDrawingFoldGutter(self: *const Self) !bool {
        if (mbind_is_drawing_fold_gutter == null) {
            mbind_is_drawing_fold_gutter = try api.createMethod("TextEdit", "is_drawing_fold_gutter");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_drawing_fold_gutter, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDrawingMinimap(self: *const Self) !bool {
        if (mbind_is_drawing_minimap == null) {
            mbind_is_drawing_minimap = try api.createMethod("TextEdit", "is_drawing_minimap");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_drawing_minimap, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDrawingSpaces(self: *const Self) !bool {
        if (mbind_is_drawing_spaces == null) {
            mbind_is_drawing_spaces = try api.createMethod("TextEdit", "is_drawing_spaces");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_drawing_spaces, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDrawingTabs(self: *const Self) !bool {
        if (mbind_is_drawing_tabs == null) {
            mbind_is_drawing_tabs = try api.createMethod("TextEdit", "is_drawing_tabs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_drawing_tabs, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isFolded(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_folded == null) {
            mbind_is_folded = try api.createMethod("TextEdit", "is_folded");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_folded, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHidingEnabled(self: *const Self) !bool {
        if (mbind_is_hiding_enabled == null) {
            mbind_is_hiding_enabled = try api.createMethod("TextEdit", "is_hiding_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_hiding_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHighlightAllOccurrencesEnabled(self: *const Self) !bool {
        if (mbind_is_highlight_all_occurrences_enabled == null) {
            mbind_is_highlight_all_occurrences_enabled = try api.createMethod("TextEdit", "is_highlight_all_occurrences_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_highlight_all_occurrences_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHighlightCurrentLineEnabled(self: *const Self) !bool {
        if (mbind_is_highlight_current_line_enabled == null) {
            mbind_is_highlight_current_line_enabled = try api.createMethod("TextEdit", "is_highlight_current_line_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_highlight_current_line_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLineHidden(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_line_hidden == null) {
            mbind_is_line_hidden = try api.createMethod("TextEdit", "is_line_hidden");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_line_hidden, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLineSetAsBookmark(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_line_set_as_bookmark == null) {
            mbind_is_line_set_as_bookmark = try api.createMethod("TextEdit", "is_line_set_as_bookmark");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_line_set_as_bookmark, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLineSetAsBreakpoint(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_line_set_as_breakpoint == null) {
            mbind_is_line_set_as_breakpoint = try api.createMethod("TextEdit", "is_line_set_as_breakpoint");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_line_set_as_breakpoint, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLineSetAsSafe(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_line_set_as_safe == null) {
            mbind_is_line_set_as_safe = try api.createMethod("TextEdit", "is_line_set_as_safe");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_line_set_as_safe, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isLineWrapped(self: *const Self, arg_line: i32) !bool {
        if (mbind_is_line_wrapped == null) {
            mbind_is_line_wrapped = try api.createMethod("TextEdit", "is_line_wrapped");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_line_wrapped, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOverridingSelectedFontColor(self: *const Self) !bool {
        if (mbind_is_overriding_selected_font_color == null) {
            mbind_is_overriding_selected_font_color = try api.createMethod("TextEdit", "is_overriding_selected_font_color");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_overriding_selected_font_color, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isReadonly(self: *const Self) !bool {
        if (mbind_is_readonly == null) {
            mbind_is_readonly = try api.createMethod("TextEdit", "is_readonly");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_readonly, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isRightClickMovingCaret(self: *const Self) !bool {
        if (mbind_is_right_click_moving_caret == null) {
            mbind_is_right_click_moving_caret = try api.createMethod("TextEdit", "is_right_click_moving_caret");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_right_click_moving_caret, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSelectingEnabled(self: *const Self) !bool {
        if (mbind_is_selecting_enabled == null) {
            mbind_is_selecting_enabled = try api.createMethod("TextEdit", "is_selecting_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_selecting_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSelectionActive(self: *const Self) !bool {
        if (mbind_is_selection_active == null) {
            mbind_is_selection_active = try api.createMethod("TextEdit", "is_selection_active");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_selection_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isShortcutKeysEnabled(self: *const Self) !bool {
        if (mbind_is_shortcut_keys_enabled == null) {
            mbind_is_shortcut_keys_enabled = try api.createMethod("TextEdit", "is_shortcut_keys_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_shortcut_keys_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isShowLineNumbersEnabled(self: *const Self) !bool {
        if (mbind_is_show_line_numbers_enabled == null) {
            mbind_is_show_line_numbers_enabled = try api.createMethod("TextEdit", "is_show_line_numbers_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_show_line_numbers_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSmoothScrollEnabled(self: *const Self) !bool {
        if (mbind_is_smooth_scroll_enabled == null) {
            mbind_is_smooth_scroll_enabled = try api.createMethod("TextEdit", "is_smooth_scroll_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_smooth_scroll_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSyntaxColoringEnabled(self: *const Self) !bool {
        if (mbind_is_syntax_coloring_enabled == null) {
            mbind_is_syntax_coloring_enabled = try api.createMethod("TextEdit", "is_syntax_coloring_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_syntax_coloring_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVirtualKeyboardEnabled(self: *const Self) !bool {
        if (mbind_is_virtual_keyboard_enabled == null) {
            mbind_is_virtual_keyboard_enabled = try api.createMethod("TextEdit", "is_virtual_keyboard_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_virtual_keyboard_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWrapEnabled(self: *const Self) !bool {
        if (mbind_is_wrap_enabled == null) {
            mbind_is_wrap_enabled = try api.createMethod("TextEdit", "is_wrap_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_wrap_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn menuOption(self: *const Self, arg_option: i32) !void {
        if (mbind_menu_option == null) {
            mbind_menu_option = try api.createMethod("TextEdit", "menu_option");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_option),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_menu_option, base, cargs, result);
    }

    pub fn paste(self: *const Self) !void {
        if (mbind_paste == null) {
            mbind_paste = try api.createMethod("TextEdit", "paste");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_paste, base, cargs, result);
    }

    pub fn redo(self: *const Self) !void {
        if (mbind_redo == null) {
            mbind_redo = try api.createMethod("TextEdit", "redo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_redo, base, cargs, result);
    }

    pub fn removeBreakpoints(self: *const Self) !void {
        if (mbind_remove_breakpoints == null) {
            mbind_remove_breakpoints = try api.createMethod("TextEdit", "remove_breakpoints");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_breakpoints, base, cargs, result);
    }

    pub fn search(self: *const Self, arg_key: *const godot.String, arg_flags: i32, arg_from_line: i32, arg_from_column: i32) !godot.PoolIntArray {
        if (mbind_search == null) {
            mbind_search = try api.createMethod("TextEdit", "search");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_key),
            @ptrCast(*const anyopaque, *arg_flags),
            @ptrCast(*const anyopaque, *arg_from_line),
            @ptrCast(*const anyopaque, *arg_from_column),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_search, base, cargs, result);
        return @ptrCast(*godot.PoolIntArray, @alignCast(@alignOf(&godot.PoolIntArray), result)).*;
    }

    pub fn select(self: *const Self, arg_from_line: i32, arg_from_column: i32, arg_to_line: i32, arg_to_column: i32) !void {
        if (mbind_select == null) {
            mbind_select = try api.createMethod("TextEdit", "select");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_from_line),
            @ptrCast(*const anyopaque, *arg_from_column),
            @ptrCast(*const anyopaque, *arg_to_line),
            @ptrCast(*const anyopaque, *arg_to_column),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_select, base, cargs, result);
    }

    pub fn selectAll(self: *const Self) !void {
        if (mbind_select_all == null) {
            mbind_select_all = try api.createMethod("TextEdit", "select_all");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_select_all, base, cargs, result);
    }

    pub fn setBookmarkGutterEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_bookmark_gutter_enabled == null) {
            mbind_set_bookmark_gutter_enabled = try api.createMethod("TextEdit", "set_bookmark_gutter_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_bookmark_gutter_enabled, base, cargs, result);
    }

    pub fn setBreakpointGutterEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_breakpoint_gutter_enabled == null) {
            mbind_set_breakpoint_gutter_enabled = try api.createMethod("TextEdit", "set_breakpoint_gutter_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_breakpoint_gutter_enabled, base, cargs, result);
    }

    pub fn setContextMenuEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_context_menu_enabled == null) {
            mbind_set_context_menu_enabled = try api.createMethod("TextEdit", "set_context_menu_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_context_menu_enabled, base, cargs, result);
    }

    pub fn setDrawFoldGutter(self: *const Self, arg_arg0: bool) !void {
        if (mbind_set_draw_fold_gutter == null) {
            mbind_set_draw_fold_gutter = try api.createMethod("TextEdit", "set_draw_fold_gutter");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_arg0),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_draw_fold_gutter, base, cargs, result);
    }

    pub fn setDrawSpaces(self: *const Self, arg_arg0: bool) !void {
        if (mbind_set_draw_spaces == null) {
            mbind_set_draw_spaces = try api.createMethod("TextEdit", "set_draw_spaces");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_arg0),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_draw_spaces, base, cargs, result);
    }

    pub fn setDrawTabs(self: *const Self, arg_arg0: bool) !void {
        if (mbind_set_draw_tabs == null) {
            mbind_set_draw_tabs = try api.createMethod("TextEdit", "set_draw_tabs");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_arg0),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_draw_tabs, base, cargs, result);
    }

    pub fn setHScroll(self: *const Self, arg_value: i32) !void {
        if (mbind_set_h_scroll == null) {
            mbind_set_h_scroll = try api.createMethod("TextEdit", "set_h_scroll");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_h_scroll, base, cargs, result);
    }

    pub fn setHidingEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hiding_enabled == null) {
            mbind_set_hiding_enabled = try api.createMethod("TextEdit", "set_hiding_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hiding_enabled, base, cargs, result);
    }

    pub fn setHighlightAllOccurrences(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_highlight_all_occurrences == null) {
            mbind_set_highlight_all_occurrences = try api.createMethod("TextEdit", "set_highlight_all_occurrences");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_highlight_all_occurrences, base, cargs, result);
    }

    pub fn setHighlightCurrentLine(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_highlight_current_line == null) {
            mbind_set_highlight_current_line = try api.createMethod("TextEdit", "set_highlight_current_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_highlight_current_line, base, cargs, result);
    }

    pub fn setLine(self: *const Self, arg_line: i32, arg_new_text: *const godot.String) !void {
        if (mbind_set_line == null) {
            mbind_set_line = try api.createMethod("TextEdit", "set_line");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, arg_new_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line, base, cargs, result);
    }

    pub fn setLineAsBookmark(self: *const Self, arg_line: i32, arg_bookmark: bool) !void {
        if (mbind_set_line_as_bookmark == null) {
            mbind_set_line_as_bookmark = try api.createMethod("TextEdit", "set_line_as_bookmark");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_bookmark),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line_as_bookmark, base, cargs, result);
    }

    pub fn setLineAsBreakpoint(self: *const Self, arg_line: i32, arg_breakpoint: bool) !void {
        if (mbind_set_line_as_breakpoint == null) {
            mbind_set_line_as_breakpoint = try api.createMethod("TextEdit", "set_line_as_breakpoint");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_breakpoint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line_as_breakpoint, base, cargs, result);
    }

    pub fn setLineAsHidden(self: *const Self, arg_line: i32, arg_enable: bool) !void {
        if (mbind_set_line_as_hidden == null) {
            mbind_set_line_as_hidden = try api.createMethod("TextEdit", "set_line_as_hidden");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line_as_hidden, base, cargs, result);
    }

    pub fn setLineAsSafe(self: *const Self, arg_line: i32, arg_safe: bool) !void {
        if (mbind_set_line_as_safe == null) {
            mbind_set_line_as_safe = try api.createMethod("TextEdit", "set_line_as_safe");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
            @ptrCast(*const anyopaque, *arg_safe),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_line_as_safe, base, cargs, result);
    }

    pub fn setMinimapWidth(self: *const Self, arg_width: i32) !void {
        if (mbind_set_minimap_width == null) {
            mbind_set_minimap_width = try api.createMethod("TextEdit", "set_minimap_width");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_minimap_width, base, cargs, result);
    }

    pub fn setOverrideSelectedFontColor(self: *const Self, arg_override: bool) !void {
        if (mbind_set_override_selected_font_color == null) {
            mbind_set_override_selected_font_color = try api.createMethod("TextEdit", "set_override_selected_font_color");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_override),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_override_selected_font_color, base, cargs, result);
    }

    pub fn setReadonly(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_readonly == null) {
            mbind_set_readonly = try api.createMethod("TextEdit", "set_readonly");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_readonly, base, cargs, result);
    }

    pub fn setRightClickMovesCaret(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_right_click_moves_caret == null) {
            mbind_set_right_click_moves_caret = try api.createMethod("TextEdit", "set_right_click_moves_caret");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_right_click_moves_caret, base, cargs, result);
    }

    pub fn setSelectingEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_selecting_enabled == null) {
            mbind_set_selecting_enabled = try api.createMethod("TextEdit", "set_selecting_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_selecting_enabled, base, cargs, result);
    }

    pub fn setShortcutKeysEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_shortcut_keys_enabled == null) {
            mbind_set_shortcut_keys_enabled = try api.createMethod("TextEdit", "set_shortcut_keys_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_shortcut_keys_enabled, base, cargs, result);
    }

    pub fn setShowLineNumbers(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_show_line_numbers == null) {
            mbind_set_show_line_numbers = try api.createMethod("TextEdit", "set_show_line_numbers");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_show_line_numbers, base, cargs, result);
    }

    pub fn setSmoothScrollEnable(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_smooth_scroll_enable == null) {
            mbind_set_smooth_scroll_enable = try api.createMethod("TextEdit", "set_smooth_scroll_enable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_smooth_scroll_enable, base, cargs, result);
    }

    pub fn setSyntaxColoring(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_syntax_coloring == null) {
            mbind_set_syntax_coloring = try api.createMethod("TextEdit", "set_syntax_coloring");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_syntax_coloring, base, cargs, result);
    }

    pub fn setText(self: *const Self, arg_text: *const godot.String) !void {
        if (mbind_set_text == null) {
            mbind_set_text = try api.createMethod("TextEdit", "set_text");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_text, base, cargs, result);
    }

    pub fn setVScroll(self: *const Self, arg_value: f32) !void {
        if (mbind_set_v_scroll == null) {
            mbind_set_v_scroll = try api.createMethod("TextEdit", "set_v_scroll");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_v_scroll, base, cargs, result);
    }

    pub fn setVScrollSpeed(self: *const Self, arg_speed: f32) !void {
        if (mbind_set_v_scroll_speed == null) {
            mbind_set_v_scroll_speed = try api.createMethod("TextEdit", "set_v_scroll_speed");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_speed),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_v_scroll_speed, base, cargs, result);
    }

    pub fn setVirtualKeyboardEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_virtual_keyboard_enabled == null) {
            mbind_set_virtual_keyboard_enabled = try api.createMethod("TextEdit", "set_virtual_keyboard_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_virtual_keyboard_enabled, base, cargs, result);
    }

    pub fn setWrapEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_wrap_enabled == null) {
            mbind_set_wrap_enabled = try api.createMethod("TextEdit", "set_wrap_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_wrap_enabled, base, cargs, result);
    }

    pub fn toggleFoldLine(self: *const Self, arg_line: i32) !void {
        if (mbind_toggle_fold_line == null) {
            mbind_toggle_fold_line = try api.createMethod("TextEdit", "toggle_fold_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_toggle_fold_line, base, cargs, result);
    }

    pub fn undo(self: *const Self) !void {
        if (mbind_undo == null) {
            mbind_undo = try api.createMethod("TextEdit", "undo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_undo, base, cargs, result);
    }

    pub fn unfoldLine(self: *const Self, arg_line: i32) !void {
        if (mbind_unfold_line == null) {
            mbind_unfold_line = try api.createMethod("TextEdit", "unfold_line");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_line),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unfold_line, base, cargs, result);
    }

    pub fn unhideAllLines(self: *const Self) !void {
        if (mbind_unhide_all_lines == null) {
            mbind_unhide_all_lines = try api.createMethod("TextEdit", "unhide_all_lines");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unhide_all_lines, base, cargs, result);
    }
};