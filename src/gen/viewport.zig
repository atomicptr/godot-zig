// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_find_world: ?*c_api.godot_method_bind = null;
var mbind_find_world_2d: ?*c_api.godot_method_bind = null;
var mbind_get_camera: ?*c_api.godot_method_bind = null;
var mbind_get_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_get_clear_mode: ?*c_api.godot_method_bind = null;
var mbind_get_debug_draw: ?*c_api.godot_method_bind = null;
var mbind_get_final_transform: ?*c_api.godot_method_bind = null;
var mbind_get_global_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_get_hdr: ?*c_api.godot_method_bind = null;
var mbind_get_keep_3d_linear: ?*c_api.godot_method_bind = null;
var mbind_get_modal_stack_top: ?*c_api.godot_method_bind = null;
var mbind_get_mouse_position: ?*c_api.godot_method_bind = null;
var mbind_get_msaa: ?*c_api.godot_method_bind = null;
var mbind_get_physics_object_picking: ?*c_api.godot_method_bind = null;
var mbind_get_render_info: ?*c_api.godot_method_bind = null;
var mbind_get_shadow_atlas_quadrant_subdiv: ?*c_api.godot_method_bind = null;
var mbind_get_shadow_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_get_sharpen_intensity: ?*c_api.godot_method_bind = null;
var mbind_get_size: ?*c_api.godot_method_bind = null;
var mbind_get_size_override: ?*c_api.godot_method_bind = null;
var mbind_get_texture: ?*c_api.godot_method_bind = null;
var mbind_get_update_mode: ?*c_api.godot_method_bind = null;
var mbind_get_usage: ?*c_api.godot_method_bind = null;
var mbind_get_use_debanding: ?*c_api.godot_method_bind = null;
var mbind_get_use_fxaa: ?*c_api.godot_method_bind = null;
var mbind_get_vflip: ?*c_api.godot_method_bind = null;
var mbind_get_viewport_rid: ?*c_api.godot_method_bind = null;
var mbind_get_visible_rect: ?*c_api.godot_method_bind = null;
var mbind_get_world: ?*c_api.godot_method_bind = null;
var mbind_get_world_2d: ?*c_api.godot_method_bind = null;
var mbind_gui_get_drag_data: ?*c_api.godot_method_bind = null;
var mbind_gui_has_modal_stack: ?*c_api.godot_method_bind = null;
var mbind_gui_is_dragging: ?*c_api.godot_method_bind = null;
var mbind_has_transparent_background: ?*c_api.godot_method_bind = null;
var mbind_input: ?*c_api.godot_method_bind = null;
var mbind_is_3d_disabled: ?*c_api.godot_method_bind = null;
var mbind_is_audio_listener: ?*c_api.godot_method_bind = null;
var mbind_is_audio_listener_2d: ?*c_api.godot_method_bind = null;
var mbind_is_handling_input_locally: ?*c_api.godot_method_bind = null;
var mbind_is_input_disabled: ?*c_api.godot_method_bind = null;
var mbind_is_input_handled: ?*c_api.godot_method_bind = null;
var mbind_is_size_override_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_size_override_stretch_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_snap_controls_to_pixels_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_using_own_world: ?*c_api.godot_method_bind = null;
var mbind_is_using_render_direct_to_screen: ?*c_api.godot_method_bind = null;
var mbind_set_as_audio_listener: ?*c_api.godot_method_bind = null;
var mbind_set_as_audio_listener_2d: ?*c_api.godot_method_bind = null;
var mbind_set_attach_to_screen_rect: ?*c_api.godot_method_bind = null;
var mbind_set_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_set_clear_mode: ?*c_api.godot_method_bind = null;
var mbind_set_debug_draw: ?*c_api.godot_method_bind = null;
var mbind_set_disable_3d: ?*c_api.godot_method_bind = null;
var mbind_set_disable_input: ?*c_api.godot_method_bind = null;
var mbind_set_global_canvas_transform: ?*c_api.godot_method_bind = null;
var mbind_set_handle_input_locally: ?*c_api.godot_method_bind = null;
var mbind_set_hdr: ?*c_api.godot_method_bind = null;
var mbind_set_input_as_handled: ?*c_api.godot_method_bind = null;
var mbind_set_keep_3d_linear: ?*c_api.godot_method_bind = null;
var mbind_set_msaa: ?*c_api.godot_method_bind = null;
var mbind_set_physics_object_picking: ?*c_api.godot_method_bind = null;
var mbind_set_shadow_atlas_quadrant_subdiv: ?*c_api.godot_method_bind = null;
var mbind_set_shadow_atlas_size: ?*c_api.godot_method_bind = null;
var mbind_set_sharpen_intensity: ?*c_api.godot_method_bind = null;
var mbind_set_size: ?*c_api.godot_method_bind = null;
var mbind_set_size_override: ?*c_api.godot_method_bind = null;
var mbind_set_size_override_stretch: ?*c_api.godot_method_bind = null;
var mbind_set_snap_controls_to_pixels: ?*c_api.godot_method_bind = null;
var mbind_set_transparent_background: ?*c_api.godot_method_bind = null;
var mbind_set_update_mode: ?*c_api.godot_method_bind = null;
var mbind_set_usage: ?*c_api.godot_method_bind = null;
var mbind_set_use_arvr: ?*c_api.godot_method_bind = null;
var mbind_set_use_debanding: ?*c_api.godot_method_bind = null;
var mbind_set_use_fxaa: ?*c_api.godot_method_bind = null;
var mbind_set_use_own_world: ?*c_api.godot_method_bind = null;
var mbind_set_use_render_direct_to_screen: ?*c_api.godot_method_bind = null;
var mbind_set_vflip: ?*c_api.godot_method_bind = null;
var mbind_set_world: ?*c_api.godot_method_bind = null;
var mbind_set_world_2d: ?*c_api.godot_method_bind = null;
var mbind_unhandled_input: ?*c_api.godot_method_bind = null;
var mbind_update_worlds: ?*c_api.godot_method_bind = null;
var mbind_use_arvr: ?*c_api.godot_method_bind = null;
var mbind_warp_mouse: ?*c_api.godot_method_bind = null;
var mbind_viewport_constructor: ?fn () ?*c_api.godot_object = null;

pub const Viewport = struct {
    const Self = @This();
    pub const BaseClass = godot.Node;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_viewport_constructor == null) {
            mbind_viewport_constructor = try api.createConstructor("Viewport");
        }
        return api.createObject(Self, mbind_viewport_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn findWorld(self: *const Self) !godot.World {
        if (mbind_find_world == null) {
            mbind_find_world = try api.createMethod("Viewport", "find_world");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_world, base, cargs, result);
        return @ptrCast(*godot.World, @alignCast(@alignOf(&godot.World), result)).*;
    }

    pub fn findWorld2d(self: *const Self) !godot.World2D {
        if (mbind_find_world_2d == null) {
            mbind_find_world_2d = try api.createMethod("Viewport", "find_world_2d");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_world_2d, base, cargs, result);
        return @ptrCast(*godot.World2D, @alignCast(@alignOf(&godot.World2D), result)).*;
    }

    pub fn getCamera(self: *const Self) !godot.Camera {
        if (mbind_get_camera == null) {
            mbind_get_camera = try api.createMethod("Viewport", "get_camera");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_camera, base, cargs, result);
        return @ptrCast(*godot.Camera, @alignCast(@alignOf(&godot.Camera), result)).*;
    }

    pub fn getCanvasTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_canvas_transform == null) {
            mbind_get_canvas_transform = try api.createMethod("Viewport", "get_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_canvas_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getClearMode(self: *const Self) !i32 {
        if (mbind_get_clear_mode == null) {
            mbind_get_clear_mode = try api.createMethod("Viewport", "get_clear_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_clear_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDebugDraw(self: *const Self) !i32 {
        if (mbind_get_debug_draw == null) {
            mbind_get_debug_draw = try api.createMethod("Viewport", "get_debug_draw");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_debug_draw, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getFinalTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_final_transform == null) {
            mbind_get_final_transform = try api.createMethod("Viewport", "get_final_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_final_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getGlobalCanvasTransform(self: *const Self) !godot.Transform2D {
        if (mbind_get_global_canvas_transform == null) {
            mbind_get_global_canvas_transform = try api.createMethod("Viewport", "get_global_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_canvas_transform, base, cargs, result);
        return @ptrCast(*godot.Transform2D, @alignCast(@alignOf(&godot.Transform2D), result)).*;
    }

    pub fn getHdr(self: *const Self) !bool {
        if (mbind_get_hdr == null) {
            mbind_get_hdr = try api.createMethod("Viewport", "get_hdr");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_hdr, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getKeep3dLinear(self: *const Self) !bool {
        if (mbind_get_keep_3d_linear == null) {
            mbind_get_keep_3d_linear = try api.createMethod("Viewport", "get_keep_3d_linear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_keep_3d_linear, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getModalStackTop(self: *const Self) !godot.Control {
        if (mbind_get_modal_stack_top == null) {
            mbind_get_modal_stack_top = try api.createMethod("Viewport", "get_modal_stack_top");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_modal_stack_top, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn getMousePosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_mouse_position == null) {
            mbind_get_mouse_position = try api.createMethod("Viewport", "get_mouse_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_mouse_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getMsaa(self: *const Self) !i32 {
        if (mbind_get_msaa == null) {
            mbind_get_msaa = try api.createMethod("Viewport", "get_msaa");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_msaa, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPhysicsObjectPicking(self: *const Self) !bool {
        if (mbind_get_physics_object_picking == null) {
            mbind_get_physics_object_picking = try api.createMethod("Viewport", "get_physics_object_picking");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_physics_object_picking, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getRenderInfo(self: *const Self, arg_info: i32) !i32 {
        if (mbind_get_render_info == null) {
            mbind_get_render_info = try api.createMethod("Viewport", "get_render_info");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_info),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_render_info, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getShadowAtlasQuadrantSubdiv(self: *const Self, arg_quadrant: i32) !i32 {
        if (mbind_get_shadow_atlas_quadrant_subdiv == null) {
            mbind_get_shadow_atlas_quadrant_subdiv = try api.createMethod("Viewport", "get_shadow_atlas_quadrant_subdiv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_quadrant),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_shadow_atlas_quadrant_subdiv, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getShadowAtlasSize(self: *const Self) !i32 {
        if (mbind_get_shadow_atlas_size == null) {
            mbind_get_shadow_atlas_size = try api.createMethod("Viewport", "get_shadow_atlas_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_shadow_atlas_size, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSharpenIntensity(self: *const Self) !f32 {
        if (mbind_get_sharpen_intensity == null) {
            mbind_get_sharpen_intensity = try api.createMethod("Viewport", "get_sharpen_intensity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_sharpen_intensity, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_size == null) {
            mbind_get_size = try api.createMethod("Viewport", "get_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getSizeOverride(self: *const Self) !godot.Vector2 {
        if (mbind_get_size_override == null) {
            mbind_get_size_override = try api.createMethod("Viewport", "get_size_override");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_size_override, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getTexture(self: *const Self) !godot.ViewportTexture {
        if (mbind_get_texture == null) {
            mbind_get_texture = try api.createMethod("Viewport", "get_texture");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_texture, base, cargs, result);
        return @ptrCast(*godot.ViewportTexture, @alignCast(@alignOf(&godot.ViewportTexture), result)).*;
    }

    pub fn getUpdateMode(self: *const Self) !i32 {
        if (mbind_get_update_mode == null) {
            mbind_get_update_mode = try api.createMethod("Viewport", "get_update_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_update_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getUsage(self: *const Self) !i32 {
        if (mbind_get_usage == null) {
            mbind_get_usage = try api.createMethod("Viewport", "get_usage");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_usage, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getUseDebanding(self: *const Self) !bool {
        if (mbind_get_use_debanding == null) {
            mbind_get_use_debanding = try api.createMethod("Viewport", "get_use_debanding");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_use_debanding, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getUseFxaa(self: *const Self) !bool {
        if (mbind_get_use_fxaa == null) {
            mbind_get_use_fxaa = try api.createMethod("Viewport", "get_use_fxaa");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_use_fxaa, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getVflip(self: *const Self) !bool {
        if (mbind_get_vflip == null) {
            mbind_get_vflip = try api.createMethod("Viewport", "get_vflip");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_vflip, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getViewportRid(self: *const Self) !godot.RID {
        if (mbind_get_viewport_rid == null) {
            mbind_get_viewport_rid = try api.createMethod("Viewport", "get_viewport_rid");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_viewport_rid, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn getVisibleRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_visible_rect == null) {
            mbind_get_visible_rect = try api.createMethod("Viewport", "get_visible_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_visible_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getWorld(self: *const Self) !godot.World {
        if (mbind_get_world == null) {
            mbind_get_world = try api.createMethod("Viewport", "get_world");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_world, base, cargs, result);
        return @ptrCast(*godot.World, @alignCast(@alignOf(&godot.World), result)).*;
    }

    pub fn getWorld2d(self: *const Self) !godot.World2D {
        if (mbind_get_world_2d == null) {
            mbind_get_world_2d = try api.createMethod("Viewport", "get_world_2d");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_world_2d, base, cargs, result);
        return @ptrCast(*godot.World2D, @alignCast(@alignOf(&godot.World2D), result)).*;
    }

    pub fn guiGetDragData(self: *const Self) !godot.Variant {
        if (mbind_gui_get_drag_data == null) {
            mbind_gui_get_drag_data = try api.createMethod("Viewport", "gui_get_drag_data");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gui_get_drag_data, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn guiHasModalStack(self: *const Self) !bool {
        if (mbind_gui_has_modal_stack == null) {
            mbind_gui_has_modal_stack = try api.createMethod("Viewport", "gui_has_modal_stack");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gui_has_modal_stack, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn guiIsDragging(self: *const Self) !bool {
        if (mbind_gui_is_dragging == null) {
            mbind_gui_is_dragging = try api.createMethod("Viewport", "gui_is_dragging");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_gui_is_dragging, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasTransparentBackground(self: *const Self) !bool {
        if (mbind_has_transparent_background == null) {
            mbind_has_transparent_background = try api.createMethod("Viewport", "has_transparent_background");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_transparent_background, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn input(self: *const Self, arg_local_event: *const godot.InputEvent) !void {
        if (mbind_input == null) {
            mbind_input = try api.createMethod("Viewport", "input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_local_event),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_input, base, cargs, result);
    }

    pub fn is3dDisabled(self: *const Self) !bool {
        if (mbind_is_3d_disabled == null) {
            mbind_is_3d_disabled = try api.createMethod("Viewport", "is_3d_disabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_3d_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isAudioListener(self: *const Self) !bool {
        if (mbind_is_audio_listener == null) {
            mbind_is_audio_listener = try api.createMethod("Viewport", "is_audio_listener");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_audio_listener, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isAudioListener2d(self: *const Self) !bool {
        if (mbind_is_audio_listener_2d == null) {
            mbind_is_audio_listener_2d = try api.createMethod("Viewport", "is_audio_listener_2d");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_audio_listener_2d, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isHandlingInputLocally(self: *const Self) !bool {
        if (mbind_is_handling_input_locally == null) {
            mbind_is_handling_input_locally = try api.createMethod("Viewport", "is_handling_input_locally");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_handling_input_locally, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInputDisabled(self: *const Self) !bool {
        if (mbind_is_input_disabled == null) {
            mbind_is_input_disabled = try api.createMethod("Viewport", "is_input_disabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_input_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInputHandled(self: *const Self) !bool {
        if (mbind_is_input_handled == null) {
            mbind_is_input_handled = try api.createMethod("Viewport", "is_input_handled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_input_handled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSizeOverrideEnabled(self: *const Self) !bool {
        if (mbind_is_size_override_enabled == null) {
            mbind_is_size_override_enabled = try api.createMethod("Viewport", "is_size_override_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_size_override_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSizeOverrideStretchEnabled(self: *const Self) !bool {
        if (mbind_is_size_override_stretch_enabled == null) {
            mbind_is_size_override_stretch_enabled = try api.createMethod("Viewport", "is_size_override_stretch_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_size_override_stretch_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSnapControlsToPixelsEnabled(self: *const Self) !bool {
        if (mbind_is_snap_controls_to_pixels_enabled == null) {
            mbind_is_snap_controls_to_pixels_enabled = try api.createMethod("Viewport", "is_snap_controls_to_pixels_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_snap_controls_to_pixels_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingOwnWorld(self: *const Self) !bool {
        if (mbind_is_using_own_world == null) {
            mbind_is_using_own_world = try api.createMethod("Viewport", "is_using_own_world");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_own_world, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingRenderDirectToScreen(self: *const Self) !bool {
        if (mbind_is_using_render_direct_to_screen == null) {
            mbind_is_using_render_direct_to_screen = try api.createMethod("Viewport", "is_using_render_direct_to_screen");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_render_direct_to_screen, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setAsAudioListener(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_as_audio_listener == null) {
            mbind_set_as_audio_listener = try api.createMethod("Viewport", "set_as_audio_listener");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_as_audio_listener, base, cargs, result);
    }

    pub fn setAsAudioListener2d(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_as_audio_listener_2d == null) {
            mbind_set_as_audio_listener_2d = try api.createMethod("Viewport", "set_as_audio_listener_2d");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_as_audio_listener_2d, base, cargs, result);
    }

    pub fn setAttachToScreenRect(self: *const Self, arg_rect: *const godot.Rect2) !void {
        if (mbind_set_attach_to_screen_rect == null) {
            mbind_set_attach_to_screen_rect = try api.createMethod("Viewport", "set_attach_to_screen_rect");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_attach_to_screen_rect, base, cargs, result);
    }

    pub fn setCanvasTransform(self: *const Self, arg_xform: *const godot.Transform2D) !void {
        if (mbind_set_canvas_transform == null) {
            mbind_set_canvas_transform = try api.createMethod("Viewport", "set_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_xform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_canvas_transform, base, cargs, result);
    }

    pub fn setClearMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_clear_mode == null) {
            mbind_set_clear_mode = try api.createMethod("Viewport", "set_clear_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clear_mode, base, cargs, result);
    }

    pub fn setDebugDraw(self: *const Self, arg_debug_draw: i32) !void {
        if (mbind_set_debug_draw == null) {
            mbind_set_debug_draw = try api.createMethod("Viewport", "set_debug_draw");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_debug_draw),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_debug_draw, base, cargs, result);
    }

    pub fn setDisable3d(self: *const Self, arg_disable: bool) !void {
        if (mbind_set_disable_3d == null) {
            mbind_set_disable_3d = try api.createMethod("Viewport", "set_disable_3d");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_disable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_disable_3d, base, cargs, result);
    }

    pub fn setDisableInput(self: *const Self, arg_disable: bool) !void {
        if (mbind_set_disable_input == null) {
            mbind_set_disable_input = try api.createMethod("Viewport", "set_disable_input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_disable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_disable_input, base, cargs, result);
    }

    pub fn setGlobalCanvasTransform(self: *const Self, arg_xform: *const godot.Transform2D) !void {
        if (mbind_set_global_canvas_transform == null) {
            mbind_set_global_canvas_transform = try api.createMethod("Viewport", "set_global_canvas_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_xform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_global_canvas_transform, base, cargs, result);
    }

    pub fn setHandleInputLocally(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_handle_input_locally == null) {
            mbind_set_handle_input_locally = try api.createMethod("Viewport", "set_handle_input_locally");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_handle_input_locally, base, cargs, result);
    }

    pub fn setHdr(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_hdr == null) {
            mbind_set_hdr = try api.createMethod("Viewport", "set_hdr");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_hdr, base, cargs, result);
    }

    pub fn setInputAsHandled(self: *const Self) !void {
        if (mbind_set_input_as_handled == null) {
            mbind_set_input_as_handled = try api.createMethod("Viewport", "set_input_as_handled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_input_as_handled, base, cargs, result);
    }

    pub fn setKeep3dLinear(self: *const Self, arg_keep_3d_linear: bool) !void {
        if (mbind_set_keep_3d_linear == null) {
            mbind_set_keep_3d_linear = try api.createMethod("Viewport", "set_keep_3d_linear");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_keep_3d_linear),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_keep_3d_linear, base, cargs, result);
    }

    pub fn setMsaa(self: *const Self, arg_msaa: i32) !void {
        if (mbind_set_msaa == null) {
            mbind_set_msaa = try api.createMethod("Viewport", "set_msaa");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_msaa),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_msaa, base, cargs, result);
    }

    pub fn setPhysicsObjectPicking(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_physics_object_picking == null) {
            mbind_set_physics_object_picking = try api.createMethod("Viewport", "set_physics_object_picking");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_physics_object_picking, base, cargs, result);
    }

    pub fn setShadowAtlasQuadrantSubdiv(self: *const Self, arg_quadrant: i32, arg_subdiv: i32) !void {
        if (mbind_set_shadow_atlas_quadrant_subdiv == null) {
            mbind_set_shadow_atlas_quadrant_subdiv = try api.createMethod("Viewport", "set_shadow_atlas_quadrant_subdiv");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_quadrant),
            @ptrCast(*const anyopaque, *arg_subdiv),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_shadow_atlas_quadrant_subdiv, base, cargs, result);
    }

    pub fn setShadowAtlasSize(self: *const Self, arg_size: i32) !void {
        if (mbind_set_shadow_atlas_size == null) {
            mbind_set_shadow_atlas_size = try api.createMethod("Viewport", "set_shadow_atlas_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_shadow_atlas_size, base, cargs, result);
    }

    pub fn setSharpenIntensity(self: *const Self, arg_intensity: f32) !void {
        if (mbind_set_sharpen_intensity == null) {
            mbind_set_sharpen_intensity = try api.createMethod("Viewport", "set_sharpen_intensity");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_intensity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_sharpen_intensity, base, cargs, result);
    }

    pub fn setSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_size == null) {
            mbind_set_size = try api.createMethod("Viewport", "set_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_size, base, cargs, result);
    }

    pub fn setSizeOverride(self: *const Self, arg_enable: bool, arg_size: *const godot.Vector2, arg_margin: *const godot.Vector2) !void {
        if (mbind_set_size_override == null) {
            mbind_set_size_override = try api.createMethod("Viewport", "set_size_override");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
            @ptrCast(*const anyopaque, arg_size),
            @ptrCast(*const anyopaque, arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_size_override, base, cargs, result);
    }

    pub fn setSizeOverrideStretch(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_size_override_stretch == null) {
            mbind_set_size_override_stretch = try api.createMethod("Viewport", "set_size_override_stretch");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_size_override_stretch, base, cargs, result);
    }

    pub fn setSnapControlsToPixels(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_snap_controls_to_pixels == null) {
            mbind_set_snap_controls_to_pixels = try api.createMethod("Viewport", "set_snap_controls_to_pixels");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_snap_controls_to_pixels, base, cargs, result);
    }

    pub fn setTransparentBackground(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_transparent_background == null) {
            mbind_set_transparent_background = try api.createMethod("Viewport", "set_transparent_background");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_transparent_background, base, cargs, result);
    }

    pub fn setUpdateMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_update_mode == null) {
            mbind_set_update_mode = try api.createMethod("Viewport", "set_update_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_update_mode, base, cargs, result);
    }

    pub fn setUsage(self: *const Self, arg_usage: i32) !void {
        if (mbind_set_usage == null) {
            mbind_set_usage = try api.createMethod("Viewport", "set_usage");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_usage),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_usage, base, cargs, result);
    }

    pub fn setUseArvr(self: *const Self, arg_use: bool) !void {
        if (mbind_set_use_arvr == null) {
            mbind_set_use_arvr = try api.createMethod("Viewport", "set_use_arvr");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_use),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_arvr, base, cargs, result);
    }

    pub fn setUseDebanding(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_debanding == null) {
            mbind_set_use_debanding = try api.createMethod("Viewport", "set_use_debanding");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_debanding, base, cargs, result);
    }

    pub fn setUseFxaa(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_fxaa == null) {
            mbind_set_use_fxaa = try api.createMethod("Viewport", "set_use_fxaa");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_fxaa, base, cargs, result);
    }

    pub fn setUseOwnWorld(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_own_world == null) {
            mbind_set_use_own_world = try api.createMethod("Viewport", "set_use_own_world");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_own_world, base, cargs, result);
    }

    pub fn setUseRenderDirectToScreen(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_render_direct_to_screen == null) {
            mbind_set_use_render_direct_to_screen = try api.createMethod("Viewport", "set_use_render_direct_to_screen");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_render_direct_to_screen, base, cargs, result);
    }

    pub fn setVflip(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_vflip == null) {
            mbind_set_vflip = try api.createMethod("Viewport", "set_vflip");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_vflip, base, cargs, result);
    }

    pub fn setWorld(self: *const Self, arg_world: *const godot.World) !void {
        if (mbind_set_world == null) {
            mbind_set_world = try api.createMethod("Viewport", "set_world");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_world),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_world, base, cargs, result);
    }

    pub fn setWorld2d(self: *const Self, arg_world_2d: *const godot.World2D) !void {
        if (mbind_set_world_2d == null) {
            mbind_set_world_2d = try api.createMethod("Viewport", "set_world_2d");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_world_2d),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_world_2d, base, cargs, result);
    }

    pub fn unhandledInput(self: *const Self, arg_local_event: *const godot.InputEvent) !void {
        if (mbind_unhandled_input == null) {
            mbind_unhandled_input = try api.createMethod("Viewport", "unhandled_input");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_local_event),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unhandled_input, base, cargs, result);
    }

    pub fn updateWorlds(self: *const Self) !void {
        if (mbind_update_worlds == null) {
            mbind_update_worlds = try api.createMethod("Viewport", "update_worlds");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_worlds, base, cargs, result);
    }

    pub fn useArvr(self: *const Self) !bool {
        if (mbind_use_arvr == null) {
            mbind_use_arvr = try api.createMethod("Viewport", "use_arvr");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_use_arvr, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn warpMouse(self: *const Self, arg_to_position: *const godot.Vector2) !void {
        if (mbind_warp_mouse == null) {
            mbind_warp_mouse = try api.createMethod("Viewport", "warp_mouse");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_to_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_warp_mouse, base, cargs, result);
    }
};