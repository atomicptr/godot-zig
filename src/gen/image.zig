// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Resource = @import("resource.zig").Resource;

// method bindings
var mbind_blend_rect: ?*c_api.godot_method_bind = null;
var mbind_blend_rect_mask: ?*c_api.godot_method_bind = null;
var mbind_blit_rect: ?*c_api.godot_method_bind = null;
var mbind_blit_rect_mask: ?*c_api.godot_method_bind = null;
var mbind_bumpmap_to_normalmap: ?*c_api.godot_method_bind = null;
var mbind_clear_mipmaps: ?*c_api.godot_method_bind = null;
var mbind_compress: ?*c_api.godot_method_bind = null;
var mbind_convert: ?*c_api.godot_method_bind = null;
var mbind_copy_from: ?*c_api.godot_method_bind = null;
var mbind_create: ?*c_api.godot_method_bind = null;
var mbind_create_from_data: ?*c_api.godot_method_bind = null;
var mbind_crop: ?*c_api.godot_method_bind = null;
var mbind_decompress: ?*c_api.godot_method_bind = null;
var mbind_detect_alpha: ?*c_api.godot_method_bind = null;
var mbind_expand_x2_hq2x: ?*c_api.godot_method_bind = null;
var mbind_fill: ?*c_api.godot_method_bind = null;
var mbind_fix_alpha_edges: ?*c_api.godot_method_bind = null;
var mbind_flip_x: ?*c_api.godot_method_bind = null;
var mbind_flip_y: ?*c_api.godot_method_bind = null;
var mbind_generate_mipmaps: ?*c_api.godot_method_bind = null;
var mbind_get_data: ?*c_api.godot_method_bind = null;
var mbind_get_format: ?*c_api.godot_method_bind = null;
var mbind_get_height: ?*c_api.godot_method_bind = null;
var mbind_get_mipmap_offset: ?*c_api.godot_method_bind = null;
var mbind_get_pixel: ?*c_api.godot_method_bind = null;
var mbind_get_pixelv: ?*c_api.godot_method_bind = null;
var mbind_get_rect: ?*c_api.godot_method_bind = null;
var mbind_get_size: ?*c_api.godot_method_bind = null;
var mbind_get_used_rect: ?*c_api.godot_method_bind = null;
var mbind_get_width: ?*c_api.godot_method_bind = null;
var mbind_has_mipmaps: ?*c_api.godot_method_bind = null;
var mbind_is_compressed: ?*c_api.godot_method_bind = null;
var mbind_is_empty: ?*c_api.godot_method_bind = null;
var mbind_is_invisible: ?*c_api.godot_method_bind = null;
var mbind_load: ?*c_api.godot_method_bind = null;
var mbind_load_bmp_from_buffer: ?*c_api.godot_method_bind = null;
var mbind_load_jpg_from_buffer: ?*c_api.godot_method_bind = null;
var mbind_load_png_from_buffer: ?*c_api.godot_method_bind = null;
var mbind_load_tga_from_buffer: ?*c_api.godot_method_bind = null;
var mbind_load_webp_from_buffer: ?*c_api.godot_method_bind = null;
var mbind_lock: ?*c_api.godot_method_bind = null;
var mbind_normalmap_to_xy: ?*c_api.godot_method_bind = null;
var mbind_premultiply_alpha: ?*c_api.godot_method_bind = null;
var mbind_resize: ?*c_api.godot_method_bind = null;
var mbind_resize_to_po2: ?*c_api.godot_method_bind = null;
var mbind_rgbe_to_srgb: ?*c_api.godot_method_bind = null;
var mbind_save_exr: ?*c_api.godot_method_bind = null;
var mbind_save_png: ?*c_api.godot_method_bind = null;
var mbind_save_png_to_buffer: ?*c_api.godot_method_bind = null;
var mbind_set_pixel: ?*c_api.godot_method_bind = null;
var mbind_set_pixelv: ?*c_api.godot_method_bind = null;
var mbind_shrink_x2: ?*c_api.godot_method_bind = null;
var mbind_srgb_to_linear: ?*c_api.godot_method_bind = null;
var mbind_unlock: ?*c_api.godot_method_bind = null;
var mbind_image_constructor: ?fn () ?*c_api.godot_object = null;

pub const Image = struct {
    const Self = @This();
    const BaseClass = Resource;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_image_constructor == null) {
            mbind_image_constructor = try api.createConstructor("Image");
        }
        return api.createObject(Self, mbind_image_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn blendRect(self: *const Self, arg_src: *const godot.Image, arg_src_rect: *const godot.Rect2, arg_dst: *const godot.Vector2) !void {
        if (mbind_blend_rect == null) {
            mbind_blend_rect = try api.createMethod("Image", "blend_rect");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_dst),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend_rect, base, cargs, result);
    }

    pub fn blendRectMask(self: *const Self, arg_src: *const godot.Image, arg_mask: *const godot.Image, arg_src_rect: *const godot.Rect2, arg_dst: *const godot.Vector2) !void {
        if (mbind_blend_rect_mask == null) {
            mbind_blend_rect_mask = try api.createMethod("Image", "blend_rect_mask");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
            @ptrCast(*const anyopaque, arg_mask),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_dst),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend_rect_mask, base, cargs, result);
    }

    pub fn blitRect(self: *const Self, arg_src: *const godot.Image, arg_src_rect: *const godot.Rect2, arg_dst: *const godot.Vector2) !void {
        if (mbind_blit_rect == null) {
            mbind_blit_rect = try api.createMethod("Image", "blit_rect");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_dst),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blit_rect, base, cargs, result);
    }

    pub fn blitRectMask(self: *const Self, arg_src: *const godot.Image, arg_mask: *const godot.Image, arg_src_rect: *const godot.Rect2, arg_dst: *const godot.Vector2) !void {
        if (mbind_blit_rect_mask == null) {
            mbind_blit_rect_mask = try api.createMethod("Image", "blit_rect_mask");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
            @ptrCast(*const anyopaque, arg_mask),
            @ptrCast(*const anyopaque, arg_src_rect),
            @ptrCast(*const anyopaque, arg_dst),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blit_rect_mask, base, cargs, result);
    }

    pub fn bumpmapToNormalmap(self: *const Self, arg_bump_scale: f32) !void {
        if (mbind_bumpmap_to_normalmap == null) {
            mbind_bumpmap_to_normalmap = try api.createMethod("Image", "bumpmap_to_normalmap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_bump_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_bumpmap_to_normalmap, base, cargs, result);
    }

    pub fn clearMipmaps(self: *const Self) !void {
        if (mbind_clear_mipmaps == null) {
            mbind_clear_mipmaps = try api.createMethod("Image", "clear_mipmaps");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_mipmaps, base, cargs, result);
    }

    pub fn compress(self: *const Self, arg_mode: i32, arg_source: i32, arg_lossy_quality: f32) !i32 {
        if (mbind_compress == null) {
            mbind_compress = try api.createMethod("Image", "compress");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
            @ptrCast(*const anyopaque, *arg_source),
            @ptrCast(*const anyopaque, *arg_lossy_quality),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_compress, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn convert(self: *const Self, arg_format: i32) !void {
        if (mbind_convert == null) {
            mbind_convert = try api.createMethod("Image", "convert");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_format),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_convert, base, cargs, result);
    }

    pub fn copyFrom(self: *const Self, arg_src: *const godot.Image) !void {
        if (mbind_copy_from == null) {
            mbind_copy_from = try api.createMethod("Image", "copy_from");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_copy_from, base, cargs, result);
    }

    pub fn create(self: *const Self, arg_width: i32, arg_height: i32, arg_use_mipmaps: bool, arg_format: i32) !void {
        if (mbind_create == null) {
            mbind_create = try api.createMethod("Image", "create");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_use_mipmaps),
            @ptrCast(*const anyopaque, *arg_format),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_create, base, cargs, result);
    }

    pub fn createFromData(self: *const Self, arg_width: i32, arg_height: i32, arg_use_mipmaps: bool, arg_format: i32, arg_data: *const godot.PoolByteArray) !void {
        if (mbind_create_from_data == null) {
            mbind_create_from_data = try api.createMethod("Image", "create_from_data");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_use_mipmaps),
            @ptrCast(*const anyopaque, *arg_format),
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_create_from_data, base, cargs, result);
    }

    pub fn crop(self: *const Self, arg_width: i32, arg_height: i32) !void {
        if (mbind_crop == null) {
            mbind_crop = try api.createMethod("Image", "crop");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_crop, base, cargs, result);
    }

    pub fn decompress(self: *const Self) !i32 {
        if (mbind_decompress == null) {
            mbind_decompress = try api.createMethod("Image", "decompress");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_decompress, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn detectAlpha(self: *const Self) !i32 {
        if (mbind_detect_alpha == null) {
            mbind_detect_alpha = try api.createMethod("Image", "detect_alpha");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_detect_alpha, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn expandX2Hq2x(self: *const Self) !void {
        if (mbind_expand_x2_hq2x == null) {
            mbind_expand_x2_hq2x = try api.createMethod("Image", "expand_x2_hq2x");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_expand_x2_hq2x, base, cargs, result);
    }

    pub fn fill(self: *const Self, arg_color: *const godot.Color) !void {
        if (mbind_fill == null) {
            mbind_fill = try api.createMethod("Image", "fill");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_fill, base, cargs, result);
    }

    pub fn fixAlphaEdges(self: *const Self) !void {
        if (mbind_fix_alpha_edges == null) {
            mbind_fix_alpha_edges = try api.createMethod("Image", "fix_alpha_edges");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_fix_alpha_edges, base, cargs, result);
    }

    pub fn flipX(self: *const Self) !void {
        if (mbind_flip_x == null) {
            mbind_flip_x = try api.createMethod("Image", "flip_x");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_flip_x, base, cargs, result);
    }

    pub fn flipY(self: *const Self) !void {
        if (mbind_flip_y == null) {
            mbind_flip_y = try api.createMethod("Image", "flip_y");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_flip_y, base, cargs, result);
    }

    pub fn generateMipmaps(self: *const Self, arg_renormalize: bool) !i32 {
        if (mbind_generate_mipmaps == null) {
            mbind_generate_mipmaps = try api.createMethod("Image", "generate_mipmaps");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_renormalize),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generate_mipmaps, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getData(self: *const Self) !godot.PoolByteArray {
        if (mbind_get_data == null) {
            mbind_get_data = try api.createMethod("Image", "get_data");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_data, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn getFormat(self: *const Self) !i32 {
        if (mbind_get_format == null) {
            mbind_get_format = try api.createMethod("Image", "get_format");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_format, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getHeight(self: *const Self) !i32 {
        if (mbind_get_height == null) {
            mbind_get_height = try api.createMethod("Image", "get_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_height, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMipmapOffset(self: *const Self, arg_mipmap: i32) !i32 {
        if (mbind_get_mipmap_offset == null) {
            mbind_get_mipmap_offset = try api.createMethod("Image", "get_mipmap_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mipmap),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_mipmap_offset, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPixel(self: *const Self, arg_x: i32, arg_y: i32) !godot.Color {
        if (mbind_get_pixel == null) {
            mbind_get_pixel = try api.createMethod("Image", "get_pixel");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pixel, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getPixelv(self: *const Self, arg_src: *const godot.Vector2) !godot.Color {
        if (mbind_get_pixelv == null) {
            mbind_get_pixelv = try api.createMethod("Image", "get_pixelv");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_src),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pixelv, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getRect(self: *const Self, arg_rect: *const godot.Rect2) !godot.Image {
        if (mbind_get_rect == null) {
            mbind_get_rect = try api.createMethod("Image", "get_rect");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rect),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rect, base, cargs, result);
        return @ptrCast(*godot.Image, @alignCast(@alignOf(&godot.Image), result)).*;
    }

    pub fn getSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_size == null) {
            mbind_get_size = try api.createMethod("Image", "get_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getUsedRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_used_rect == null) {
            mbind_get_used_rect = try api.createMethod("Image", "get_used_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_used_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getWidth(self: *const Self) !i32 {
        if (mbind_get_width == null) {
            mbind_get_width = try api.createMethod("Image", "get_width");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_width, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn hasMipmaps(self: *const Self) !bool {
        if (mbind_has_mipmaps == null) {
            mbind_has_mipmaps = try api.createMethod("Image", "has_mipmaps");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_mipmaps, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isCompressed(self: *const Self) !bool {
        if (mbind_is_compressed == null) {
            mbind_is_compressed = try api.createMethod("Image", "is_compressed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_compressed, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isEmpty(self: *const Self) !bool {
        if (mbind_is_empty == null) {
            mbind_is_empty = try api.createMethod("Image", "is_empty");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_empty, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInvisible(self: *const Self) !bool {
        if (mbind_is_invisible == null) {
            mbind_is_invisible = try api.createMethod("Image", "is_invisible");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_invisible, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn load(self: *const Self, arg_path: *const godot.String) !i32 {
        if (mbind_load == null) {
            mbind_load = try api.createMethod("Image", "load");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn loadBmpFromBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_load_bmp_from_buffer == null) {
            mbind_load_bmp_from_buffer = try api.createMethod("Image", "load_bmp_from_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load_bmp_from_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn loadJpgFromBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_load_jpg_from_buffer == null) {
            mbind_load_jpg_from_buffer = try api.createMethod("Image", "load_jpg_from_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load_jpg_from_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn loadPngFromBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_load_png_from_buffer == null) {
            mbind_load_png_from_buffer = try api.createMethod("Image", "load_png_from_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load_png_from_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn loadTgaFromBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_load_tga_from_buffer == null) {
            mbind_load_tga_from_buffer = try api.createMethod("Image", "load_tga_from_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load_tga_from_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn loadWebpFromBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_load_webp_from_buffer == null) {
            mbind_load_webp_from_buffer = try api.createMethod("Image", "load_webp_from_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_load_webp_from_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn lock(self: *const Self) !void {
        if (mbind_lock == null) {
            mbind_lock = try api.createMethod("Image", "lock");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_lock, base, cargs, result);
    }

    pub fn normalmapToXy(self: *const Self) !void {
        if (mbind_normalmap_to_xy == null) {
            mbind_normalmap_to_xy = try api.createMethod("Image", "normalmap_to_xy");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_normalmap_to_xy, base, cargs, result);
    }

    pub fn premultiplyAlpha(self: *const Self) !void {
        if (mbind_premultiply_alpha == null) {
            mbind_premultiply_alpha = try api.createMethod("Image", "premultiply_alpha");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_premultiply_alpha, base, cargs, result);
    }

    pub fn resize(self: *const Self, arg_width: i32, arg_height: i32, arg_interpolation: i32) !void {
        if (mbind_resize == null) {
            mbind_resize = try api.createMethod("Image", "resize");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_width),
            @ptrCast(*const anyopaque, *arg_height),
            @ptrCast(*const anyopaque, *arg_interpolation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_resize, base, cargs, result);
    }

    pub fn resizeToPo2(self: *const Self, arg_square: bool, arg_interpolation: i32) !void {
        if (mbind_resize_to_po2 == null) {
            mbind_resize_to_po2 = try api.createMethod("Image", "resize_to_po2");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_square),
            @ptrCast(*const anyopaque, *arg_interpolation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_resize_to_po2, base, cargs, result);
    }

    pub fn rgbeToSrgb(self: *const Self) !godot.Image {
        if (mbind_rgbe_to_srgb == null) {
            mbind_rgbe_to_srgb = try api.createMethod("Image", "rgbe_to_srgb");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rgbe_to_srgb, base, cargs, result);
        return @ptrCast(*godot.Image, @alignCast(@alignOf(&godot.Image), result)).*;
    }

    pub fn saveExr(self: *const Self, arg_path: *const godot.String, arg_grayscale: bool) !i32 {
        if (mbind_save_exr == null) {
            mbind_save_exr = try api.createMethod("Image", "save_exr");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_grayscale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_save_exr, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn savePng(self: *const Self, arg_path: *const godot.String) !i32 {
        if (mbind_save_png == null) {
            mbind_save_png = try api.createMethod("Image", "save_png");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_save_png, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn savePngToBuffer(self: *const Self) !godot.PoolByteArray {
        if (mbind_save_png_to_buffer == null) {
            mbind_save_png_to_buffer = try api.createMethod("Image", "save_png_to_buffer");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_save_png_to_buffer, base, cargs, result);
        return @ptrCast(*godot.PoolByteArray, @alignCast(@alignOf(&godot.PoolByteArray), result)).*;
    }

    pub fn setPixel(self: *const Self, arg_x: i32, arg_y: i32, arg_color: *const godot.Color) !void {
        if (mbind_set_pixel == null) {
            mbind_set_pixel = try api.createMethod("Image", "set_pixel");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_x),
            @ptrCast(*const anyopaque, *arg_y),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pixel, base, cargs, result);
    }

    pub fn setPixelv(self: *const Self, arg_dst: *const godot.Vector2, arg_color: *const godot.Color) !void {
        if (mbind_set_pixelv == null) {
            mbind_set_pixelv = try api.createMethod("Image", "set_pixelv");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_dst),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pixelv, base, cargs, result);
    }

    pub fn shrinkX2(self: *const Self) !void {
        if (mbind_shrink_x2 == null) {
            mbind_shrink_x2 = try api.createMethod("Image", "shrink_x2");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shrink_x2, base, cargs, result);
    }

    pub fn srgbToLinear(self: *const Self) !void {
        if (mbind_srgb_to_linear == null) {
            mbind_srgb_to_linear = try api.createMethod("Image", "srgb_to_linear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_srgb_to_linear, base, cargs, result);
    }

    pub fn unlock(self: *const Self) !void {
        if (mbind_unlock == null) {
            mbind_unlock = try api.createMethod("Image", "unlock");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_unlock, base, cargs, result);
    }
};