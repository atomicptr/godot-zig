// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const CanvasItem = @import("canvas_item.zig").CanvasItem;

// method bindings
var mbind_accept_event: ?*c_api.godot_method_bind = null;
var mbind_add_color_override: ?*c_api.godot_method_bind = null;
var mbind_add_constant_override: ?*c_api.godot_method_bind = null;
var mbind_add_font_override: ?*c_api.godot_method_bind = null;
var mbind_add_icon_override: ?*c_api.godot_method_bind = null;
var mbind_add_shader_override: ?*c_api.godot_method_bind = null;
var mbind_add_stylebox_override: ?*c_api.godot_method_bind = null;
var mbind_find_next_valid_focus: ?*c_api.godot_method_bind = null;
var mbind_find_prev_valid_focus: ?*c_api.godot_method_bind = null;
var mbind_force_drag: ?*c_api.godot_method_bind = null;
var mbind_get_anchor: ?*c_api.godot_method_bind = null;
var mbind_get_begin: ?*c_api.godot_method_bind = null;
var mbind_get_color: ?*c_api.godot_method_bind = null;
var mbind_get_combined_minimum_size: ?*c_api.godot_method_bind = null;
var mbind_get_constant: ?*c_api.godot_method_bind = null;
var mbind_get_cursor_shape: ?*c_api.godot_method_bind = null;
var mbind_get_custom_minimum_size: ?*c_api.godot_method_bind = null;
var mbind_get_default_cursor_shape: ?*c_api.godot_method_bind = null;
var mbind_get_end: ?*c_api.godot_method_bind = null;
var mbind_get_focus_mode: ?*c_api.godot_method_bind = null;
var mbind_get_focus_neighbour: ?*c_api.godot_method_bind = null;
var mbind_get_focus_next: ?*c_api.godot_method_bind = null;
var mbind_get_focus_owner: ?*c_api.godot_method_bind = null;
var mbind_get_focus_previous: ?*c_api.godot_method_bind = null;
var mbind_get_font: ?*c_api.godot_method_bind = null;
var mbind_get_global_position: ?*c_api.godot_method_bind = null;
var mbind_get_global_rect: ?*c_api.godot_method_bind = null;
var mbind_get_h_grow_direction: ?*c_api.godot_method_bind = null;
var mbind_get_h_size_flags: ?*c_api.godot_method_bind = null;
var mbind_get_icon: ?*c_api.godot_method_bind = null;
var mbind_get_margin: ?*c_api.godot_method_bind = null;
var mbind_get_minimum_size: ?*c_api.godot_method_bind = null;
var mbind_get_mouse_filter: ?*c_api.godot_method_bind = null;
var mbind_get_parent_area_size: ?*c_api.godot_method_bind = null;
var mbind_get_parent_control: ?*c_api.godot_method_bind = null;
var mbind_get_pass_on_modal_close_click: ?*c_api.godot_method_bind = null;
var mbind_get_pivot_offset: ?*c_api.godot_method_bind = null;
var mbind_get_position: ?*c_api.godot_method_bind = null;
var mbind_get_rect: ?*c_api.godot_method_bind = null;
var mbind_get_rotation: ?*c_api.godot_method_bind = null;
var mbind_get_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_get_scale: ?*c_api.godot_method_bind = null;
var mbind_get_size: ?*c_api.godot_method_bind = null;
var mbind_get_stretch_ratio: ?*c_api.godot_method_bind = null;
var mbind_get_stylebox: ?*c_api.godot_method_bind = null;
var mbind_get_theme: ?*c_api.godot_method_bind = null;
var mbind_get_theme_default_font: ?*c_api.godot_method_bind = null;
var mbind_get_tooltip: ?*c_api.godot_method_bind = null;
var mbind_get_v_grow_direction: ?*c_api.godot_method_bind = null;
var mbind_get_v_size_flags: ?*c_api.godot_method_bind = null;
var mbind_grab_click_focus: ?*c_api.godot_method_bind = null;
var mbind_grab_focus: ?*c_api.godot_method_bind = null;
var mbind_has_color: ?*c_api.godot_method_bind = null;
var mbind_has_color_override: ?*c_api.godot_method_bind = null;
var mbind_has_constant: ?*c_api.godot_method_bind = null;
var mbind_has_constant_override: ?*c_api.godot_method_bind = null;
var mbind_has_focus: ?*c_api.godot_method_bind = null;
var mbind_has_font: ?*c_api.godot_method_bind = null;
var mbind_has_font_override: ?*c_api.godot_method_bind = null;
var mbind_has_icon: ?*c_api.godot_method_bind = null;
var mbind_has_icon_override: ?*c_api.godot_method_bind = null;
var mbind_has_shader_override: ?*c_api.godot_method_bind = null;
var mbind_has_stylebox: ?*c_api.godot_method_bind = null;
var mbind_has_stylebox_override: ?*c_api.godot_method_bind = null;
var mbind_is_clipping_contents: ?*c_api.godot_method_bind = null;
var mbind_minimum_size_changed: ?*c_api.godot_method_bind = null;
var mbind_release_focus: ?*c_api.godot_method_bind = null;
var mbind_set_anchor: ?*c_api.godot_method_bind = null;
var mbind_set_anchor_and_margin: ?*c_api.godot_method_bind = null;
var mbind_set_anchors_and_margins_preset: ?*c_api.godot_method_bind = null;
var mbind_set_anchors_preset: ?*c_api.godot_method_bind = null;
var mbind_set_begin: ?*c_api.godot_method_bind = null;
var mbind_set_clip_contents: ?*c_api.godot_method_bind = null;
var mbind_set_custom_minimum_size: ?*c_api.godot_method_bind = null;
var mbind_set_default_cursor_shape: ?*c_api.godot_method_bind = null;
var mbind_set_drag_forwarding: ?*c_api.godot_method_bind = null;
var mbind_set_drag_preview: ?*c_api.godot_method_bind = null;
var mbind_set_end: ?*c_api.godot_method_bind = null;
var mbind_set_focus_mode: ?*c_api.godot_method_bind = null;
var mbind_set_focus_neighbour: ?*c_api.godot_method_bind = null;
var mbind_set_focus_next: ?*c_api.godot_method_bind = null;
var mbind_set_focus_previous: ?*c_api.godot_method_bind = null;
var mbind_set_global_position: ?*c_api.godot_method_bind = null;
var mbind_set_h_grow_direction: ?*c_api.godot_method_bind = null;
var mbind_set_h_size_flags: ?*c_api.godot_method_bind = null;
var mbind_set_margin: ?*c_api.godot_method_bind = null;
var mbind_set_margins_preset: ?*c_api.godot_method_bind = null;
var mbind_set_mouse_filter: ?*c_api.godot_method_bind = null;
var mbind_set_pass_on_modal_close_click: ?*c_api.godot_method_bind = null;
var mbind_set_pivot_offset: ?*c_api.godot_method_bind = null;
var mbind_set_position: ?*c_api.godot_method_bind = null;
var mbind_set_rotation: ?*c_api.godot_method_bind = null;
var mbind_set_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_set_scale: ?*c_api.godot_method_bind = null;
var mbind_set_size: ?*c_api.godot_method_bind = null;
var mbind_set_stretch_ratio: ?*c_api.godot_method_bind = null;
var mbind_set_theme: ?*c_api.godot_method_bind = null;
var mbind_set_tooltip: ?*c_api.godot_method_bind = null;
var mbind_set_v_grow_direction: ?*c_api.godot_method_bind = null;
var mbind_set_v_size_flags: ?*c_api.godot_method_bind = null;
var mbind_show_modal: ?*c_api.godot_method_bind = null;
var mbind_warp_mouse: ?*c_api.godot_method_bind = null;
var mbind_control_constructor: ?fn () ?*c_api.godot_object = null;

pub const Control = struct {
    const Self = @This();
    const BaseClass = CanvasItem;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_control_constructor == null) {
            mbind_control_constructor = try api.createConstructor("Control");
        }
        return api.createObject(Self, mbind_control_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn acceptEvent(self: *const Self) !void {
        if (mbind_accept_event == null) {
            mbind_accept_event = try api.createMethod("Control", "accept_event");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_accept_event, base, cargs, result);
    }

    pub fn addColorOverride(self: *const Self, arg_name: *const godot.String, arg_color: *const godot.Color) !void {
        if (mbind_add_color_override == null) {
            mbind_add_color_override = try api.createMethod("Control", "add_color_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_color_override, base, cargs, result);
    }

    pub fn addConstantOverride(self: *const Self, arg_name: *const godot.String, arg_constant: i32) !void {
        if (mbind_add_constant_override == null) {
            mbind_add_constant_override = try api.createMethod("Control", "add_constant_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, *arg_constant),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_constant_override, base, cargs, result);
    }

    pub fn addFontOverride(self: *const Self, arg_name: *const godot.String, arg_font: *const godot.Font) !void {
        if (mbind_add_font_override == null) {
            mbind_add_font_override = try api.createMethod("Control", "add_font_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_font),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_font_override, base, cargs, result);
    }

    pub fn addIconOverride(self: *const Self, arg_name: *const godot.String, arg_texture: *const godot.Texture) !void {
        if (mbind_add_icon_override == null) {
            mbind_add_icon_override = try api.createMethod("Control", "add_icon_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_icon_override, base, cargs, result);
    }

    pub fn addShaderOverride(self: *const Self, arg_name: *const godot.String, arg_shader: *const godot.Shader) !void {
        if (mbind_add_shader_override == null) {
            mbind_add_shader_override = try api.createMethod("Control", "add_shader_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_shader),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_shader_override, base, cargs, result);
    }

    pub fn addStyleboxOverride(self: *const Self, arg_name: *const godot.String, arg_stylebox: *const godot.StyleBox) !void {
        if (mbind_add_stylebox_override == null) {
            mbind_add_stylebox_override = try api.createMethod("Control", "add_stylebox_override");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_stylebox),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_stylebox_override, base, cargs, result);
    }

    pub fn findNextValidFocus(self: *const Self) !godot.Control {
        if (mbind_find_next_valid_focus == null) {
            mbind_find_next_valid_focus = try api.createMethod("Control", "find_next_valid_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_next_valid_focus, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn findPrevValidFocus(self: *const Self) !godot.Control {
        if (mbind_find_prev_valid_focus == null) {
            mbind_find_prev_valid_focus = try api.createMethod("Control", "find_prev_valid_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_prev_valid_focus, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn forceDrag(self: *const Self, arg_data: *const godot.Variant, arg_preview: *const godot.Control) !void {
        if (mbind_force_drag == null) {
            mbind_force_drag = try api.createMethod("Control", "force_drag");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_data),
            @ptrCast(*const anyopaque, arg_preview),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_force_drag, base, cargs, result);
    }

    pub fn getAnchor(self: *const Self, arg_margin: i32) !f32 {
        if (mbind_get_anchor == null) {
            mbind_get_anchor = try api.createMethod("Control", "get_anchor");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_anchor, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getBegin(self: *const Self) !godot.Vector2 {
        if (mbind_get_begin == null) {
            mbind_get_begin = try api.createMethod("Control", "get_begin");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_begin, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getColor(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !godot.Color {
        if (mbind_get_color == null) {
            mbind_get_color = try api.createMethod("Control", "get_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getCombinedMinimumSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_combined_minimum_size == null) {
            mbind_get_combined_minimum_size = try api.createMethod("Control", "get_combined_minimum_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_combined_minimum_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getConstant(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !i32 {
        if (mbind_get_constant == null) {
            mbind_get_constant = try api.createMethod("Control", "get_constant");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_constant, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCursorShape(self: *const Self, arg_position: *const godot.Vector2) !i32 {
        if (mbind_get_cursor_shape == null) {
            mbind_get_cursor_shape = try api.createMethod("Control", "get_cursor_shape");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cursor_shape, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCustomMinimumSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_custom_minimum_size == null) {
            mbind_get_custom_minimum_size = try api.createMethod("Control", "get_custom_minimum_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_custom_minimum_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getDefaultCursorShape(self: *const Self) !i32 {
        if (mbind_get_default_cursor_shape == null) {
            mbind_get_default_cursor_shape = try api.createMethod("Control", "get_default_cursor_shape");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_default_cursor_shape, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getEnd(self: *const Self) !godot.Vector2 {
        if (mbind_get_end == null) {
            mbind_get_end = try api.createMethod("Control", "get_end");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_end, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getFocusMode(self: *const Self) !i32 {
        if (mbind_get_focus_mode == null) {
            mbind_get_focus_mode = try api.createMethod("Control", "get_focus_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_focus_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getFocusNeighbour(self: *const Self, arg_margin: i32) !godot.NodePath {
        if (mbind_get_focus_neighbour == null) {
            mbind_get_focus_neighbour = try api.createMethod("Control", "get_focus_neighbour");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_focus_neighbour, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getFocusNext(self: *const Self) !godot.NodePath {
        if (mbind_get_focus_next == null) {
            mbind_get_focus_next = try api.createMethod("Control", "get_focus_next");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_focus_next, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getFocusOwner(self: *const Self) !godot.Control {
        if (mbind_get_focus_owner == null) {
            mbind_get_focus_owner = try api.createMethod("Control", "get_focus_owner");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_focus_owner, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn getFocusPrevious(self: *const Self) !godot.NodePath {
        if (mbind_get_focus_previous == null) {
            mbind_get_focus_previous = try api.createMethod("Control", "get_focus_previous");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_focus_previous, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getFont(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !godot.Font {
        if (mbind_get_font == null) {
            mbind_get_font = try api.createMethod("Control", "get_font");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_font, base, cargs, result);
        return @ptrCast(*godot.Font, @alignCast(@alignOf(&godot.Font), result)).*;
    }

    pub fn getGlobalPosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_global_position == null) {
            mbind_get_global_position = try api.createMethod("Control", "get_global_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getGlobalRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_global_rect == null) {
            mbind_get_global_rect = try api.createMethod("Control", "get_global_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getHGrowDirection(self: *const Self) !i32 {
        if (mbind_get_h_grow_direction == null) {
            mbind_get_h_grow_direction = try api.createMethod("Control", "get_h_grow_direction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_h_grow_direction, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getHSizeFlags(self: *const Self) !i32 {
        if (mbind_get_h_size_flags == null) {
            mbind_get_h_size_flags = try api.createMethod("Control", "get_h_size_flags");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_h_size_flags, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getIcon(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !godot.Texture {
        if (mbind_get_icon == null) {
            mbind_get_icon = try api.createMethod("Control", "get_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getMargin(self: *const Self, arg_margin: i32) !f32 {
        if (mbind_get_margin == null) {
            mbind_get_margin = try api.createMethod("Control", "get_margin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_margin, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getMinimumSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_minimum_size == null) {
            mbind_get_minimum_size = try api.createMethod("Control", "get_minimum_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_minimum_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getMouseFilter(self: *const Self) !i32 {
        if (mbind_get_mouse_filter == null) {
            mbind_get_mouse_filter = try api.createMethod("Control", "get_mouse_filter");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_mouse_filter, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getParentAreaSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_parent_area_size == null) {
            mbind_get_parent_area_size = try api.createMethod("Control", "get_parent_area_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_parent_area_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getParentControl(self: *const Self) !godot.Control {
        if (mbind_get_parent_control == null) {
            mbind_get_parent_control = try api.createMethod("Control", "get_parent_control");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_parent_control, base, cargs, result);
        return @ptrCast(*godot.Control, @alignCast(@alignOf(&godot.Control), result)).*;
    }

    pub fn getPassOnModalCloseClick(self: *const Self) !bool {
        if (mbind_get_pass_on_modal_close_click == null) {
            mbind_get_pass_on_modal_close_click = try api.createMethod("Control", "get_pass_on_modal_close_click");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pass_on_modal_close_click, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getPivotOffset(self: *const Self) !godot.Vector2 {
        if (mbind_get_pivot_offset == null) {
            mbind_get_pivot_offset = try api.createMethod("Control", "get_pivot_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_pivot_offset, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getPosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_position == null) {
            mbind_get_position = try api.createMethod("Control", "get_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getRect(self: *const Self) !godot.Rect2 {
        if (mbind_get_rect == null) {
            mbind_get_rect = try api.createMethod("Control", "get_rect");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rect, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getRotation(self: *const Self) !f32 {
        if (mbind_get_rotation == null) {
            mbind_get_rotation = try api.createMethod("Control", "get_rotation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rotation, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getRotationDegrees(self: *const Self) !f32 {
        if (mbind_get_rotation_degrees == null) {
            mbind_get_rotation_degrees = try api.createMethod("Control", "get_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rotation_degrees, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getScale(self: *const Self) !godot.Vector2 {
        if (mbind_get_scale == null) {
            mbind_get_scale = try api.createMethod("Control", "get_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_scale, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_size == null) {
            mbind_get_size = try api.createMethod("Control", "get_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getStretchRatio(self: *const Self) !f32 {
        if (mbind_get_stretch_ratio == null) {
            mbind_get_stretch_ratio = try api.createMethod("Control", "get_stretch_ratio");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stretch_ratio, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getStylebox(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !godot.StyleBox {
        if (mbind_get_stylebox == null) {
            mbind_get_stylebox = try api.createMethod("Control", "get_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stylebox, base, cargs, result);
        return @ptrCast(*godot.StyleBox, @alignCast(@alignOf(&godot.StyleBox), result)).*;
    }

    pub fn getTheme(self: *const Self) !godot.Theme {
        if (mbind_get_theme == null) {
            mbind_get_theme = try api.createMethod("Control", "get_theme");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_theme, base, cargs, result);
        return @ptrCast(*godot.Theme, @alignCast(@alignOf(&godot.Theme), result)).*;
    }

    pub fn getThemeDefaultFont(self: *const Self) !godot.Font {
        if (mbind_get_theme_default_font == null) {
            mbind_get_theme_default_font = try api.createMethod("Control", "get_theme_default_font");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_theme_default_font, base, cargs, result);
        return @ptrCast(*godot.Font, @alignCast(@alignOf(&godot.Font), result)).*;
    }

    pub fn getTooltip(self: *const Self, arg_at_position: *const godot.Vector2) !godot.String {
        if (mbind_get_tooltip == null) {
            mbind_get_tooltip = try api.createMethod("Control", "get_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_at_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tooltip, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVGrowDirection(self: *const Self) !i32 {
        if (mbind_get_v_grow_direction == null) {
            mbind_get_v_grow_direction = try api.createMethod("Control", "get_v_grow_direction");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_v_grow_direction, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getVSizeFlags(self: *const Self) !i32 {
        if (mbind_get_v_size_flags == null) {
            mbind_get_v_size_flags = try api.createMethod("Control", "get_v_size_flags");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_v_size_flags, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn grabClickFocus(self: *const Self) !void {
        if (mbind_grab_click_focus == null) {
            mbind_grab_click_focus = try api.createMethod("Control", "grab_click_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_grab_click_focus, base, cargs, result);
    }

    pub fn grabFocus(self: *const Self) !void {
        if (mbind_grab_focus == null) {
            mbind_grab_focus = try api.createMethod("Control", "grab_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_grab_focus, base, cargs, result);
    }

    pub fn hasColor(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !bool {
        if (mbind_has_color == null) {
            mbind_has_color = try api.createMethod("Control", "has_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_color, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasColorOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_color_override == null) {
            mbind_has_color_override = try api.createMethod("Control", "has_color_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_color_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasConstant(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !bool {
        if (mbind_has_constant == null) {
            mbind_has_constant = try api.createMethod("Control", "has_constant");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_constant, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasConstantOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_constant_override == null) {
            mbind_has_constant_override = try api.createMethod("Control", "has_constant_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_constant_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFocus(self: *const Self) !bool {
        if (mbind_has_focus == null) {
            mbind_has_focus = try api.createMethod("Control", "has_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_focus, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFont(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !bool {
        if (mbind_has_font == null) {
            mbind_has_font = try api.createMethod("Control", "has_font");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_font, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFontOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_font_override == null) {
            mbind_has_font_override = try api.createMethod("Control", "has_font_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_font_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasIcon(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !bool {
        if (mbind_has_icon == null) {
            mbind_has_icon = try api.createMethod("Control", "has_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_icon, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasIconOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_icon_override == null) {
            mbind_has_icon_override = try api.createMethod("Control", "has_icon_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_icon_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasShaderOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_shader_override == null) {
            mbind_has_shader_override = try api.createMethod("Control", "has_shader_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_shader_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasStylebox(self: *const Self, arg_name: *const godot.String, arg_theme_type: *const godot.String) !bool {
        if (mbind_has_stylebox == null) {
            mbind_has_stylebox = try api.createMethod("Control", "has_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_theme_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_stylebox, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasStyleboxOverride(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_stylebox_override == null) {
            mbind_has_stylebox_override = try api.createMethod("Control", "has_stylebox_override");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_stylebox_override, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isClippingContents(self: *const Self) !bool {
        if (mbind_is_clipping_contents == null) {
            mbind_is_clipping_contents = try api.createMethod("Control", "is_clipping_contents");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_clipping_contents, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn minimumSizeChanged(self: *const Self) !void {
        if (mbind_minimum_size_changed == null) {
            mbind_minimum_size_changed = try api.createMethod("Control", "minimum_size_changed");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_minimum_size_changed, base, cargs, result);
    }

    pub fn releaseFocus(self: *const Self) !void {
        if (mbind_release_focus == null) {
            mbind_release_focus = try api.createMethod("Control", "release_focus");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_release_focus, base, cargs, result);
    }

    pub fn setAnchor(self: *const Self, arg_margin: i32, arg_anchor: f32, arg_keep_margin: bool, arg_push_opposite_anchor: bool) !void {
        if (mbind_set_anchor == null) {
            mbind_set_anchor = try api.createMethod("Control", "set_anchor");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, *arg_anchor),
            @ptrCast(*const anyopaque, *arg_keep_margin),
            @ptrCast(*const anyopaque, *arg_push_opposite_anchor),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_anchor, base, cargs, result);
    }

    pub fn setAnchorAndMargin(self: *const Self, arg_margin: i32, arg_anchor: f32, arg_offset: f32, arg_push_opposite_anchor: bool) !void {
        if (mbind_set_anchor_and_margin == null) {
            mbind_set_anchor_and_margin = try api.createMethod("Control", "set_anchor_and_margin");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, *arg_anchor),
            @ptrCast(*const anyopaque, *arg_offset),
            @ptrCast(*const anyopaque, *arg_push_opposite_anchor),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_anchor_and_margin, base, cargs, result);
    }

    pub fn setAnchorsAndMarginsPreset(self: *const Self, arg_preset: i32, arg_resize_mode: i32, arg_margin: i32) !void {
        if (mbind_set_anchors_and_margins_preset == null) {
            mbind_set_anchors_and_margins_preset = try api.createMethod("Control", "set_anchors_and_margins_preset");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_preset),
            @ptrCast(*const anyopaque, *arg_resize_mode),
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_anchors_and_margins_preset, base, cargs, result);
    }

    pub fn setAnchorsPreset(self: *const Self, arg_preset: i32, arg_keep_margins: bool) !void {
        if (mbind_set_anchors_preset == null) {
            mbind_set_anchors_preset = try api.createMethod("Control", "set_anchors_preset");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_preset),
            @ptrCast(*const anyopaque, *arg_keep_margins),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_anchors_preset, base, cargs, result);
    }

    pub fn setBegin(self: *const Self, arg_position: *const godot.Vector2) !void {
        if (mbind_set_begin == null) {
            mbind_set_begin = try api.createMethod("Control", "set_begin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_begin, base, cargs, result);
    }

    pub fn setClipContents(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_clip_contents == null) {
            mbind_set_clip_contents = try api.createMethod("Control", "set_clip_contents");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clip_contents, base, cargs, result);
    }

    pub fn setCustomMinimumSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_custom_minimum_size == null) {
            mbind_set_custom_minimum_size = try api.createMethod("Control", "set_custom_minimum_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_custom_minimum_size, base, cargs, result);
    }

    pub fn setDefaultCursorShape(self: *const Self, arg_shape: i32) !void {
        if (mbind_set_default_cursor_shape == null) {
            mbind_set_default_cursor_shape = try api.createMethod("Control", "set_default_cursor_shape");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_default_cursor_shape, base, cargs, result);
    }

    pub fn setDragForwarding(self: *const Self, arg_target: *const godot.Control) !void {
        if (mbind_set_drag_forwarding == null) {
            mbind_set_drag_forwarding = try api.createMethod("Control", "set_drag_forwarding");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_target),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_drag_forwarding, base, cargs, result);
    }

    pub fn setDragPreview(self: *const Self, arg_control: *const godot.Control) !void {
        if (mbind_set_drag_preview == null) {
            mbind_set_drag_preview = try api.createMethod("Control", "set_drag_preview");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_control),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_drag_preview, base, cargs, result);
    }

    pub fn setEnd(self: *const Self, arg_position: *const godot.Vector2) !void {
        if (mbind_set_end == null) {
            mbind_set_end = try api.createMethod("Control", "set_end");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_end, base, cargs, result);
    }

    pub fn setFocusMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_focus_mode == null) {
            mbind_set_focus_mode = try api.createMethod("Control", "set_focus_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_focus_mode, base, cargs, result);
    }

    pub fn setFocusNeighbour(self: *const Self, arg_margin: i32, arg_neighbour: *const godot.NodePath) !void {
        if (mbind_set_focus_neighbour == null) {
            mbind_set_focus_neighbour = try api.createMethod("Control", "set_focus_neighbour");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, arg_neighbour),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_focus_neighbour, base, cargs, result);
    }

    pub fn setFocusNext(self: *const Self, arg_next: *const godot.NodePath) !void {
        if (mbind_set_focus_next == null) {
            mbind_set_focus_next = try api.createMethod("Control", "set_focus_next");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_next),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_focus_next, base, cargs, result);
    }

    pub fn setFocusPrevious(self: *const Self, arg_previous: *const godot.NodePath) !void {
        if (mbind_set_focus_previous == null) {
            mbind_set_focus_previous = try api.createMethod("Control", "set_focus_previous");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_previous),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_focus_previous, base, cargs, result);
    }

    pub fn setGlobalPosition(self: *const Self, arg_position: *const godot.Vector2, arg_keep_margins: bool) !void {
        if (mbind_set_global_position == null) {
            mbind_set_global_position = try api.createMethod("Control", "set_global_position");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_keep_margins),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_global_position, base, cargs, result);
    }

    pub fn setHGrowDirection(self: *const Self, arg_direction: i32) !void {
        if (mbind_set_h_grow_direction == null) {
            mbind_set_h_grow_direction = try api.createMethod("Control", "set_h_grow_direction");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_direction),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_h_grow_direction, base, cargs, result);
    }

    pub fn setHSizeFlags(self: *const Self, arg_flags: i32) !void {
        if (mbind_set_h_size_flags == null) {
            mbind_set_h_size_flags = try api.createMethod("Control", "set_h_size_flags");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_h_size_flags, base, cargs, result);
    }

    pub fn setMargin(self: *const Self, arg_margin: i32, arg_offset: f32) !void {
        if (mbind_set_margin == null) {
            mbind_set_margin = try api.createMethod("Control", "set_margin");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_margin),
            @ptrCast(*const anyopaque, *arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_margin, base, cargs, result);
    }

    pub fn setMarginsPreset(self: *const Self, arg_preset: i32, arg_resize_mode: i32, arg_margin: i32) !void {
        if (mbind_set_margins_preset == null) {
            mbind_set_margins_preset = try api.createMethod("Control", "set_margins_preset");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_preset),
            @ptrCast(*const anyopaque, *arg_resize_mode),
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_margins_preset, base, cargs, result);
    }

    pub fn setMouseFilter(self: *const Self, arg_filter: i32) !void {
        if (mbind_set_mouse_filter == null) {
            mbind_set_mouse_filter = try api.createMethod("Control", "set_mouse_filter");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_filter),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_mouse_filter, base, cargs, result);
    }

    pub fn setPassOnModalCloseClick(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_pass_on_modal_close_click == null) {
            mbind_set_pass_on_modal_close_click = try api.createMethod("Control", "set_pass_on_modal_close_click");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pass_on_modal_close_click, base, cargs, result);
    }

    pub fn setPivotOffset(self: *const Self, arg_pivot_offset: *const godot.Vector2) !void {
        if (mbind_set_pivot_offset == null) {
            mbind_set_pivot_offset = try api.createMethod("Control", "set_pivot_offset");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_pivot_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_pivot_offset, base, cargs, result);
    }

    pub fn setPosition(self: *const Self, arg_position: *const godot.Vector2, arg_keep_margins: bool) !void {
        if (mbind_set_position == null) {
            mbind_set_position = try api.createMethod("Control", "set_position");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, *arg_keep_margins),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_position, base, cargs, result);
    }

    pub fn setRotation(self: *const Self, arg_radians: f32) !void {
        if (mbind_set_rotation == null) {
            mbind_set_rotation = try api.createMethod("Control", "set_rotation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_radians),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rotation, base, cargs, result);
    }

    pub fn setRotationDegrees(self: *const Self, arg_degrees: f32) !void {
        if (mbind_set_rotation_degrees == null) {
            mbind_set_rotation_degrees = try api.createMethod("Control", "set_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_degrees),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rotation_degrees, base, cargs, result);
    }

    pub fn setScale(self: *const Self, arg_scale: *const godot.Vector2) !void {
        if (mbind_set_scale == null) {
            mbind_set_scale = try api.createMethod("Control", "set_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_scale, base, cargs, result);
    }

    pub fn setSize(self: *const Self, arg_size: *const godot.Vector2, arg_keep_margins: bool) !void {
        if (mbind_set_size == null) {
            mbind_set_size = try api.createMethod("Control", "set_size");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
            @ptrCast(*const anyopaque, *arg_keep_margins),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_size, base, cargs, result);
    }

    pub fn setStretchRatio(self: *const Self, arg_ratio: f32) !void {
        if (mbind_set_stretch_ratio == null) {
            mbind_set_stretch_ratio = try api.createMethod("Control", "set_stretch_ratio");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_ratio),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_stretch_ratio, base, cargs, result);
    }

    pub fn setTheme(self: *const Self, arg_theme: *const godot.Theme) !void {
        if (mbind_set_theme == null) {
            mbind_set_theme = try api.createMethod("Control", "set_theme");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_theme),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_theme, base, cargs, result);
    }

    pub fn setTooltip(self: *const Self, arg_tooltip: *const godot.String) !void {
        if (mbind_set_tooltip == null) {
            mbind_set_tooltip = try api.createMethod("Control", "set_tooltip");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tooltip),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_tooltip, base, cargs, result);
    }

    pub fn setVGrowDirection(self: *const Self, arg_direction: i32) !void {
        if (mbind_set_v_grow_direction == null) {
            mbind_set_v_grow_direction = try api.createMethod("Control", "set_v_grow_direction");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_direction),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_v_grow_direction, base, cargs, result);
    }

    pub fn setVSizeFlags(self: *const Self, arg_flags: i32) !void {
        if (mbind_set_v_size_flags == null) {
            mbind_set_v_size_flags = try api.createMethod("Control", "set_v_size_flags");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_flags),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_v_size_flags, base, cargs, result);
    }

    pub fn showModal(self: *const Self, arg_exclusive: bool) !void {
        if (mbind_show_modal == null) {
            mbind_show_modal = try api.createMethod("Control", "show_modal");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_exclusive),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_show_modal, base, cargs, result);
    }

    pub fn warpMouse(self: *const Self, arg_to_position: *const godot.Vector2) !void {
        if (mbind_warp_mouse == null) {
            mbind_warp_mouse = try api.createMethod("Control", "warp_mouse");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_to_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_warp_mouse, base, cargs, result);
    }
};