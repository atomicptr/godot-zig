// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Control = @import("control.zig").Control;

// method bindings
var mbind_add_valid_connection_type: ?*c_api.godot_method_bind = null;
var mbind_add_valid_left_disconnect_type: ?*c_api.godot_method_bind = null;
var mbind_add_valid_right_disconnect_type: ?*c_api.godot_method_bind = null;
var mbind_clear_connections: ?*c_api.godot_method_bind = null;
var mbind_connect_node: ?*c_api.godot_method_bind = null;
var mbind_disconnect_node: ?*c_api.godot_method_bind = null;
var mbind_get_connection_list: ?*c_api.godot_method_bind = null;
var mbind_get_minimap_opacity: ?*c_api.godot_method_bind = null;
var mbind_get_minimap_size: ?*c_api.godot_method_bind = null;
var mbind_get_scroll_ofs: ?*c_api.godot_method_bind = null;
var mbind_get_snap: ?*c_api.godot_method_bind = null;
var mbind_get_zoom: ?*c_api.godot_method_bind = null;
var mbind_get_zoom_hbox: ?*c_api.godot_method_bind = null;
var mbind_get_zoom_max: ?*c_api.godot_method_bind = null;
var mbind_get_zoom_min: ?*c_api.godot_method_bind = null;
var mbind_get_zoom_step: ?*c_api.godot_method_bind = null;
var mbind_is_minimap_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_node_connected: ?*c_api.godot_method_bind = null;
var mbind_is_right_disconnects_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_showing_zoom_label: ?*c_api.godot_method_bind = null;
var mbind_is_using_snap: ?*c_api.godot_method_bind = null;
var mbind_is_valid_connection_type: ?*c_api.godot_method_bind = null;
var mbind_remove_valid_connection_type: ?*c_api.godot_method_bind = null;
var mbind_remove_valid_left_disconnect_type: ?*c_api.godot_method_bind = null;
var mbind_remove_valid_right_disconnect_type: ?*c_api.godot_method_bind = null;
var mbind_set_connection_activity: ?*c_api.godot_method_bind = null;
var mbind_set_minimap_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_minimap_opacity: ?*c_api.godot_method_bind = null;
var mbind_set_minimap_size: ?*c_api.godot_method_bind = null;
var mbind_set_right_disconnects: ?*c_api.godot_method_bind = null;
var mbind_set_scroll_ofs: ?*c_api.godot_method_bind = null;
var mbind_set_selected: ?*c_api.godot_method_bind = null;
var mbind_set_show_zoom_label: ?*c_api.godot_method_bind = null;
var mbind_set_snap: ?*c_api.godot_method_bind = null;
var mbind_set_use_snap: ?*c_api.godot_method_bind = null;
var mbind_set_zoom: ?*c_api.godot_method_bind = null;
var mbind_set_zoom_max: ?*c_api.godot_method_bind = null;
var mbind_set_zoom_min: ?*c_api.godot_method_bind = null;
var mbind_set_zoom_step: ?*c_api.godot_method_bind = null;
var mbind_graph_edit_constructor: ?fn () ?*c_api.godot_object = null;

pub const GraphEdit = struct {
    const Self = @This();
    const BaseClass = Control;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_graph_edit_constructor == null) {
            mbind_graph_edit_constructor = try api.createConstructor("GraphEdit");
        }
        return api.createObject(Self, mbind_graph_edit_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addValidConnectionType(self: *const Self, arg_from_type: i32, arg_to_type: i32) !void {
        if (mbind_add_valid_connection_type == null) {
            mbind_add_valid_connection_type = try api.createMethod("GraphEdit", "add_valid_connection_type");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_from_type),
            @ptrCast(*const anyopaque, *arg_to_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_valid_connection_type, base, cargs, result);
    }

    pub fn addValidLeftDisconnectType(self: *const Self, arg_type: i32) !void {
        if (mbind_add_valid_left_disconnect_type == null) {
            mbind_add_valid_left_disconnect_type = try api.createMethod("GraphEdit", "add_valid_left_disconnect_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_valid_left_disconnect_type, base, cargs, result);
    }

    pub fn addValidRightDisconnectType(self: *const Self, arg_type: i32) !void {
        if (mbind_add_valid_right_disconnect_type == null) {
            mbind_add_valid_right_disconnect_type = try api.createMethod("GraphEdit", "add_valid_right_disconnect_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_valid_right_disconnect_type, base, cargs, result);
    }

    pub fn clearConnections(self: *const Self) !void {
        if (mbind_clear_connections == null) {
            mbind_clear_connections = try api.createMethod("GraphEdit", "clear_connections");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_connections, base, cargs, result);
    }

    pub fn connectNode(self: *const Self, arg_from: *const godot.String, arg_from_port: i32, arg_to: *const godot.String, arg_to_port: i32) !i32 {
        if (mbind_connect_node == null) {
            mbind_connect_node = try api.createMethod("GraphEdit", "connect_node");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, *arg_from_port),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, *arg_to_port),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_connect_node, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn disconnectNode(self: *const Self, arg_from: *const godot.String, arg_from_port: i32, arg_to: *const godot.String, arg_to_port: i32) !void {
        if (mbind_disconnect_node == null) {
            mbind_disconnect_node = try api.createMethod("GraphEdit", "disconnect_node");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, *arg_from_port),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, *arg_to_port),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_disconnect_node, base, cargs, result);
    }

    pub fn getConnectionList(self: *const Self) !godot.Array {
        if (mbind_get_connection_list == null) {
            mbind_get_connection_list = try api.createMethod("GraphEdit", "get_connection_list");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_connection_list, base, cargs, result);
        return @ptrCast(*godot.Array, @alignCast(@alignOf(&godot.Array), result)).*;
    }

    pub fn getMinimapOpacity(self: *const Self) !f32 {
        if (mbind_get_minimap_opacity == null) {
            mbind_get_minimap_opacity = try api.createMethod("GraphEdit", "get_minimap_opacity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_minimap_opacity, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getMinimapSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_minimap_size == null) {
            mbind_get_minimap_size = try api.createMethod("GraphEdit", "get_minimap_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_minimap_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getScrollOfs(self: *const Self) !godot.Vector2 {
        if (mbind_get_scroll_ofs == null) {
            mbind_get_scroll_ofs = try api.createMethod("GraphEdit", "get_scroll_ofs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_scroll_ofs, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getSnap(self: *const Self) !i32 {
        if (mbind_get_snap == null) {
            mbind_get_snap = try api.createMethod("GraphEdit", "get_snap");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_snap, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getZoom(self: *const Self) !f32 {
        if (mbind_get_zoom == null) {
            mbind_get_zoom = try api.createMethod("GraphEdit", "get_zoom");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_zoom, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getZoomHbox(self: *const Self) !godot.HBoxContainer {
        if (mbind_get_zoom_hbox == null) {
            mbind_get_zoom_hbox = try api.createMethod("GraphEdit", "get_zoom_hbox");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_zoom_hbox, base, cargs, result);
        return @ptrCast(*godot.HBoxContainer, @alignCast(@alignOf(&godot.HBoxContainer), result)).*;
    }

    pub fn getZoomMax(self: *const Self) !f32 {
        if (mbind_get_zoom_max == null) {
            mbind_get_zoom_max = try api.createMethod("GraphEdit", "get_zoom_max");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_zoom_max, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getZoomMin(self: *const Self) !f32 {
        if (mbind_get_zoom_min == null) {
            mbind_get_zoom_min = try api.createMethod("GraphEdit", "get_zoom_min");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_zoom_min, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getZoomStep(self: *const Self) !f32 {
        if (mbind_get_zoom_step == null) {
            mbind_get_zoom_step = try api.createMethod("GraphEdit", "get_zoom_step");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_zoom_step, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn isMinimapEnabled(self: *const Self) !bool {
        if (mbind_is_minimap_enabled == null) {
            mbind_is_minimap_enabled = try api.createMethod("GraphEdit", "is_minimap_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_minimap_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isNodeConnected(self: *const Self, arg_from: *const godot.String, arg_from_port: i32, arg_to: *const godot.String, arg_to_port: i32) !bool {
        if (mbind_is_node_connected == null) {
            mbind_is_node_connected = try api.createMethod("GraphEdit", "is_node_connected");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, *arg_from_port),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, *arg_to_port),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_node_connected, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isRightDisconnectsEnabled(self: *const Self) !bool {
        if (mbind_is_right_disconnects_enabled == null) {
            mbind_is_right_disconnects_enabled = try api.createMethod("GraphEdit", "is_right_disconnects_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_right_disconnects_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isShowingZoomLabel(self: *const Self) !bool {
        if (mbind_is_showing_zoom_label == null) {
            mbind_is_showing_zoom_label = try api.createMethod("GraphEdit", "is_showing_zoom_label");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_showing_zoom_label, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUsingSnap(self: *const Self) !bool {
        if (mbind_is_using_snap == null) {
            mbind_is_using_snap = try api.createMethod("GraphEdit", "is_using_snap");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_using_snap, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isValidConnectionType(self: *const Self, arg_from_type: i32, arg_to_type: i32) !bool {
        if (mbind_is_valid_connection_type == null) {
            mbind_is_valid_connection_type = try api.createMethod("GraphEdit", "is_valid_connection_type");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_from_type),
            @ptrCast(*const anyopaque, *arg_to_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_valid_connection_type, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn removeValidConnectionType(self: *const Self, arg_from_type: i32, arg_to_type: i32) !void {
        if (mbind_remove_valid_connection_type == null) {
            mbind_remove_valid_connection_type = try api.createMethod("GraphEdit", "remove_valid_connection_type");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_from_type),
            @ptrCast(*const anyopaque, *arg_to_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_valid_connection_type, base, cargs, result);
    }

    pub fn removeValidLeftDisconnectType(self: *const Self, arg_type: i32) !void {
        if (mbind_remove_valid_left_disconnect_type == null) {
            mbind_remove_valid_left_disconnect_type = try api.createMethod("GraphEdit", "remove_valid_left_disconnect_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_valid_left_disconnect_type, base, cargs, result);
    }

    pub fn removeValidRightDisconnectType(self: *const Self, arg_type: i32) !void {
        if (mbind_remove_valid_right_disconnect_type == null) {
            mbind_remove_valid_right_disconnect_type = try api.createMethod("GraphEdit", "remove_valid_right_disconnect_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_valid_right_disconnect_type, base, cargs, result);
    }

    pub fn setConnectionActivity(self: *const Self, arg_from: *const godot.String, arg_from_port: i32, arg_to: *const godot.String, arg_to_port: i32, arg_amount: f32) !void {
        if (mbind_set_connection_activity == null) {
            mbind_set_connection_activity = try api.createMethod("GraphEdit", "set_connection_activity");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, *arg_from_port),
            @ptrCast(*const anyopaque, arg_to),
            @ptrCast(*const anyopaque, *arg_to_port),
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_connection_activity, base, cargs, result);
    }

    pub fn setMinimapEnabled(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_minimap_enabled == null) {
            mbind_set_minimap_enabled = try api.createMethod("GraphEdit", "set_minimap_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_minimap_enabled, base, cargs, result);
    }

    pub fn setMinimapOpacity(self: *const Self, arg_p_opacity: f32) !void {
        if (mbind_set_minimap_opacity == null) {
            mbind_set_minimap_opacity = try api.createMethod("GraphEdit", "set_minimap_opacity");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_p_opacity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_minimap_opacity, base, cargs, result);
    }

    pub fn setMinimapSize(self: *const Self, arg_p_size: *const godot.Vector2) !void {
        if (mbind_set_minimap_size == null) {
            mbind_set_minimap_size = try api.createMethod("GraphEdit", "set_minimap_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_p_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_minimap_size, base, cargs, result);
    }

    pub fn setRightDisconnects(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_right_disconnects == null) {
            mbind_set_right_disconnects = try api.createMethod("GraphEdit", "set_right_disconnects");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_right_disconnects, base, cargs, result);
    }

    pub fn setScrollOfs(self: *const Self, arg_ofs: *const godot.Vector2) !void {
        if (mbind_set_scroll_ofs == null) {
            mbind_set_scroll_ofs = try api.createMethod("GraphEdit", "set_scroll_ofs");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_ofs),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_scroll_ofs, base, cargs, result);
    }

    pub fn setSelected(self: *const Self, arg_node: *const godot.Node) !void {
        if (mbind_set_selected == null) {
            mbind_set_selected = try api.createMethod("GraphEdit", "set_selected");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_selected, base, cargs, result);
    }

    pub fn setShowZoomLabel(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_show_zoom_label == null) {
            mbind_set_show_zoom_label = try api.createMethod("GraphEdit", "set_show_zoom_label");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_show_zoom_label, base, cargs, result);
    }

    pub fn setSnap(self: *const Self, arg_pixels: i32) !void {
        if (mbind_set_snap == null) {
            mbind_set_snap = try api.createMethod("GraphEdit", "set_snap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_pixels),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_snap, base, cargs, result);
    }

    pub fn setUseSnap(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_snap == null) {
            mbind_set_use_snap = try api.createMethod("GraphEdit", "set_use_snap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_snap, base, cargs, result);
    }

    pub fn setZoom(self: *const Self, arg_p_zoom: f32) !void {
        if (mbind_set_zoom == null) {
            mbind_set_zoom = try api.createMethod("GraphEdit", "set_zoom");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_p_zoom),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_zoom, base, cargs, result);
    }

    pub fn setZoomMax(self: *const Self, arg_zoom_max: f32) !void {
        if (mbind_set_zoom_max == null) {
            mbind_set_zoom_max = try api.createMethod("GraphEdit", "set_zoom_max");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_zoom_max),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_zoom_max, base, cargs, result);
    }

    pub fn setZoomMin(self: *const Self, arg_zoom_min: f32) !void {
        if (mbind_set_zoom_min == null) {
            mbind_set_zoom_min = try api.createMethod("GraphEdit", "set_zoom_min");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_zoom_min),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_zoom_min, base, cargs, result);
    }

    pub fn setZoomStep(self: *const Self, arg_zoom_step: f32) !void {
        if (mbind_set_zoom_step == null) {
            mbind_set_zoom_step = try api.createMethod("GraphEdit", "set_zoom_step");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_zoom_step),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_zoom_step, base, cargs, result);
    }
};