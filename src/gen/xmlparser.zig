// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_get_attribute_count: ?*c_api.godot_method_bind = null;
var mbind_get_attribute_name: ?*c_api.godot_method_bind = null;
var mbind_get_attribute_value: ?*c_api.godot_method_bind = null;
var mbind_get_current_line: ?*c_api.godot_method_bind = null;
var mbind_get_named_attribute_value: ?*c_api.godot_method_bind = null;
var mbind_get_named_attribute_value_safe: ?*c_api.godot_method_bind = null;
var mbind_get_node_data: ?*c_api.godot_method_bind = null;
var mbind_get_node_name: ?*c_api.godot_method_bind = null;
var mbind_get_node_offset: ?*c_api.godot_method_bind = null;
var mbind_get_node_type: ?*c_api.godot_method_bind = null;
var mbind_has_attribute: ?*c_api.godot_method_bind = null;
var mbind_is_empty: ?*c_api.godot_method_bind = null;
var mbind_open: ?*c_api.godot_method_bind = null;
var mbind_open_buffer: ?*c_api.godot_method_bind = null;
var mbind_read: ?*c_api.godot_method_bind = null;
var mbind_seek: ?*c_api.godot_method_bind = null;
var mbind_skip_section: ?*c_api.godot_method_bind = null;
var mbind_xmlparser_constructor: ?fn () ?*c_api.godot_object = null;

pub const XMLParser = struct {
    const Self = @This();
    pub const BaseClass = godot.Reference;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_xmlparser_constructor == null) {
            mbind_xmlparser_constructor = try api.createConstructor("XMLParser");
        }
        return api.createObject(Self, mbind_xmlparser_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn getAttributeCount(self: *const Self) !i32 {
        if (mbind_get_attribute_count == null) {
            mbind_get_attribute_count = try api.createMethod("XMLParser", "get_attribute_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_attribute_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getAttributeName(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_attribute_name == null) {
            mbind_get_attribute_name = try api.createMethod("XMLParser", "get_attribute_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_attribute_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getAttributeValue(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_attribute_value == null) {
            mbind_get_attribute_value = try api.createMethod("XMLParser", "get_attribute_value");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_attribute_value, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getCurrentLine(self: *const Self) !i32 {
        if (mbind_get_current_line == null) {
            mbind_get_current_line = try api.createMethod("XMLParser", "get_current_line");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_line, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNamedAttributeValue(self: *const Self, arg_name: *const godot.String) !godot.String {
        if (mbind_get_named_attribute_value == null) {
            mbind_get_named_attribute_value = try api.createMethod("XMLParser", "get_named_attribute_value");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_named_attribute_value, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNamedAttributeValueSafe(self: *const Self, arg_name: *const godot.String) !godot.String {
        if (mbind_get_named_attribute_value_safe == null) {
            mbind_get_named_attribute_value_safe = try api.createMethod("XMLParser", "get_named_attribute_value_safe");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_named_attribute_value_safe, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNodeData(self: *const Self) !godot.String {
        if (mbind_get_node_data == null) {
            mbind_get_node_data = try api.createMethod("XMLParser", "get_node_data");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_data, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNodeName(self: *const Self) !godot.String {
        if (mbind_get_node_name == null) {
            mbind_get_node_name = try api.createMethod("XMLParser", "get_node_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNodeOffset(self: *const Self) !i32 {
        if (mbind_get_node_offset == null) {
            mbind_get_node_offset = try api.createMethod("XMLParser", "get_node_offset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_offset, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getNodeType(self: *const Self) !i32 {
        if (mbind_get_node_type == null) {
            mbind_get_node_type = try api.createMethod("XMLParser", "get_node_type");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn hasAttribute(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_has_attribute == null) {
            mbind_has_attribute = try api.createMethod("XMLParser", "has_attribute");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_attribute, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isEmpty(self: *const Self) !bool {
        if (mbind_is_empty == null) {
            mbind_is_empty = try api.createMethod("XMLParser", "is_empty");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_empty, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn open(self: *const Self, arg_file: *const godot.String) !i32 {
        if (mbind_open == null) {
            mbind_open = try api.createMethod("XMLParser", "open");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_file),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn openBuffer(self: *const Self, arg_buffer: *const godot.PoolByteArray) !i32 {
        if (mbind_open_buffer == null) {
            mbind_open_buffer = try api.createMethod("XMLParser", "open_buffer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_buffer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_buffer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn read(self: *const Self) !i32 {
        if (mbind_read == null) {
            mbind_read = try api.createMethod("XMLParser", "read");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_read, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn seek(self: *const Self, arg_position: i32) !i32 {
        if (mbind_seek == null) {
            mbind_seek = try api.createMethod("XMLParser", "seek");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_seek, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn skipSection(self: *const Self) !void {
        if (mbind_skip_section == null) {
            mbind_skip_section = try api.createMethod("XMLParser", "skip_section");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_skip_section, base, cargs, result);
    }
};