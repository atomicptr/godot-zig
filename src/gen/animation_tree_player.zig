// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node = @import("node.zig").Node;

// method bindings
var mbind_add_node: ?*c_api.godot_method_bind = null;
var mbind_advance: ?*c_api.godot_method_bind = null;
var mbind_animation_node_get_animation: ?*c_api.godot_method_bind = null;
var mbind_animation_node_get_master_animation: ?*c_api.godot_method_bind = null;
var mbind_animation_node_get_position: ?*c_api.godot_method_bind = null;
var mbind_animation_node_set_animation: ?*c_api.godot_method_bind = null;
var mbind_animation_node_set_filter_path: ?*c_api.godot_method_bind = null;
var mbind_animation_node_set_master_animation: ?*c_api.godot_method_bind = null;
var mbind_are_nodes_connected: ?*c_api.godot_method_bind = null;
var mbind_blend2_node_get_amount: ?*c_api.godot_method_bind = null;
var mbind_blend2_node_set_amount: ?*c_api.godot_method_bind = null;
var mbind_blend2_node_set_filter_path: ?*c_api.godot_method_bind = null;
var mbind_blend3_node_get_amount: ?*c_api.godot_method_bind = null;
var mbind_blend3_node_set_amount: ?*c_api.godot_method_bind = null;
var mbind_blend4_node_get_amount: ?*c_api.godot_method_bind = null;
var mbind_blend4_node_set_amount: ?*c_api.godot_method_bind = null;
var mbind_connect_nodes: ?*c_api.godot_method_bind = null;
var mbind_disconnect_nodes: ?*c_api.godot_method_bind = null;
var mbind_get_animation_process_mode: ?*c_api.godot_method_bind = null;
var mbind_get_base_path: ?*c_api.godot_method_bind = null;
var mbind_get_master_player: ?*c_api.godot_method_bind = null;
var mbind_get_node_list: ?*c_api.godot_method_bind = null;
var mbind_is_active: ?*c_api.godot_method_bind = null;
var mbind_mix_node_get_amount: ?*c_api.godot_method_bind = null;
var mbind_mix_node_set_amount: ?*c_api.godot_method_bind = null;
var mbind_node_exists: ?*c_api.godot_method_bind = null;
var mbind_node_get_input_count: ?*c_api.godot_method_bind = null;
var mbind_node_get_input_source: ?*c_api.godot_method_bind = null;
var mbind_node_get_position: ?*c_api.godot_method_bind = null;
var mbind_node_get_type: ?*c_api.godot_method_bind = null;
var mbind_node_rename: ?*c_api.godot_method_bind = null;
var mbind_node_set_position: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_get_autorestart_delay: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_get_autorestart_random_delay: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_get_fadein_time: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_get_fadeout_time: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_has_autorestart: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_is_active: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_autorestart: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_autorestart_delay: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_autorestart_random_delay: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_fadein_time: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_fadeout_time: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_set_filter_path: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_start: ?*c_api.godot_method_bind = null;
var mbind_oneshot_node_stop: ?*c_api.godot_method_bind = null;
var mbind_recompute_caches: ?*c_api.godot_method_bind = null;
var mbind_remove_node: ?*c_api.godot_method_bind = null;
var mbind_reset: ?*c_api.godot_method_bind = null;
var mbind_set_active: ?*c_api.godot_method_bind = null;
var mbind_set_animation_process_mode: ?*c_api.godot_method_bind = null;
var mbind_set_base_path: ?*c_api.godot_method_bind = null;
var mbind_set_master_player: ?*c_api.godot_method_bind = null;
var mbind_timescale_node_get_scale: ?*c_api.godot_method_bind = null;
var mbind_timescale_node_set_scale: ?*c_api.godot_method_bind = null;
var mbind_timeseek_node_seek: ?*c_api.godot_method_bind = null;
var mbind_transition_node_delete_input: ?*c_api.godot_method_bind = null;
var mbind_transition_node_get_current: ?*c_api.godot_method_bind = null;
var mbind_transition_node_get_input_count: ?*c_api.godot_method_bind = null;
var mbind_transition_node_get_xfade_time: ?*c_api.godot_method_bind = null;
var mbind_transition_node_has_input_auto_advance: ?*c_api.godot_method_bind = null;
var mbind_transition_node_set_current: ?*c_api.godot_method_bind = null;
var mbind_transition_node_set_input_auto_advance: ?*c_api.godot_method_bind = null;
var mbind_transition_node_set_input_count: ?*c_api.godot_method_bind = null;
var mbind_transition_node_set_xfade_time: ?*c_api.godot_method_bind = null;
var mbind_animation_tree_player_constructor: ?fn () ?*c_api.godot_object = null;

pub const AnimationTreePlayer = struct {
    const Self = @This();
    const BaseClass = Node;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_animation_tree_player_constructor == null) {
            mbind_animation_tree_player_constructor = try api.createConstructor("AnimationTreePlayer");
        }
        return api.createObject(Self, mbind_animation_tree_player_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn addNode(self: *const Self, arg_type: i32, arg_id: *const godot.String) !void {
        if (mbind_add_node == null) {
            mbind_add_node = try api.createMethod("AnimationTreePlayer", "add_node");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_add_node, base, cargs, result);
    }

    pub fn advance(self: *const Self, arg_delta: f32) !void {
        if (mbind_advance == null) {
            mbind_advance = try api.createMethod("AnimationTreePlayer", "advance");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_delta),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_advance, base, cargs, result);
    }

    pub fn animationNodeGetAnimation(self: *const Self, arg_id: *const godot.String) !godot.Animation {
        if (mbind_animation_node_get_animation == null) {
            mbind_animation_node_get_animation = try api.createMethod("AnimationTreePlayer", "animation_node_get_animation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_get_animation, base, cargs, result);
        return @ptrCast(*godot.Animation, @alignCast(@alignOf(&godot.Animation), result)).*;
    }

    pub fn animationNodeGetMasterAnimation(self: *const Self, arg_id: *const godot.String) !godot.String {
        if (mbind_animation_node_get_master_animation == null) {
            mbind_animation_node_get_master_animation = try api.createMethod("AnimationTreePlayer", "animation_node_get_master_animation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_get_master_animation, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn animationNodeGetPosition(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_animation_node_get_position == null) {
            mbind_animation_node_get_position = try api.createMethod("AnimationTreePlayer", "animation_node_get_position");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_get_position, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn animationNodeSetAnimation(self: *const Self, arg_id: *const godot.String, arg_animation: *const godot.Animation) !void {
        if (mbind_animation_node_set_animation == null) {
            mbind_animation_node_set_animation = try api.createMethod("AnimationTreePlayer", "animation_node_set_animation");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_animation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_set_animation, base, cargs, result);
    }

    pub fn animationNodeSetFilterPath(self: *const Self, arg_id: *const godot.String, arg_path: *const godot.NodePath, arg_enable: bool) !void {
        if (mbind_animation_node_set_filter_path == null) {
            mbind_animation_node_set_filter_path = try api.createMethod("AnimationTreePlayer", "animation_node_set_filter_path");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_set_filter_path, base, cargs, result);
    }

    pub fn animationNodeSetMasterAnimation(self: *const Self, arg_id: *const godot.String, arg_source: *const godot.String) !void {
        if (mbind_animation_node_set_master_animation == null) {
            mbind_animation_node_set_master_animation = try api.createMethod("AnimationTreePlayer", "animation_node_set_master_animation");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_source),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_animation_node_set_master_animation, base, cargs, result);
    }

    pub fn areNodesConnected(self: *const Self, arg_id: *const godot.String, arg_dst_id: *const godot.String, arg_dst_input_idx: i32) !bool {
        if (mbind_are_nodes_connected == null) {
            mbind_are_nodes_connected = try api.createMethod("AnimationTreePlayer", "are_nodes_connected");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_dst_id),
            @ptrCast(*const anyopaque, *arg_dst_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_are_nodes_connected, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn blend2NodeGetAmount(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_blend2_node_get_amount == null) {
            mbind_blend2_node_get_amount = try api.createMethod("AnimationTreePlayer", "blend2_node_get_amount");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend2_node_get_amount, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn blend2NodeSetAmount(self: *const Self, arg_id: *const godot.String, arg_blend: f32) !void {
        if (mbind_blend2_node_set_amount == null) {
            mbind_blend2_node_set_amount = try api.createMethod("AnimationTreePlayer", "blend2_node_set_amount");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_blend),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend2_node_set_amount, base, cargs, result);
    }

    pub fn blend2NodeSetFilterPath(self: *const Self, arg_id: *const godot.String, arg_path: *const godot.NodePath, arg_enable: bool) !void {
        if (mbind_blend2_node_set_filter_path == null) {
            mbind_blend2_node_set_filter_path = try api.createMethod("AnimationTreePlayer", "blend2_node_set_filter_path");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend2_node_set_filter_path, base, cargs, result);
    }

    pub fn blend3NodeGetAmount(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_blend3_node_get_amount == null) {
            mbind_blend3_node_get_amount = try api.createMethod("AnimationTreePlayer", "blend3_node_get_amount");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend3_node_get_amount, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn blend3NodeSetAmount(self: *const Self, arg_id: *const godot.String, arg_blend: f32) !void {
        if (mbind_blend3_node_set_amount == null) {
            mbind_blend3_node_set_amount = try api.createMethod("AnimationTreePlayer", "blend3_node_set_amount");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_blend),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend3_node_set_amount, base, cargs, result);
    }

    pub fn blend4NodeGetAmount(self: *const Self, arg_id: *const godot.String) !godot.Vector2 {
        if (mbind_blend4_node_get_amount == null) {
            mbind_blend4_node_get_amount = try api.createMethod("AnimationTreePlayer", "blend4_node_get_amount");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend4_node_get_amount, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn blend4NodeSetAmount(self: *const Self, arg_id: *const godot.String, arg_blend: *const godot.Vector2) !void {
        if (mbind_blend4_node_set_amount == null) {
            mbind_blend4_node_set_amount = try api.createMethod("AnimationTreePlayer", "blend4_node_set_amount");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_blend),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_blend4_node_set_amount, base, cargs, result);
    }

    pub fn connectNodes(self: *const Self, arg_id: *const godot.String, arg_dst_id: *const godot.String, arg_dst_input_idx: i32) !i32 {
        if (mbind_connect_nodes == null) {
            mbind_connect_nodes = try api.createMethod("AnimationTreePlayer", "connect_nodes");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_dst_id),
            @ptrCast(*const anyopaque, *arg_dst_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_connect_nodes, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn disconnectNodes(self: *const Self, arg_id: *const godot.String, arg_dst_input_idx: i32) !void {
        if (mbind_disconnect_nodes == null) {
            mbind_disconnect_nodes = try api.createMethod("AnimationTreePlayer", "disconnect_nodes");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_dst_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_disconnect_nodes, base, cargs, result);
    }

    pub fn getAnimationProcessMode(self: *const Self) !i32 {
        if (mbind_get_animation_process_mode == null) {
            mbind_get_animation_process_mode = try api.createMethod("AnimationTreePlayer", "get_animation_process_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_animation_process_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getBasePath(self: *const Self) !godot.NodePath {
        if (mbind_get_base_path == null) {
            mbind_get_base_path = try api.createMethod("AnimationTreePlayer", "get_base_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_base_path, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getMasterPlayer(self: *const Self) !godot.NodePath {
        if (mbind_get_master_player == null) {
            mbind_get_master_player = try api.createMethod("AnimationTreePlayer", "get_master_player");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_master_player, base, cargs, result);
        return @ptrCast(*godot.NodePath, @alignCast(@alignOf(&godot.NodePath), result)).*;
    }

    pub fn getNodeList(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_node_list == null) {
            mbind_get_node_list = try api.createMethod("AnimationTreePlayer", "get_node_list");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_node_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn isActive(self: *const Self) !bool {
        if (mbind_is_active == null) {
            mbind_is_active = try api.createMethod("AnimationTreePlayer", "is_active");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn mixNodeGetAmount(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_mix_node_get_amount == null) {
            mbind_mix_node_get_amount = try api.createMethod("AnimationTreePlayer", "mix_node_get_amount");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mix_node_get_amount, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn mixNodeSetAmount(self: *const Self, arg_id: *const godot.String, arg_ratio: f32) !void {
        if (mbind_mix_node_set_amount == null) {
            mbind_mix_node_set_amount = try api.createMethod("AnimationTreePlayer", "mix_node_set_amount");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_ratio),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_mix_node_set_amount, base, cargs, result);
    }

    pub fn nodeExists(self: *const Self, arg_node: *const godot.String) !bool {
        if (mbind_node_exists == null) {
            mbind_node_exists = try api.createMethod("AnimationTreePlayer", "node_exists");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_exists, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn nodeGetInputCount(self: *const Self, arg_id: *const godot.String) !i32 {
        if (mbind_node_get_input_count == null) {
            mbind_node_get_input_count = try api.createMethod("AnimationTreePlayer", "node_get_input_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_get_input_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn nodeGetInputSource(self: *const Self, arg_id: *const godot.String, arg_idx: i32) !godot.String {
        if (mbind_node_get_input_source == null) {
            mbind_node_get_input_source = try api.createMethod("AnimationTreePlayer", "node_get_input_source");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_get_input_source, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn nodeGetPosition(self: *const Self, arg_id: *const godot.String) !godot.Vector2 {
        if (mbind_node_get_position == null) {
            mbind_node_get_position = try api.createMethod("AnimationTreePlayer", "node_get_position");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_get_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn nodeGetType(self: *const Self, arg_id: *const godot.String) !i32 {
        if (mbind_node_get_type == null) {
            mbind_node_get_type = try api.createMethod("AnimationTreePlayer", "node_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn nodeRename(self: *const Self, arg_node: *const godot.String, arg_new_name: *const godot.String) !i32 {
        if (mbind_node_rename == null) {
            mbind_node_rename = try api.createMethod("AnimationTreePlayer", "node_rename");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node),
            @ptrCast(*const anyopaque, arg_new_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_rename, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn nodeSetPosition(self: *const Self, arg_id: *const godot.String, arg_screen_position: *const godot.Vector2) !void {
        if (mbind_node_set_position == null) {
            mbind_node_set_position = try api.createMethod("AnimationTreePlayer", "node_set_position");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_screen_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_node_set_position, base, cargs, result);
    }

    pub fn oneshotNodeGetAutorestartDelay(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_oneshot_node_get_autorestart_delay == null) {
            mbind_oneshot_node_get_autorestart_delay = try api.createMethod("AnimationTreePlayer", "oneshot_node_get_autorestart_delay");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_get_autorestart_delay, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn oneshotNodeGetAutorestartRandomDelay(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_oneshot_node_get_autorestart_random_delay == null) {
            mbind_oneshot_node_get_autorestart_random_delay = try api.createMethod("AnimationTreePlayer", "oneshot_node_get_autorestart_random_delay");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_get_autorestart_random_delay, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn oneshotNodeGetFadeinTime(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_oneshot_node_get_fadein_time == null) {
            mbind_oneshot_node_get_fadein_time = try api.createMethod("AnimationTreePlayer", "oneshot_node_get_fadein_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_get_fadein_time, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn oneshotNodeGetFadeoutTime(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_oneshot_node_get_fadeout_time == null) {
            mbind_oneshot_node_get_fadeout_time = try api.createMethod("AnimationTreePlayer", "oneshot_node_get_fadeout_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_get_fadeout_time, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn oneshotNodeHasAutorestart(self: *const Self, arg_id: *const godot.String) !bool {
        if (mbind_oneshot_node_has_autorestart == null) {
            mbind_oneshot_node_has_autorestart = try api.createMethod("AnimationTreePlayer", "oneshot_node_has_autorestart");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_has_autorestart, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn oneshotNodeIsActive(self: *const Self, arg_id: *const godot.String) !bool {
        if (mbind_oneshot_node_is_active == null) {
            mbind_oneshot_node_is_active = try api.createMethod("AnimationTreePlayer", "oneshot_node_is_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_is_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn oneshotNodeSetAutorestart(self: *const Self, arg_id: *const godot.String, arg_enable: bool) !void {
        if (mbind_oneshot_node_set_autorestart == null) {
            mbind_oneshot_node_set_autorestart = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_autorestart");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_autorestart, base, cargs, result);
    }

    pub fn oneshotNodeSetAutorestartDelay(self: *const Self, arg_id: *const godot.String, arg_delay_sec: f32) !void {
        if (mbind_oneshot_node_set_autorestart_delay == null) {
            mbind_oneshot_node_set_autorestart_delay = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_autorestart_delay");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_delay_sec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_autorestart_delay, base, cargs, result);
    }

    pub fn oneshotNodeSetAutorestartRandomDelay(self: *const Self, arg_id: *const godot.String, arg_rand_sec: f32) !void {
        if (mbind_oneshot_node_set_autorestart_random_delay == null) {
            mbind_oneshot_node_set_autorestart_random_delay = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_autorestart_random_delay");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_rand_sec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_autorestart_random_delay, base, cargs, result);
    }

    pub fn oneshotNodeSetFadeinTime(self: *const Self, arg_id: *const godot.String, arg_time_sec: f32) !void {
        if (mbind_oneshot_node_set_fadein_time == null) {
            mbind_oneshot_node_set_fadein_time = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_fadein_time");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_time_sec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_fadein_time, base, cargs, result);
    }

    pub fn oneshotNodeSetFadeoutTime(self: *const Self, arg_id: *const godot.String, arg_time_sec: f32) !void {
        if (mbind_oneshot_node_set_fadeout_time == null) {
            mbind_oneshot_node_set_fadeout_time = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_fadeout_time");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_time_sec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_fadeout_time, base, cargs, result);
    }

    pub fn oneshotNodeSetFilterPath(self: *const Self, arg_id: *const godot.String, arg_path: *const godot.NodePath, arg_enable: bool) !void {
        if (mbind_oneshot_node_set_filter_path == null) {
            mbind_oneshot_node_set_filter_path = try api.createMethod("AnimationTreePlayer", "oneshot_node_set_filter_path");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_set_filter_path, base, cargs, result);
    }

    pub fn oneshotNodeStart(self: *const Self, arg_id: *const godot.String) !void {
        if (mbind_oneshot_node_start == null) {
            mbind_oneshot_node_start = try api.createMethod("AnimationTreePlayer", "oneshot_node_start");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_start, base, cargs, result);
    }

    pub fn oneshotNodeStop(self: *const Self, arg_id: *const godot.String) !void {
        if (mbind_oneshot_node_stop == null) {
            mbind_oneshot_node_stop = try api.createMethod("AnimationTreePlayer", "oneshot_node_stop");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_oneshot_node_stop, base, cargs, result);
    }

    pub fn recomputeCaches(self: *const Self) !void {
        if (mbind_recompute_caches == null) {
            mbind_recompute_caches = try api.createMethod("AnimationTreePlayer", "recompute_caches");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_recompute_caches, base, cargs, result);
    }

    pub fn removeNode(self: *const Self, arg_id: *const godot.String) !void {
        if (mbind_remove_node == null) {
            mbind_remove_node = try api.createMethod("AnimationTreePlayer", "remove_node");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_remove_node, base, cargs, result);
    }

    pub fn reset(self: *const Self) !void {
        if (mbind_reset == null) {
            mbind_reset = try api.createMethod("AnimationTreePlayer", "reset");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_reset, base, cargs, result);
    }

    pub fn setActive(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_active == null) {
            mbind_set_active = try api.createMethod("AnimationTreePlayer", "set_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_active, base, cargs, result);
    }

    pub fn setAnimationProcessMode(self: *const Self, arg_mode: i32) !void {
        if (mbind_set_animation_process_mode == null) {
            mbind_set_animation_process_mode = try api.createMethod("AnimationTreePlayer", "set_animation_process_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_animation_process_mode, base, cargs, result);
    }

    pub fn setBasePath(self: *const Self, arg_path: *const godot.NodePath) !void {
        if (mbind_set_base_path == null) {
            mbind_set_base_path = try api.createMethod("AnimationTreePlayer", "set_base_path");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_base_path, base, cargs, result);
    }

    pub fn setMasterPlayer(self: *const Self, arg_nodepath: *const godot.NodePath) !void {
        if (mbind_set_master_player == null) {
            mbind_set_master_player = try api.createMethod("AnimationTreePlayer", "set_master_player");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_nodepath),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_master_player, base, cargs, result);
    }

    pub fn timescaleNodeGetScale(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_timescale_node_get_scale == null) {
            mbind_timescale_node_get_scale = try api.createMethod("AnimationTreePlayer", "timescale_node_get_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_timescale_node_get_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn timescaleNodeSetScale(self: *const Self, arg_id: *const godot.String, arg_scale: f32) !void {
        if (mbind_timescale_node_set_scale == null) {
            mbind_timescale_node_set_scale = try api.createMethod("AnimationTreePlayer", "timescale_node_set_scale");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_timescale_node_set_scale, base, cargs, result);
    }

    pub fn timeseekNodeSeek(self: *const Self, arg_id: *const godot.String, arg_seconds: f32) !void {
        if (mbind_timeseek_node_seek == null) {
            mbind_timeseek_node_seek = try api.createMethod("AnimationTreePlayer", "timeseek_node_seek");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_seconds),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_timeseek_node_seek, base, cargs, result);
    }

    pub fn transitionNodeDeleteInput(self: *const Self, arg_id: *const godot.String, arg_input_idx: i32) !void {
        if (mbind_transition_node_delete_input == null) {
            mbind_transition_node_delete_input = try api.createMethod("AnimationTreePlayer", "transition_node_delete_input");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_delete_input, base, cargs, result);
    }

    pub fn transitionNodeGetCurrent(self: *const Self, arg_id: *const godot.String) !i32 {
        if (mbind_transition_node_get_current == null) {
            mbind_transition_node_get_current = try api.createMethod("AnimationTreePlayer", "transition_node_get_current");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_get_current, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn transitionNodeGetInputCount(self: *const Self, arg_id: *const godot.String) !i32 {
        if (mbind_transition_node_get_input_count == null) {
            mbind_transition_node_get_input_count = try api.createMethod("AnimationTreePlayer", "transition_node_get_input_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_get_input_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn transitionNodeGetXfadeTime(self: *const Self, arg_id: *const godot.String) !f32 {
        if (mbind_transition_node_get_xfade_time == null) {
            mbind_transition_node_get_xfade_time = try api.createMethod("AnimationTreePlayer", "transition_node_get_xfade_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_get_xfade_time, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn transitionNodeHasInputAutoAdvance(self: *const Self, arg_id: *const godot.String, arg_input_idx: i32) !bool {
        if (mbind_transition_node_has_input_auto_advance == null) {
            mbind_transition_node_has_input_auto_advance = try api.createMethod("AnimationTreePlayer", "transition_node_has_input_auto_advance");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_has_input_auto_advance, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn transitionNodeSetCurrent(self: *const Self, arg_id: *const godot.String, arg_input_idx: i32) !void {
        if (mbind_transition_node_set_current == null) {
            mbind_transition_node_set_current = try api.createMethod("AnimationTreePlayer", "transition_node_set_current");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_input_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_set_current, base, cargs, result);
    }

    pub fn transitionNodeSetInputAutoAdvance(self: *const Self, arg_id: *const godot.String, arg_input_idx: i32, arg_enable: bool) !void {
        if (mbind_transition_node_set_input_auto_advance == null) {
            mbind_transition_node_set_input_auto_advance = try api.createMethod("AnimationTreePlayer", "transition_node_set_input_auto_advance");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_input_idx),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_set_input_auto_advance, base, cargs, result);
    }

    pub fn transitionNodeSetInputCount(self: *const Self, arg_id: *const godot.String, arg_count: i32) !void {
        if (mbind_transition_node_set_input_count == null) {
            mbind_transition_node_set_input_count = try api.createMethod("AnimationTreePlayer", "transition_node_set_input_count");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_count),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_set_input_count, base, cargs, result);
    }

    pub fn transitionNodeSetXfadeTime(self: *const Self, arg_id: *const godot.String, arg_time_sec: f32) !void {
        if (mbind_transition_node_set_xfade_time == null) {
            mbind_transition_node_set_xfade_time = try api.createMethod("AnimationTreePlayer", "transition_node_set_xfade_time");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, *arg_time_sec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_transition_node_set_xfade_time, base, cargs, result);
    }
};