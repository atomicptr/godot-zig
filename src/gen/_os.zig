// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_alert: ?*c_api.godot_method_bind = null;
var mbind_can_draw: ?*c_api.godot_method_bind = null;
var mbind_can_use_threads: ?*c_api.godot_method_bind = null;
var mbind_center_window: ?*c_api.godot_method_bind = null;
var mbind_close_midi_inputs: ?*c_api.godot_method_bind = null;
var mbind_delay_msec: ?*c_api.godot_method_bind = null;
var mbind_delay_usec: ?*c_api.godot_method_bind = null;
var mbind_dump_memory_to_file: ?*c_api.godot_method_bind = null;
var mbind_dump_resources_to_file: ?*c_api.godot_method_bind = null;
var mbind_execute: ?*c_api.godot_method_bind = null;
var mbind_find_scancode_from_string: ?*c_api.godot_method_bind = null;
var mbind_get_audio_driver_count: ?*c_api.godot_method_bind = null;
var mbind_get_audio_driver_name: ?*c_api.godot_method_bind = null;
var mbind_get_borderless_window: ?*c_api.godot_method_bind = null;
var mbind_get_cache_dir: ?*c_api.godot_method_bind = null;
var mbind_get_clipboard: ?*c_api.godot_method_bind = null;
var mbind_get_cmdline_args: ?*c_api.godot_method_bind = null;
var mbind_get_config_dir: ?*c_api.godot_method_bind = null;
var mbind_get_connected_midi_inputs: ?*c_api.godot_method_bind = null;
var mbind_get_current_screen: ?*c_api.godot_method_bind = null;
var mbind_get_current_tablet_driver: ?*c_api.godot_method_bind = null;
var mbind_get_current_video_driver: ?*c_api.godot_method_bind = null;
var mbind_get_data_dir: ?*c_api.godot_method_bind = null;
var mbind_get_date: ?*c_api.godot_method_bind = null;
var mbind_get_datetime: ?*c_api.godot_method_bind = null;
var mbind_get_datetime_from_unix_time: ?*c_api.godot_method_bind = null;
var mbind_get_dynamic_memory_usage: ?*c_api.godot_method_bind = null;
var mbind_get_environment: ?*c_api.godot_method_bind = null;
var mbind_get_executable_path: ?*c_api.godot_method_bind = null;
var mbind_get_exit_code: ?*c_api.godot_method_bind = null;
var mbind_get_granted_permissions: ?*c_api.godot_method_bind = null;
var mbind_get_ime_selection: ?*c_api.godot_method_bind = null;
var mbind_get_ime_text: ?*c_api.godot_method_bind = null;
var mbind_get_latin_keyboard_variant: ?*c_api.godot_method_bind = null;
var mbind_get_locale: ?*c_api.godot_method_bind = null;
var mbind_get_locale_language: ?*c_api.godot_method_bind = null;
var mbind_get_low_processor_usage_mode_sleep_usec: ?*c_api.godot_method_bind = null;
var mbind_get_max_window_size: ?*c_api.godot_method_bind = null;
var mbind_get_min_window_size: ?*c_api.godot_method_bind = null;
var mbind_get_model_name: ?*c_api.godot_method_bind = null;
var mbind_get_name: ?*c_api.godot_method_bind = null;
var mbind_get_native_handle: ?*c_api.godot_method_bind = null;
var mbind_get_power_percent_left: ?*c_api.godot_method_bind = null;
var mbind_get_power_seconds_left: ?*c_api.godot_method_bind = null;
var mbind_get_power_state: ?*c_api.godot_method_bind = null;
var mbind_get_process_id: ?*c_api.godot_method_bind = null;
var mbind_get_processor_count: ?*c_api.godot_method_bind = null;
var mbind_get_real_window_size: ?*c_api.godot_method_bind = null;
var mbind_get_scancode_string: ?*c_api.godot_method_bind = null;
var mbind_get_screen_count: ?*c_api.godot_method_bind = null;
var mbind_get_screen_dpi: ?*c_api.godot_method_bind = null;
var mbind_get_screen_max_scale: ?*c_api.godot_method_bind = null;
var mbind_get_screen_orientation: ?*c_api.godot_method_bind = null;
var mbind_get_screen_position: ?*c_api.godot_method_bind = null;
var mbind_get_screen_scale: ?*c_api.godot_method_bind = null;
var mbind_get_screen_size: ?*c_api.godot_method_bind = null;
var mbind_get_splash_tick_msec: ?*c_api.godot_method_bind = null;
var mbind_get_static_memory_peak_usage: ?*c_api.godot_method_bind = null;
var mbind_get_static_memory_usage: ?*c_api.godot_method_bind = null;
var mbind_get_system_dir: ?*c_api.godot_method_bind = null;
var mbind_get_system_time_msecs: ?*c_api.godot_method_bind = null;
var mbind_get_system_time_secs: ?*c_api.godot_method_bind = null;
var mbind_get_tablet_driver_count: ?*c_api.godot_method_bind = null;
var mbind_get_tablet_driver_name: ?*c_api.godot_method_bind = null;
var mbind_get_thread_caller_id: ?*c_api.godot_method_bind = null;
var mbind_get_ticks_msec: ?*c_api.godot_method_bind = null;
var mbind_get_ticks_usec: ?*c_api.godot_method_bind = null;
var mbind_get_time: ?*c_api.godot_method_bind = null;
var mbind_get_time_zone_info: ?*c_api.godot_method_bind = null;
var mbind_get_unique_id: ?*c_api.godot_method_bind = null;
var mbind_get_unix_time: ?*c_api.godot_method_bind = null;
var mbind_get_unix_time_from_datetime: ?*c_api.godot_method_bind = null;
var mbind_get_user_data_dir: ?*c_api.godot_method_bind = null;
var mbind_get_video_driver_count: ?*c_api.godot_method_bind = null;
var mbind_get_video_driver_name: ?*c_api.godot_method_bind = null;
var mbind_get_virtual_keyboard_height: ?*c_api.godot_method_bind = null;
var mbind_get_window_per_pixel_transparency_enabled: ?*c_api.godot_method_bind = null;
var mbind_get_window_position: ?*c_api.godot_method_bind = null;
var mbind_get_window_safe_area: ?*c_api.godot_method_bind = null;
var mbind_get_window_size: ?*c_api.godot_method_bind = null;
var mbind_global_menu_add_item: ?*c_api.godot_method_bind = null;
var mbind_global_menu_add_separator: ?*c_api.godot_method_bind = null;
var mbind_global_menu_clear: ?*c_api.godot_method_bind = null;
var mbind_global_menu_remove_item: ?*c_api.godot_method_bind = null;
var mbind_has_environment: ?*c_api.godot_method_bind = null;
var mbind_has_feature: ?*c_api.godot_method_bind = null;
var mbind_has_touchscreen_ui_hint: ?*c_api.godot_method_bind = null;
var mbind_has_virtual_keyboard: ?*c_api.godot_method_bind = null;
var mbind_hide_virtual_keyboard: ?*c_api.godot_method_bind = null;
var mbind_is_debug_build: ?*c_api.godot_method_bind = null;
var mbind_is_delta_smoothing_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_in_low_processor_usage_mode: ?*c_api.godot_method_bind = null;
var mbind_is_keep_screen_on: ?*c_api.godot_method_bind = null;
var mbind_is_ok_left_and_cancel_right: ?*c_api.godot_method_bind = null;
var mbind_is_scancode_unicode: ?*c_api.godot_method_bind = null;
var mbind_is_stdout_verbose: ?*c_api.godot_method_bind = null;
var mbind_is_userfs_persistent: ?*c_api.godot_method_bind = null;
var mbind_is_vsync_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_vsync_via_compositor_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_window_always_on_top: ?*c_api.godot_method_bind = null;
var mbind_is_window_focused: ?*c_api.godot_method_bind = null;
var mbind_is_window_fullscreen: ?*c_api.godot_method_bind = null;
var mbind_is_window_maximized: ?*c_api.godot_method_bind = null;
var mbind_is_window_minimized: ?*c_api.godot_method_bind = null;
var mbind_is_window_resizable: ?*c_api.godot_method_bind = null;
var mbind_keyboard_get_current_layout: ?*c_api.godot_method_bind = null;
var mbind_keyboard_get_layout_count: ?*c_api.godot_method_bind = null;
var mbind_keyboard_get_layout_language: ?*c_api.godot_method_bind = null;
var mbind_keyboard_get_layout_name: ?*c_api.godot_method_bind = null;
var mbind_keyboard_set_current_layout: ?*c_api.godot_method_bind = null;
var mbind_kill: ?*c_api.godot_method_bind = null;
var mbind_move_window_to_foreground: ?*c_api.godot_method_bind = null;
var mbind_native_video_is_playing: ?*c_api.godot_method_bind = null;
var mbind_native_video_pause: ?*c_api.godot_method_bind = null;
var mbind_native_video_play: ?*c_api.godot_method_bind = null;
var mbind_native_video_stop: ?*c_api.godot_method_bind = null;
var mbind_native_video_unpause: ?*c_api.godot_method_bind = null;
var mbind_open_midi_inputs: ?*c_api.godot_method_bind = null;
var mbind_print_all_resources: ?*c_api.godot_method_bind = null;
var mbind_print_all_textures_by_size: ?*c_api.godot_method_bind = null;
var mbind_print_resources_by_type: ?*c_api.godot_method_bind = null;
var mbind_print_resources_in_use: ?*c_api.godot_method_bind = null;
var mbind_request_attention: ?*c_api.godot_method_bind = null;
var mbind_request_permission: ?*c_api.godot_method_bind = null;
var mbind_request_permissions: ?*c_api.godot_method_bind = null;
var mbind_set_borderless_window: ?*c_api.godot_method_bind = null;
var mbind_set_clipboard: ?*c_api.godot_method_bind = null;
var mbind_set_current_screen: ?*c_api.godot_method_bind = null;
var mbind_set_current_tablet_driver: ?*c_api.godot_method_bind = null;
var mbind_set_delta_smoothing: ?*c_api.godot_method_bind = null;
var mbind_set_environment: ?*c_api.godot_method_bind = null;
var mbind_set_exit_code: ?*c_api.godot_method_bind = null;
var mbind_set_icon: ?*c_api.godot_method_bind = null;
var mbind_set_ime_active: ?*c_api.godot_method_bind = null;
var mbind_set_ime_position: ?*c_api.godot_method_bind = null;
var mbind_set_keep_screen_on: ?*c_api.godot_method_bind = null;
var mbind_set_low_processor_usage_mode: ?*c_api.godot_method_bind = null;
var mbind_set_low_processor_usage_mode_sleep_usec: ?*c_api.godot_method_bind = null;
var mbind_set_max_window_size: ?*c_api.godot_method_bind = null;
var mbind_set_min_window_size: ?*c_api.godot_method_bind = null;
var mbind_set_native_icon: ?*c_api.godot_method_bind = null;
var mbind_set_screen_orientation: ?*c_api.godot_method_bind = null;
var mbind_set_thread_name: ?*c_api.godot_method_bind = null;
var mbind_set_use_file_access_save_and_swap: ?*c_api.godot_method_bind = null;
var mbind_set_use_vsync: ?*c_api.godot_method_bind = null;
var mbind_set_vsync_via_compositor: ?*c_api.godot_method_bind = null;
var mbind_set_window_always_on_top: ?*c_api.godot_method_bind = null;
var mbind_set_window_fullscreen: ?*c_api.godot_method_bind = null;
var mbind_set_window_maximized: ?*c_api.godot_method_bind = null;
var mbind_set_window_minimized: ?*c_api.godot_method_bind = null;
var mbind_set_window_mouse_passthrough: ?*c_api.godot_method_bind = null;
var mbind_set_window_per_pixel_transparency_enabled: ?*c_api.godot_method_bind = null;
var mbind_set_window_position: ?*c_api.godot_method_bind = null;
var mbind_set_window_resizable: ?*c_api.godot_method_bind = null;
var mbind_set_window_size: ?*c_api.godot_method_bind = null;
var mbind_set_window_title: ?*c_api.godot_method_bind = null;
var mbind_shell_open: ?*c_api.godot_method_bind = null;
var mbind_show_virtual_keyboard: ?*c_api.godot_method_bind = null;
var mbind__os_constructor: ?fn () ?*c_api.godot_object = null;

pub const _OS = struct {
    const Self = @This();
    pub const BaseClass = godot.Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind__os_constructor == null) {
            mbind__os_constructor = try api.createConstructor("_OS");
        }
        return api.createObject(Self, mbind__os_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn alert(self: *const Self, arg_text: *const godot.String, arg_title: *const godot.String) !void {
        if (mbind_alert == null) {
            mbind_alert = try api.createMethod("_OS", "alert");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_text),
            @ptrCast(*const anyopaque, arg_title),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_alert, base, cargs, result);
    }

    pub fn canDraw(self: *const Self) !bool {
        if (mbind_can_draw == null) {
            mbind_can_draw = try api.createMethod("_OS", "can_draw");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_can_draw, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn canUseThreads(self: *const Self) !bool {
        if (mbind_can_use_threads == null) {
            mbind_can_use_threads = try api.createMethod("_OS", "can_use_threads");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_can_use_threads, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn centerWindow(self: *const Self) !void {
        if (mbind_center_window == null) {
            mbind_center_window = try api.createMethod("_OS", "center_window");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_center_window, base, cargs, result);
    }

    pub fn closeMidiInputs(self: *const Self) !void {
        if (mbind_close_midi_inputs == null) {
            mbind_close_midi_inputs = try api.createMethod("_OS", "close_midi_inputs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_close_midi_inputs, base, cargs, result);
    }

    pub fn delayMsec(self: *const Self, arg_msec: i32) !void {
        if (mbind_delay_msec == null) {
            mbind_delay_msec = try api.createMethod("_OS", "delay_msec");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_msec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_delay_msec, base, cargs, result);
    }

    pub fn delayUsec(self: *const Self, arg_usec: i32) !void {
        if (mbind_delay_usec == null) {
            mbind_delay_usec = try api.createMethod("_OS", "delay_usec");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_usec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_delay_usec, base, cargs, result);
    }

    pub fn dumpMemoryToFile(self: *const Self, arg_file: *const godot.String) !void {
        if (mbind_dump_memory_to_file == null) {
            mbind_dump_memory_to_file = try api.createMethod("_OS", "dump_memory_to_file");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_file),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_dump_memory_to_file, base, cargs, result);
    }

    pub fn dumpResourcesToFile(self: *const Self, arg_file: *const godot.String) !void {
        if (mbind_dump_resources_to_file == null) {
            mbind_dump_resources_to_file = try api.createMethod("_OS", "dump_resources_to_file");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_file),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_dump_resources_to_file, base, cargs, result);
    }

    pub fn execute(self: *const Self, arg_path: *const godot.String, arg_arguments: *const godot.PoolStringArray, arg_blocking: bool, arg_output: *const godot.Array, arg_read_stderr: bool) !i32 {
        if (mbind_execute == null) {
            mbind_execute = try api.createMethod("_OS", "execute");
        }

        var result: ?*anyopaque = null;
        var args: [5]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, arg_arguments),
            @ptrCast(*const anyopaque, *arg_blocking),
            @ptrCast(*const anyopaque, arg_output),
            @ptrCast(*const anyopaque, *arg_read_stderr),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_execute, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn findScancodeFromString(self: *const Self, arg_string: *const godot.String) !i32 {
        if (mbind_find_scancode_from_string == null) {
            mbind_find_scancode_from_string = try api.createMethod("_OS", "find_scancode_from_string");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_string),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_find_scancode_from_string, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getAudioDriverCount(self: *const Self) !i32 {
        if (mbind_get_audio_driver_count == null) {
            mbind_get_audio_driver_count = try api.createMethod("_OS", "get_audio_driver_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_audio_driver_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getAudioDriverName(self: *const Self, arg_driver: i32) !godot.String {
        if (mbind_get_audio_driver_name == null) {
            mbind_get_audio_driver_name = try api.createMethod("_OS", "get_audio_driver_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_driver),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_audio_driver_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getBorderlessWindow(self: *const Self) !bool {
        if (mbind_get_borderless_window == null) {
            mbind_get_borderless_window = try api.createMethod("_OS", "get_borderless_window");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_borderless_window, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getCacheDir(self: *const Self) !godot.String {
        if (mbind_get_cache_dir == null) {
            mbind_get_cache_dir = try api.createMethod("_OS", "get_cache_dir");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cache_dir, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getClipboard(self: *const Self) !godot.String {
        if (mbind_get_clipboard == null) {
            mbind_get_clipboard = try api.createMethod("_OS", "get_clipboard");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_clipboard, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getCmdlineArgs(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_cmdline_args == null) {
            mbind_get_cmdline_args = try api.createMethod("_OS", "get_cmdline_args");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_cmdline_args, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getConfigDir(self: *const Self) !godot.String {
        if (mbind_get_config_dir == null) {
            mbind_get_config_dir = try api.createMethod("_OS", "get_config_dir");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_config_dir, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getConnectedMidiInputs(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_connected_midi_inputs == null) {
            mbind_get_connected_midi_inputs = try api.createMethod("_OS", "get_connected_midi_inputs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_connected_midi_inputs, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getCurrentScreen(self: *const Self) !i32 {
        if (mbind_get_current_screen == null) {
            mbind_get_current_screen = try api.createMethod("_OS", "get_current_screen");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_screen, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getCurrentTabletDriver(self: *const Self) !godot.String {
        if (mbind_get_current_tablet_driver == null) {
            mbind_get_current_tablet_driver = try api.createMethod("_OS", "get_current_tablet_driver");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_tablet_driver, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getCurrentVideoDriver(self: *const Self) !i32 {
        if (mbind_get_current_video_driver == null) {
            mbind_get_current_video_driver = try api.createMethod("_OS", "get_current_video_driver");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_current_video_driver, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getDataDir(self: *const Self) !godot.String {
        if (mbind_get_data_dir == null) {
            mbind_get_data_dir = try api.createMethod("_OS", "get_data_dir");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_data_dir, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getDate(self: *const Self, arg_utc: bool) !godot.Dictionary {
        if (mbind_get_date == null) {
            mbind_get_date = try api.createMethod("_OS", "get_date");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_utc),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_date, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn getDatetime(self: *const Self, arg_utc: bool) !godot.Dictionary {
        if (mbind_get_datetime == null) {
            mbind_get_datetime = try api.createMethod("_OS", "get_datetime");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_utc),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_datetime, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn getDatetimeFromUnixTime(self: *const Self, arg_unix_time_val: i32) !godot.Dictionary {
        if (mbind_get_datetime_from_unix_time == null) {
            mbind_get_datetime_from_unix_time = try api.createMethod("_OS", "get_datetime_from_unix_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_unix_time_val),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_datetime_from_unix_time, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn getDynamicMemoryUsage(self: *const Self) !i32 {
        if (mbind_get_dynamic_memory_usage == null) {
            mbind_get_dynamic_memory_usage = try api.createMethod("_OS", "get_dynamic_memory_usage");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_dynamic_memory_usage, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getEnvironment(self: *const Self, arg_variable: *const godot.String) !godot.String {
        if (mbind_get_environment == null) {
            mbind_get_environment = try api.createMethod("_OS", "get_environment");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_variable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_environment, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getExecutablePath(self: *const Self) !godot.String {
        if (mbind_get_executable_path == null) {
            mbind_get_executable_path = try api.createMethod("_OS", "get_executable_path");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_executable_path, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getExitCode(self: *const Self) !i32 {
        if (mbind_get_exit_code == null) {
            mbind_get_exit_code = try api.createMethod("_OS", "get_exit_code");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_exit_code, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getGrantedPermissions(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_granted_permissions == null) {
            mbind_get_granted_permissions = try api.createMethod("_OS", "get_granted_permissions");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_granted_permissions, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getImeSelection(self: *const Self) !godot.Vector2 {
        if (mbind_get_ime_selection == null) {
            mbind_get_ime_selection = try api.createMethod("_OS", "get_ime_selection");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ime_selection, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getImeText(self: *const Self) !godot.String {
        if (mbind_get_ime_text == null) {
            mbind_get_ime_text = try api.createMethod("_OS", "get_ime_text");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ime_text, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLatinKeyboardVariant(self: *const Self) !godot.String {
        if (mbind_get_latin_keyboard_variant == null) {
            mbind_get_latin_keyboard_variant = try api.createMethod("_OS", "get_latin_keyboard_variant");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_latin_keyboard_variant, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLocale(self: *const Self) !godot.String {
        if (mbind_get_locale == null) {
            mbind_get_locale = try api.createMethod("_OS", "get_locale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_locale, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLocaleLanguage(self: *const Self) !godot.String {
        if (mbind_get_locale_language == null) {
            mbind_get_locale_language = try api.createMethod("_OS", "get_locale_language");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_locale_language, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getLowProcessorUsageModeSleepUsec(self: *const Self) !i32 {
        if (mbind_get_low_processor_usage_mode_sleep_usec == null) {
            mbind_get_low_processor_usage_mode_sleep_usec = try api.createMethod("_OS", "get_low_processor_usage_mode_sleep_usec");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_low_processor_usage_mode_sleep_usec, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getMaxWindowSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_max_window_size == null) {
            mbind_get_max_window_size = try api.createMethod("_OS", "get_max_window_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_max_window_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getMinWindowSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_min_window_size == null) {
            mbind_get_min_window_size = try api.createMethod("_OS", "get_min_window_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_min_window_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getModelName(self: *const Self) !godot.String {
        if (mbind_get_model_name == null) {
            mbind_get_model_name = try api.createMethod("_OS", "get_model_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_model_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getName(self: *const Self) !godot.String {
        if (mbind_get_name == null) {
            mbind_get_name = try api.createMethod("_OS", "get_name");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getNativeHandle(self: *const Self, arg_handle_type: i32) !i32 {
        if (mbind_get_native_handle == null) {
            mbind_get_native_handle = try api.createMethod("_OS", "get_native_handle");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_handle_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_native_handle, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPowerPercentLeft(self: *const Self) !i32 {
        if (mbind_get_power_percent_left == null) {
            mbind_get_power_percent_left = try api.createMethod("_OS", "get_power_percent_left");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_power_percent_left, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPowerSecondsLeft(self: *const Self) !i32 {
        if (mbind_get_power_seconds_left == null) {
            mbind_get_power_seconds_left = try api.createMethod("_OS", "get_power_seconds_left");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_power_seconds_left, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getPowerState(self: *const Self) !i32 {
        if (mbind_get_power_state == null) {
            mbind_get_power_state = try api.createMethod("_OS", "get_power_state");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_power_state, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getProcessId(self: *const Self) !i32 {
        if (mbind_get_process_id == null) {
            mbind_get_process_id = try api.createMethod("_OS", "get_process_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_process_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getProcessorCount(self: *const Self) !i32 {
        if (mbind_get_processor_count == null) {
            mbind_get_processor_count = try api.createMethod("_OS", "get_processor_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_processor_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getRealWindowSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_real_window_size == null) {
            mbind_get_real_window_size = try api.createMethod("_OS", "get_real_window_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_real_window_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getScancodeString(self: *const Self, arg_code: i32) !godot.String {
        if (mbind_get_scancode_string == null) {
            mbind_get_scancode_string = try api.createMethod("_OS", "get_scancode_string");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_code),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_scancode_string, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getScreenCount(self: *const Self) !i32 {
        if (mbind_get_screen_count == null) {
            mbind_get_screen_count = try api.createMethod("_OS", "get_screen_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getScreenDpi(self: *const Self, arg_screen: i32) !i32 {
        if (mbind_get_screen_dpi == null) {
            mbind_get_screen_dpi = try api.createMethod("_OS", "get_screen_dpi");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_dpi, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getScreenMaxScale(self: *const Self) !f32 {
        if (mbind_get_screen_max_scale == null) {
            mbind_get_screen_max_scale = try api.createMethod("_OS", "get_screen_max_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_max_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getScreenOrientation(self: *const Self) !i32 {
        if (mbind_get_screen_orientation == null) {
            mbind_get_screen_orientation = try api.createMethod("_OS", "get_screen_orientation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_orientation, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getScreenPosition(self: *const Self, arg_screen: i32) !godot.Vector2 {
        if (mbind_get_screen_position == null) {
            mbind_get_screen_position = try api.createMethod("_OS", "get_screen_position");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getScreenScale(self: *const Self, arg_screen: i32) !f32 {
        if (mbind_get_screen_scale == null) {
            mbind_get_screen_scale = try api.createMethod("_OS", "get_screen_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_scale, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn getScreenSize(self: *const Self, arg_screen: i32) !godot.Vector2 {
        if (mbind_get_screen_size == null) {
            mbind_get_screen_size = try api.createMethod("_OS", "get_screen_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_screen_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getSplashTickMsec(self: *const Self) !i32 {
        if (mbind_get_splash_tick_msec == null) {
            mbind_get_splash_tick_msec = try api.createMethod("_OS", "get_splash_tick_msec");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_splash_tick_msec, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getStaticMemoryPeakUsage(self: *const Self) !i32 {
        if (mbind_get_static_memory_peak_usage == null) {
            mbind_get_static_memory_peak_usage = try api.createMethod("_OS", "get_static_memory_peak_usage");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_static_memory_peak_usage, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getStaticMemoryUsage(self: *const Self) !i32 {
        if (mbind_get_static_memory_usage == null) {
            mbind_get_static_memory_usage = try api.createMethod("_OS", "get_static_memory_usage");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_static_memory_usage, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSystemDir(self: *const Self, arg_dir: i32, arg_shared_storage: bool) !godot.String {
        if (mbind_get_system_dir == null) {
            mbind_get_system_dir = try api.createMethod("_OS", "get_system_dir");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_dir),
            @ptrCast(*const anyopaque, *arg_shared_storage),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_system_dir, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getSystemTimeMsecs(self: *const Self) !i32 {
        if (mbind_get_system_time_msecs == null) {
            mbind_get_system_time_msecs = try api.createMethod("_OS", "get_system_time_msecs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_system_time_msecs, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getSystemTimeSecs(self: *const Self) !i32 {
        if (mbind_get_system_time_secs == null) {
            mbind_get_system_time_secs = try api.createMethod("_OS", "get_system_time_secs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_system_time_secs, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTabletDriverCount(self: *const Self) !i32 {
        if (mbind_get_tablet_driver_count == null) {
            mbind_get_tablet_driver_count = try api.createMethod("_OS", "get_tablet_driver_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tablet_driver_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTabletDriverName(self: *const Self, arg_idx: i32) !godot.String {
        if (mbind_get_tablet_driver_name == null) {
            mbind_get_tablet_driver_name = try api.createMethod("_OS", "get_tablet_driver_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_tablet_driver_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getThreadCallerId(self: *const Self) !i32 {
        if (mbind_get_thread_caller_id == null) {
            mbind_get_thread_caller_id = try api.createMethod("_OS", "get_thread_caller_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_thread_caller_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTicksMsec(self: *const Self) !i32 {
        if (mbind_get_ticks_msec == null) {
            mbind_get_ticks_msec = try api.createMethod("_OS", "get_ticks_msec");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ticks_msec, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTicksUsec(self: *const Self) !i32 {
        if (mbind_get_ticks_usec == null) {
            mbind_get_ticks_usec = try api.createMethod("_OS", "get_ticks_usec");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_ticks_usec, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getTime(self: *const Self, arg_utc: bool) !godot.Dictionary {
        if (mbind_get_time == null) {
            mbind_get_time = try api.createMethod("_OS", "get_time");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_utc),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_time, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn getTimeZoneInfo(self: *const Self) !godot.Dictionary {
        if (mbind_get_time_zone_info == null) {
            mbind_get_time_zone_info = try api.createMethod("_OS", "get_time_zone_info");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_time_zone_info, base, cargs, result);
        return @ptrCast(*godot.Dictionary, @alignCast(@alignOf(&godot.Dictionary), result)).*;
    }

    pub fn getUniqueId(self: *const Self) !godot.String {
        if (mbind_get_unique_id == null) {
            mbind_get_unique_id = try api.createMethod("_OS", "get_unique_id");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_unique_id, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getUnixTime(self: *const Self) !i32 {
        if (mbind_get_unix_time == null) {
            mbind_get_unix_time = try api.createMethod("_OS", "get_unix_time");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_unix_time, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getUnixTimeFromDatetime(self: *const Self, arg_datetime: *const godot.Dictionary) !i32 {
        if (mbind_get_unix_time_from_datetime == null) {
            mbind_get_unix_time_from_datetime = try api.createMethod("_OS", "get_unix_time_from_datetime");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_datetime),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_unix_time_from_datetime, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getUserDataDir(self: *const Self) !godot.String {
        if (mbind_get_user_data_dir == null) {
            mbind_get_user_data_dir = try api.createMethod("_OS", "get_user_data_dir");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_user_data_dir, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVideoDriverCount(self: *const Self) !i32 {
        if (mbind_get_video_driver_count == null) {
            mbind_get_video_driver_count = try api.createMethod("_OS", "get_video_driver_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_video_driver_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getVideoDriverName(self: *const Self, arg_driver: i32) !godot.String {
        if (mbind_get_video_driver_name == null) {
            mbind_get_video_driver_name = try api.createMethod("_OS", "get_video_driver_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_driver),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_video_driver_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn getVirtualKeyboardHeight(self: *const Self) !i32 {
        if (mbind_get_virtual_keyboard_height == null) {
            mbind_get_virtual_keyboard_height = try api.createMethod("_OS", "get_virtual_keyboard_height");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_virtual_keyboard_height, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getWindowPerPixelTransparencyEnabled(self: *const Self) !bool {
        if (mbind_get_window_per_pixel_transparency_enabled == null) {
            mbind_get_window_per_pixel_transparency_enabled = try api.createMethod("_OS", "get_window_per_pixel_transparency_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_window_per_pixel_transparency_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn getWindowPosition(self: *const Self) !godot.Vector2 {
        if (mbind_get_window_position == null) {
            mbind_get_window_position = try api.createMethod("_OS", "get_window_position");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_window_position, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn getWindowSafeArea(self: *const Self) !godot.Rect2 {
        if (mbind_get_window_safe_area == null) {
            mbind_get_window_safe_area = try api.createMethod("_OS", "get_window_safe_area");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_window_safe_area, base, cargs, result);
        return @ptrCast(*godot.Rect2, @alignCast(@alignOf(&godot.Rect2), result)).*;
    }

    pub fn getWindowSize(self: *const Self) !godot.Vector2 {
        if (mbind_get_window_size == null) {
            mbind_get_window_size = try api.createMethod("_OS", "get_window_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_window_size, base, cargs, result);
        return @ptrCast(*godot.Vector2, @alignCast(@alignOf(&godot.Vector2), result)).*;
    }

    pub fn globalMenuAddItem(self: *const Self, arg_menu: *const godot.String, arg_label: *const godot.String, arg_id: *const godot.Variant, arg_meta: *const godot.Variant) !void {
        if (mbind_global_menu_add_item == null) {
            mbind_global_menu_add_item = try api.createMethod("_OS", "global_menu_add_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_menu),
            @ptrCast(*const anyopaque, arg_label),
            @ptrCast(*const anyopaque, arg_id),
            @ptrCast(*const anyopaque, arg_meta),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_menu_add_item, base, cargs, result);
    }

    pub fn globalMenuAddSeparator(self: *const Self, arg_menu: *const godot.String) !void {
        if (mbind_global_menu_add_separator == null) {
            mbind_global_menu_add_separator = try api.createMethod("_OS", "global_menu_add_separator");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_menu),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_menu_add_separator, base, cargs, result);
    }

    pub fn globalMenuClear(self: *const Self, arg_menu: *const godot.String) !void {
        if (mbind_global_menu_clear == null) {
            mbind_global_menu_clear = try api.createMethod("_OS", "global_menu_clear");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_menu),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_menu_clear, base, cargs, result);
    }

    pub fn globalMenuRemoveItem(self: *const Self, arg_menu: *const godot.String, arg_idx: i32) !void {
        if (mbind_global_menu_remove_item == null) {
            mbind_global_menu_remove_item = try api.createMethod("_OS", "global_menu_remove_item");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_menu),
            @ptrCast(*const anyopaque, *arg_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_menu_remove_item, base, cargs, result);
    }

    pub fn hasEnvironment(self: *const Self, arg_variable: *const godot.String) !bool {
        if (mbind_has_environment == null) {
            mbind_has_environment = try api.createMethod("_OS", "has_environment");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_variable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_environment, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFeature(self: *const Self, arg_tag_name: *const godot.String) !bool {
        if (mbind_has_feature == null) {
            mbind_has_feature = try api.createMethod("_OS", "has_feature");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tag_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_feature, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasTouchscreenUiHint(self: *const Self) !bool {
        if (mbind_has_touchscreen_ui_hint == null) {
            mbind_has_touchscreen_ui_hint = try api.createMethod("_OS", "has_touchscreen_ui_hint");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_touchscreen_ui_hint, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasVirtualKeyboard(self: *const Self) !bool {
        if (mbind_has_virtual_keyboard == null) {
            mbind_has_virtual_keyboard = try api.createMethod("_OS", "has_virtual_keyboard");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_virtual_keyboard, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hideVirtualKeyboard(self: *const Self) !void {
        if (mbind_hide_virtual_keyboard == null) {
            mbind_hide_virtual_keyboard = try api.createMethod("_OS", "hide_virtual_keyboard");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hide_virtual_keyboard, base, cargs, result);
    }

    pub fn isDebugBuild(self: *const Self) !bool {
        if (mbind_is_debug_build == null) {
            mbind_is_debug_build = try api.createMethod("_OS", "is_debug_build");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_debug_build, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isDeltaSmoothingEnabled(self: *const Self) !bool {
        if (mbind_is_delta_smoothing_enabled == null) {
            mbind_is_delta_smoothing_enabled = try api.createMethod("_OS", "is_delta_smoothing_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_delta_smoothing_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isInLowProcessorUsageMode(self: *const Self) !bool {
        if (mbind_is_in_low_processor_usage_mode == null) {
            mbind_is_in_low_processor_usage_mode = try api.createMethod("_OS", "is_in_low_processor_usage_mode");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_in_low_processor_usage_mode, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isKeepScreenOn(self: *const Self) !bool {
        if (mbind_is_keep_screen_on == null) {
            mbind_is_keep_screen_on = try api.createMethod("_OS", "is_keep_screen_on");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_keep_screen_on, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isOkLeftAndCancelRight(self: *const Self) !bool {
        if (mbind_is_ok_left_and_cancel_right == null) {
            mbind_is_ok_left_and_cancel_right = try api.createMethod("_OS", "is_ok_left_and_cancel_right");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_ok_left_and_cancel_right, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isScancodeUnicode(self: *const Self, arg_code: i32) !bool {
        if (mbind_is_scancode_unicode == null) {
            mbind_is_scancode_unicode = try api.createMethod("_OS", "is_scancode_unicode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_code),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_scancode_unicode, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isStdoutVerbose(self: *const Self) !bool {
        if (mbind_is_stdout_verbose == null) {
            mbind_is_stdout_verbose = try api.createMethod("_OS", "is_stdout_verbose");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_stdout_verbose, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isUserfsPersistent(self: *const Self) !bool {
        if (mbind_is_userfs_persistent == null) {
            mbind_is_userfs_persistent = try api.createMethod("_OS", "is_userfs_persistent");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_userfs_persistent, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVsyncEnabled(self: *const Self) !bool {
        if (mbind_is_vsync_enabled == null) {
            mbind_is_vsync_enabled = try api.createMethod("_OS", "is_vsync_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_vsync_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVsyncViaCompositorEnabled(self: *const Self) !bool {
        if (mbind_is_vsync_via_compositor_enabled == null) {
            mbind_is_vsync_via_compositor_enabled = try api.createMethod("_OS", "is_vsync_via_compositor_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_vsync_via_compositor_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowAlwaysOnTop(self: *const Self) !bool {
        if (mbind_is_window_always_on_top == null) {
            mbind_is_window_always_on_top = try api.createMethod("_OS", "is_window_always_on_top");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_always_on_top, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowFocused(self: *const Self) !bool {
        if (mbind_is_window_focused == null) {
            mbind_is_window_focused = try api.createMethod("_OS", "is_window_focused");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_focused, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowFullscreen(self: *const Self) !bool {
        if (mbind_is_window_fullscreen == null) {
            mbind_is_window_fullscreen = try api.createMethod("_OS", "is_window_fullscreen");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_fullscreen, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowMaximized(self: *const Self) !bool {
        if (mbind_is_window_maximized == null) {
            mbind_is_window_maximized = try api.createMethod("_OS", "is_window_maximized");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_maximized, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowMinimized(self: *const Self) !bool {
        if (mbind_is_window_minimized == null) {
            mbind_is_window_minimized = try api.createMethod("_OS", "is_window_minimized");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_minimized, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isWindowResizable(self: *const Self) !bool {
        if (mbind_is_window_resizable == null) {
            mbind_is_window_resizable = try api.createMethod("_OS", "is_window_resizable");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_window_resizable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn keyboardGetCurrentLayout(self: *const Self) !i32 {
        if (mbind_keyboard_get_current_layout == null) {
            mbind_keyboard_get_current_layout = try api.createMethod("_OS", "keyboard_get_current_layout");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_keyboard_get_current_layout, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn keyboardGetLayoutCount(self: *const Self) !i32 {
        if (mbind_keyboard_get_layout_count == null) {
            mbind_keyboard_get_layout_count = try api.createMethod("_OS", "keyboard_get_layout_count");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_keyboard_get_layout_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn keyboardGetLayoutLanguage(self: *const Self, arg_index: i32) !godot.String {
        if (mbind_keyboard_get_layout_language == null) {
            mbind_keyboard_get_layout_language = try api.createMethod("_OS", "keyboard_get_layout_language");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_keyboard_get_layout_language, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn keyboardGetLayoutName(self: *const Self, arg_index: i32) !godot.String {
        if (mbind_keyboard_get_layout_name == null) {
            mbind_keyboard_get_layout_name = try api.createMethod("_OS", "keyboard_get_layout_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_keyboard_get_layout_name, base, cargs, result);
        return @ptrCast(*godot.String, @alignCast(@alignOf(&godot.String), result)).*;
    }

    pub fn keyboardSetCurrentLayout(self: *const Self, arg_index: i32) !void {
        if (mbind_keyboard_set_current_layout == null) {
            mbind_keyboard_set_current_layout = try api.createMethod("_OS", "keyboard_set_current_layout");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_index),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_keyboard_set_current_layout, base, cargs, result);
    }

    pub fn kill(self: *const Self, arg_pid: i32) !i32 {
        if (mbind_kill == null) {
            mbind_kill = try api.createMethod("_OS", "kill");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_pid),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_kill, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn moveWindowToForeground(self: *const Self) !void {
        if (mbind_move_window_to_foreground == null) {
            mbind_move_window_to_foreground = try api.createMethod("_OS", "move_window_to_foreground");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_move_window_to_foreground, base, cargs, result);
    }

    pub fn nativeVideoIsPlaying(self: *const Self) !bool {
        if (mbind_native_video_is_playing == null) {
            mbind_native_video_is_playing = try api.createMethod("_OS", "native_video_is_playing");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_native_video_is_playing, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn nativeVideoPause(self: *const Self) !void {
        if (mbind_native_video_pause == null) {
            mbind_native_video_pause = try api.createMethod("_OS", "native_video_pause");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_native_video_pause, base, cargs, result);
    }

    pub fn nativeVideoPlay(self: *const Self, arg_path: *const godot.String, arg_volume: f32, arg_audio_track: *const godot.String, arg_subtitle_track: *const godot.String) !i32 {
        if (mbind_native_video_play == null) {
            mbind_native_video_play = try api.createMethod("_OS", "native_video_play");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_path),
            @ptrCast(*const anyopaque, *arg_volume),
            @ptrCast(*const anyopaque, arg_audio_track),
            @ptrCast(*const anyopaque, arg_subtitle_track),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_native_video_play, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn nativeVideoStop(self: *const Self) !void {
        if (mbind_native_video_stop == null) {
            mbind_native_video_stop = try api.createMethod("_OS", "native_video_stop");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_native_video_stop, base, cargs, result);
    }

    pub fn nativeVideoUnpause(self: *const Self) !void {
        if (mbind_native_video_unpause == null) {
            mbind_native_video_unpause = try api.createMethod("_OS", "native_video_unpause");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_native_video_unpause, base, cargs, result);
    }

    pub fn openMidiInputs(self: *const Self) !void {
        if (mbind_open_midi_inputs == null) {
            mbind_open_midi_inputs = try api.createMethod("_OS", "open_midi_inputs");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_open_midi_inputs, base, cargs, result);
    }

    pub fn printAllResources(self: *const Self, arg_tofile: *const godot.String) !void {
        if (mbind_print_all_resources == null) {
            mbind_print_all_resources = try api.createMethod("_OS", "print_all_resources");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_tofile),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_all_resources, base, cargs, result);
    }

    pub fn printAllTexturesBySize(self: *const Self) !void {
        if (mbind_print_all_textures_by_size == null) {
            mbind_print_all_textures_by_size = try api.createMethod("_OS", "print_all_textures_by_size");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_all_textures_by_size, base, cargs, result);
    }

    pub fn printResourcesByType(self: *const Self, arg_types: *const godot.PoolStringArray) !void {
        if (mbind_print_resources_by_type == null) {
            mbind_print_resources_by_type = try api.createMethod("_OS", "print_resources_by_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_types),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_resources_by_type, base, cargs, result);
    }

    pub fn printResourcesInUse(self: *const Self, arg_short: bool) !void {
        if (mbind_print_resources_in_use == null) {
            mbind_print_resources_in_use = try api.createMethod("_OS", "print_resources_in_use");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_short),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_print_resources_in_use, base, cargs, result);
    }

    pub fn requestAttention(self: *const Self) !void {
        if (mbind_request_attention == null) {
            mbind_request_attention = try api.createMethod("_OS", "request_attention");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_request_attention, base, cargs, result);
    }

    pub fn requestPermission(self: *const Self, arg_name: *const godot.String) !bool {
        if (mbind_request_permission == null) {
            mbind_request_permission = try api.createMethod("_OS", "request_permission");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_request_permission, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn requestPermissions(self: *const Self) !bool {
        if (mbind_request_permissions == null) {
            mbind_request_permissions = try api.createMethod("_OS", "request_permissions");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_request_permissions, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setBorderlessWindow(self: *const Self, arg_borderless: bool) !void {
        if (mbind_set_borderless_window == null) {
            mbind_set_borderless_window = try api.createMethod("_OS", "set_borderless_window");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_borderless),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_borderless_window, base, cargs, result);
    }

    pub fn setClipboard(self: *const Self, arg_clipboard: *const godot.String) !void {
        if (mbind_set_clipboard == null) {
            mbind_set_clipboard = try api.createMethod("_OS", "set_clipboard");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_clipboard),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_clipboard, base, cargs, result);
    }

    pub fn setCurrentScreen(self: *const Self, arg_screen: i32) !void {
        if (mbind_set_current_screen == null) {
            mbind_set_current_screen = try api.createMethod("_OS", "set_current_screen");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_screen),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_current_screen, base, cargs, result);
    }

    pub fn setCurrentTabletDriver(self: *const Self, arg_name: *const godot.String) !void {
        if (mbind_set_current_tablet_driver == null) {
            mbind_set_current_tablet_driver = try api.createMethod("_OS", "set_current_tablet_driver");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_current_tablet_driver, base, cargs, result);
    }

    pub fn setDeltaSmoothing(self: *const Self, arg_delta_smoothing_enabled: bool) !void {
        if (mbind_set_delta_smoothing == null) {
            mbind_set_delta_smoothing = try api.createMethod("_OS", "set_delta_smoothing");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_delta_smoothing_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_delta_smoothing, base, cargs, result);
    }

    pub fn setEnvironment(self: *const Self, arg_variable: *const godot.String, arg_value: *const godot.String) !bool {
        if (mbind_set_environment == null) {
            mbind_set_environment = try api.createMethod("_OS", "set_environment");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_variable),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_environment, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn setExitCode(self: *const Self, arg_code: i32) !void {
        if (mbind_set_exit_code == null) {
            mbind_set_exit_code = try api.createMethod("_OS", "set_exit_code");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_code),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_exit_code, base, cargs, result);
    }

    pub fn setIcon(self: *const Self, arg_icon: *const godot.Image) !void {
        if (mbind_set_icon == null) {
            mbind_set_icon = try api.createMethod("_OS", "set_icon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_icon),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_icon, base, cargs, result);
    }

    pub fn setImeActive(self: *const Self, arg_active: bool) !void {
        if (mbind_set_ime_active == null) {
            mbind_set_ime_active = try api.createMethod("_OS", "set_ime_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_ime_active, base, cargs, result);
    }

    pub fn setImePosition(self: *const Self, arg_position: *const godot.Vector2) !void {
        if (mbind_set_ime_position == null) {
            mbind_set_ime_position = try api.createMethod("_OS", "set_ime_position");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_ime_position, base, cargs, result);
    }

    pub fn setKeepScreenOn(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_keep_screen_on == null) {
            mbind_set_keep_screen_on = try api.createMethod("_OS", "set_keep_screen_on");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_keep_screen_on, base, cargs, result);
    }

    pub fn setLowProcessorUsageMode(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_low_processor_usage_mode == null) {
            mbind_set_low_processor_usage_mode = try api.createMethod("_OS", "set_low_processor_usage_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_low_processor_usage_mode, base, cargs, result);
    }

    pub fn setLowProcessorUsageModeSleepUsec(self: *const Self, arg_usec: i32) !void {
        if (mbind_set_low_processor_usage_mode_sleep_usec == null) {
            mbind_set_low_processor_usage_mode_sleep_usec = try api.createMethod("_OS", "set_low_processor_usage_mode_sleep_usec");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_usec),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_low_processor_usage_mode_sleep_usec, base, cargs, result);
    }

    pub fn setMaxWindowSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_max_window_size == null) {
            mbind_set_max_window_size = try api.createMethod("_OS", "set_max_window_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_max_window_size, base, cargs, result);
    }

    pub fn setMinWindowSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_min_window_size == null) {
            mbind_set_min_window_size = try api.createMethod("_OS", "set_min_window_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_min_window_size, base, cargs, result);
    }

    pub fn setNativeIcon(self: *const Self, arg_filename: *const godot.String) !void {
        if (mbind_set_native_icon == null) {
            mbind_set_native_icon = try api.createMethod("_OS", "set_native_icon");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_filename),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_native_icon, base, cargs, result);
    }

    pub fn setScreenOrientation(self: *const Self, arg_orientation: i32) !void {
        if (mbind_set_screen_orientation == null) {
            mbind_set_screen_orientation = try api.createMethod("_OS", "set_screen_orientation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_orientation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_screen_orientation, base, cargs, result);
    }

    pub fn setThreadName(self: *const Self, arg_name: *const godot.String) !i32 {
        if (mbind_set_thread_name == null) {
            mbind_set_thread_name = try api.createMethod("_OS", "set_thread_name");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_thread_name, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn setUseFileAccessSaveAndSwap(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_use_file_access_save_and_swap == null) {
            mbind_set_use_file_access_save_and_swap = try api.createMethod("_OS", "set_use_file_access_save_and_swap");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_file_access_save_and_swap, base, cargs, result);
    }

    pub fn setUseVsync(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_use_vsync == null) {
            mbind_set_use_vsync = try api.createMethod("_OS", "set_use_vsync");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_use_vsync, base, cargs, result);
    }

    pub fn setVsyncViaCompositor(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_vsync_via_compositor == null) {
            mbind_set_vsync_via_compositor = try api.createMethod("_OS", "set_vsync_via_compositor");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_vsync_via_compositor, base, cargs, result);
    }

    pub fn setWindowAlwaysOnTop(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_always_on_top == null) {
            mbind_set_window_always_on_top = try api.createMethod("_OS", "set_window_always_on_top");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_always_on_top, base, cargs, result);
    }

    pub fn setWindowFullscreen(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_fullscreen == null) {
            mbind_set_window_fullscreen = try api.createMethod("_OS", "set_window_fullscreen");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_fullscreen, base, cargs, result);
    }

    pub fn setWindowMaximized(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_maximized == null) {
            mbind_set_window_maximized = try api.createMethod("_OS", "set_window_maximized");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_maximized, base, cargs, result);
    }

    pub fn setWindowMinimized(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_minimized == null) {
            mbind_set_window_minimized = try api.createMethod("_OS", "set_window_minimized");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_minimized, base, cargs, result);
    }

    pub fn setWindowMousePassthrough(self: *const Self, arg_region: *const godot.PoolVector2Array) !void {
        if (mbind_set_window_mouse_passthrough == null) {
            mbind_set_window_mouse_passthrough = try api.createMethod("_OS", "set_window_mouse_passthrough");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_region),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_mouse_passthrough, base, cargs, result);
    }

    pub fn setWindowPerPixelTransparencyEnabled(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_per_pixel_transparency_enabled == null) {
            mbind_set_window_per_pixel_transparency_enabled = try api.createMethod("_OS", "set_window_per_pixel_transparency_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_per_pixel_transparency_enabled, base, cargs, result);
    }

    pub fn setWindowPosition(self: *const Self, arg_position: *const godot.Vector2) !void {
        if (mbind_set_window_position == null) {
            mbind_set_window_position = try api.createMethod("_OS", "set_window_position");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_position, base, cargs, result);
    }

    pub fn setWindowResizable(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_window_resizable == null) {
            mbind_set_window_resizable = try api.createMethod("_OS", "set_window_resizable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_resizable, base, cargs, result);
    }

    pub fn setWindowSize(self: *const Self, arg_size: *const godot.Vector2) !void {
        if (mbind_set_window_size == null) {
            mbind_set_window_size = try api.createMethod("_OS", "set_window_size");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_size),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_size, base, cargs, result);
    }

    pub fn setWindowTitle(self: *const Self, arg_title: *const godot.String) !void {
        if (mbind_set_window_title == null) {
            mbind_set_window_title = try api.createMethod("_OS", "set_window_title");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_title),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_window_title, base, cargs, result);
    }

    pub fn shellOpen(self: *const Self, arg_uri: *const godot.String) !i32 {
        if (mbind_shell_open == null) {
            mbind_shell_open = try api.createMethod("_OS", "shell_open");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_uri),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shell_open, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn showVirtualKeyboard(self: *const Self, arg_existing_text: *const godot.String, arg_multiline: bool) !void {
        if (mbind_show_virtual_keyboard == null) {
            mbind_show_virtual_keyboard = try api.createMethod("_OS", "show_virtual_keyboard");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_existing_text),
            @ptrCast(*const anyopaque, *arg_multiline),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_show_virtual_keyboard, base, cargs, result);
    }
};