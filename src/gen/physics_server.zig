// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_area_add_shape: ?*c_api.godot_method_bind = null;
var mbind_area_attach_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_clear_shapes: ?*c_api.godot_method_bind = null;
var mbind_area_create: ?*c_api.godot_method_bind = null;
var mbind_area_get_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_area_get_param: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape_count: ?*c_api.godot_method_bind = null;
var mbind_area_get_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_area_get_space: ?*c_api.godot_method_bind = null;
var mbind_area_get_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_area_get_transform: ?*c_api.godot_method_bind = null;
var mbind_area_is_ray_pickable: ?*c_api.godot_method_bind = null;
var mbind_area_remove_shape: ?*c_api.godot_method_bind = null;
var mbind_area_set_area_monitor_callback: ?*c_api.godot_method_bind = null;
var mbind_area_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_area_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_area_set_monitor_callback: ?*c_api.godot_method_bind = null;
var mbind_area_set_monitorable: ?*c_api.godot_method_bind = null;
var mbind_area_set_param: ?*c_api.godot_method_bind = null;
var mbind_area_set_ray_pickable: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape_disabled: ?*c_api.godot_method_bind = null;
var mbind_area_set_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_area_set_space: ?*c_api.godot_method_bind = null;
var mbind_area_set_space_override_mode: ?*c_api.godot_method_bind = null;
var mbind_area_set_transform: ?*c_api.godot_method_bind = null;
var mbind_body_add_central_force: ?*c_api.godot_method_bind = null;
var mbind_body_add_collision_exception: ?*c_api.godot_method_bind = null;
var mbind_body_add_force: ?*c_api.godot_method_bind = null;
var mbind_body_add_shape: ?*c_api.godot_method_bind = null;
var mbind_body_add_torque: ?*c_api.godot_method_bind = null;
var mbind_body_apply_central_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_apply_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_apply_torque_impulse: ?*c_api.godot_method_bind = null;
var mbind_body_attach_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_clear_shapes: ?*c_api.godot_method_bind = null;
var mbind_body_create: ?*c_api.godot_method_bind = null;
var mbind_body_get_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_body_get_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_body_get_direct_state: ?*c_api.godot_method_bind = null;
var mbind_body_get_kinematic_safe_margin: ?*c_api.godot_method_bind = null;
var mbind_body_get_max_contacts_reported: ?*c_api.godot_method_bind = null;
var mbind_body_get_mode: ?*c_api.godot_method_bind = null;
var mbind_body_get_object_instance_id: ?*c_api.godot_method_bind = null;
var mbind_body_get_param: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape_count: ?*c_api.godot_method_bind = null;
var mbind_body_get_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_body_get_space: ?*c_api.godot_method_bind = null;
var mbind_body_get_state: ?*c_api.godot_method_bind = null;
var mbind_body_is_axis_locked: ?*c_api.godot_method_bind = null;
var mbind_body_is_continuous_collision_detection_enabled: ?*c_api.godot_method_bind = null;
var mbind_body_is_omitting_force_integration: ?*c_api.godot_method_bind = null;
var mbind_body_is_ray_pickable: ?*c_api.godot_method_bind = null;
var mbind_body_remove_collision_exception: ?*c_api.godot_method_bind = null;
var mbind_body_remove_shape: ?*c_api.godot_method_bind = null;
var mbind_body_set_axis_lock: ?*c_api.godot_method_bind = null;
var mbind_body_set_axis_velocity: ?*c_api.godot_method_bind = null;
var mbind_body_set_collision_layer: ?*c_api.godot_method_bind = null;
var mbind_body_set_collision_mask: ?*c_api.godot_method_bind = null;
var mbind_body_set_enable_continuous_collision_detection: ?*c_api.godot_method_bind = null;
var mbind_body_set_force_integration_callback: ?*c_api.godot_method_bind = null;
var mbind_body_set_kinematic_safe_margin: ?*c_api.godot_method_bind = null;
var mbind_body_set_max_contacts_reported: ?*c_api.godot_method_bind = null;
var mbind_body_set_mode: ?*c_api.godot_method_bind = null;
var mbind_body_set_omit_force_integration: ?*c_api.godot_method_bind = null;
var mbind_body_set_param: ?*c_api.godot_method_bind = null;
var mbind_body_set_ray_pickable: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_disabled: ?*c_api.godot_method_bind = null;
var mbind_body_set_shape_transform: ?*c_api.godot_method_bind = null;
var mbind_body_set_space: ?*c_api.godot_method_bind = null;
var mbind_body_set_state: ?*c_api.godot_method_bind = null;
var mbind_body_test_motion: ?*c_api.godot_method_bind = null;
var mbind_cone_twist_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_cone_twist_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_free_rid: ?*c_api.godot_method_bind = null;
var mbind_generic_6dof_joint_get_flag: ?*c_api.godot_method_bind = null;
var mbind_generic_6dof_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_generic_6dof_joint_set_flag: ?*c_api.godot_method_bind = null;
var mbind_generic_6dof_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_get_process_info: ?*c_api.godot_method_bind = null;
var mbind_hinge_joint_get_flag: ?*c_api.godot_method_bind = null;
var mbind_hinge_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_hinge_joint_set_flag: ?*c_api.godot_method_bind = null;
var mbind_hinge_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_joint_create_cone_twist: ?*c_api.godot_method_bind = null;
var mbind_joint_create_generic_6dof: ?*c_api.godot_method_bind = null;
var mbind_joint_create_hinge: ?*c_api.godot_method_bind = null;
var mbind_joint_create_pin: ?*c_api.godot_method_bind = null;
var mbind_joint_create_slider: ?*c_api.godot_method_bind = null;
var mbind_joint_get_solver_priority: ?*c_api.godot_method_bind = null;
var mbind_joint_get_type: ?*c_api.godot_method_bind = null;
var mbind_joint_set_solver_priority: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_get_local_a: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_get_local_b: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_set_local_a: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_set_local_b: ?*c_api.godot_method_bind = null;
var mbind_pin_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_set_active: ?*c_api.godot_method_bind = null;
var mbind_set_collision_iterations: ?*c_api.godot_method_bind = null;
var mbind_shape_create: ?*c_api.godot_method_bind = null;
var mbind_shape_get_data: ?*c_api.godot_method_bind = null;
var mbind_shape_get_type: ?*c_api.godot_method_bind = null;
var mbind_shape_set_data: ?*c_api.godot_method_bind = null;
var mbind_slider_joint_get_param: ?*c_api.godot_method_bind = null;
var mbind_slider_joint_set_param: ?*c_api.godot_method_bind = null;
var mbind_space_create: ?*c_api.godot_method_bind = null;
var mbind_space_get_direct_state: ?*c_api.godot_method_bind = null;
var mbind_space_get_param: ?*c_api.godot_method_bind = null;
var mbind_space_is_active: ?*c_api.godot_method_bind = null;
var mbind_space_set_active: ?*c_api.godot_method_bind = null;
var mbind_space_set_param: ?*c_api.godot_method_bind = null;
var mbind_physics_server_constructor: ?fn () ?*c_api.godot_object = null;

pub const PhysicsServer = struct {
    const Self = @This();
    pub const BaseClass = godot.Object;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_physics_server_constructor == null) {
            mbind_physics_server_constructor = try api.createConstructor("PhysicsServer");
        }
        return api.createObject(Self, mbind_physics_server_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn areaAddShape(self: *const Self, arg_area: *const godot.RID, arg_shape: *const godot.RID, arg_transform: *const godot.Transform, arg_disabled: bool) !void {
        if (mbind_area_add_shape == null) {
            mbind_area_add_shape = try api.createMethod("PhysicsServer", "area_add_shape");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_add_shape, base, cargs, result);
    }

    pub fn areaAttachObjectInstanceId(self: *const Self, arg_area: *const godot.RID, arg_id: i32) !void {
        if (mbind_area_attach_object_instance_id == null) {
            mbind_area_attach_object_instance_id = try api.createMethod("PhysicsServer", "area_attach_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_attach_object_instance_id, base, cargs, result);
    }

    pub fn areaClearShapes(self: *const Self, arg_area: *const godot.RID) !void {
        if (mbind_area_clear_shapes == null) {
            mbind_area_clear_shapes = try api.createMethod("PhysicsServer", "area_clear_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_clear_shapes, base, cargs, result);
    }

    pub fn areaCreate(self: *const Self) !godot.RID {
        if (mbind_area_create == null) {
            mbind_area_create = try api.createMethod("PhysicsServer", "area_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetObjectInstanceId(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_object_instance_id == null) {
            mbind_area_get_object_instance_id = try api.createMethod("PhysicsServer", "area_get_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_object_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetParam(self: *const Self, arg_area: *const godot.RID, arg_param: i32) !godot.Variant {
        if (mbind_area_get_param == null) {
            mbind_area_get_param = try api.createMethod("PhysicsServer", "area_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_param, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn areaGetShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !godot.RID {
        if (mbind_area_get_shape == null) {
            mbind_area_get_shape = try api.createMethod("PhysicsServer", "area_get_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetShapeCount(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_shape_count == null) {
            mbind_area_get_shape_count = try api.createMethod("PhysicsServer", "area_get_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetShapeTransform(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !godot.Transform {
        if (mbind_area_get_shape_transform == null) {
            mbind_area_get_shape_transform = try api.createMethod("PhysicsServer", "area_get_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_shape_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn areaGetSpace(self: *const Self, arg_area: *const godot.RID) !godot.RID {
        if (mbind_area_get_space == null) {
            mbind_area_get_space = try api.createMethod("PhysicsServer", "area_get_space");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_space, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn areaGetSpaceOverrideMode(self: *const Self, arg_area: *const godot.RID) !i32 {
        if (mbind_area_get_space_override_mode == null) {
            mbind_area_get_space_override_mode = try api.createMethod("PhysicsServer", "area_get_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_space_override_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn areaGetTransform(self: *const Self, arg_area: *const godot.RID) !godot.Transform {
        if (mbind_area_get_transform == null) {
            mbind_area_get_transform = try api.createMethod("PhysicsServer", "area_get_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn areaIsRayPickable(self: *const Self, arg_area: *const godot.RID) !bool {
        if (mbind_area_is_ray_pickable == null) {
            mbind_area_is_ray_pickable = try api.createMethod("PhysicsServer", "area_is_ray_pickable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_is_ray_pickable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn areaRemoveShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32) !void {
        if (mbind_area_remove_shape == null) {
            mbind_area_remove_shape = try api.createMethod("PhysicsServer", "area_remove_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_remove_shape, base, cargs, result);
    }

    pub fn areaSetAreaMonitorCallback(self: *const Self, arg_area: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String) !void {
        if (mbind_area_set_area_monitor_callback == null) {
            mbind_area_set_area_monitor_callback = try api.createMethod("PhysicsServer", "area_set_area_monitor_callback");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_area_monitor_callback, base, cargs, result);
    }

    pub fn areaSetCollisionLayer(self: *const Self, arg_area: *const godot.RID, arg_layer: i32) !void {
        if (mbind_area_set_collision_layer == null) {
            mbind_area_set_collision_layer = try api.createMethod("PhysicsServer", "area_set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_collision_layer, base, cargs, result);
    }

    pub fn areaSetCollisionMask(self: *const Self, arg_area: *const godot.RID, arg_mask: i32) !void {
        if (mbind_area_set_collision_mask == null) {
            mbind_area_set_collision_mask = try api.createMethod("PhysicsServer", "area_set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_collision_mask, base, cargs, result);
    }

    pub fn areaSetMonitorCallback(self: *const Self, arg_area: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String) !void {
        if (mbind_area_set_monitor_callback == null) {
            mbind_area_set_monitor_callback = try api.createMethod("PhysicsServer", "area_set_monitor_callback");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_monitor_callback, base, cargs, result);
    }

    pub fn areaSetMonitorable(self: *const Self, arg_area: *const godot.RID, arg_monitorable: bool) !void {
        if (mbind_area_set_monitorable == null) {
            mbind_area_set_monitorable = try api.createMethod("PhysicsServer", "area_set_monitorable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_monitorable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_monitorable, base, cargs, result);
    }

    pub fn areaSetParam(self: *const Self, arg_area: *const godot.RID, arg_param: i32, arg_value: *const godot.Variant) !void {
        if (mbind_area_set_param == null) {
            mbind_area_set_param = try api.createMethod("PhysicsServer", "area_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_param, base, cargs, result);
    }

    pub fn areaSetRayPickable(self: *const Self, arg_area: *const godot.RID, arg_enable: bool) !void {
        if (mbind_area_set_ray_pickable == null) {
            mbind_area_set_ray_pickable = try api.createMethod("PhysicsServer", "area_set_ray_pickable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_ray_pickable, base, cargs, result);
    }

    pub fn areaSetShape(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_shape: *const godot.RID) !void {
        if (mbind_area_set_shape == null) {
            mbind_area_set_shape = try api.createMethod("PhysicsServer", "area_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape, base, cargs, result);
    }

    pub fn areaSetShapeDisabled(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_disabled: bool) !void {
        if (mbind_area_set_shape_disabled == null) {
            mbind_area_set_shape_disabled = try api.createMethod("PhysicsServer", "area_set_shape_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape_disabled, base, cargs, result);
    }

    pub fn areaSetShapeTransform(self: *const Self, arg_area: *const godot.RID, arg_shape_idx: i32, arg_transform: *const godot.Transform) !void {
        if (mbind_area_set_shape_transform == null) {
            mbind_area_set_shape_transform = try api.createMethod("PhysicsServer", "area_set_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_shape_transform, base, cargs, result);
    }

    pub fn areaSetSpace(self: *const Self, arg_area: *const godot.RID, arg_space: *const godot.RID) !void {
        if (mbind_area_set_space == null) {
            mbind_area_set_space = try api.createMethod("PhysicsServer", "area_set_space");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_space, base, cargs, result);
    }

    pub fn areaSetSpaceOverrideMode(self: *const Self, arg_area: *const godot.RID, arg_mode: i32) !void {
        if (mbind_area_set_space_override_mode == null) {
            mbind_area_set_space_override_mode = try api.createMethod("PhysicsServer", "area_set_space_override_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_space_override_mode, base, cargs, result);
    }

    pub fn areaSetTransform(self: *const Self, arg_area: *const godot.RID, arg_transform: *const godot.Transform) !void {
        if (mbind_area_set_transform == null) {
            mbind_area_set_transform = try api.createMethod("PhysicsServer", "area_set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_area),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_area_set_transform, base, cargs, result);
    }

    pub fn bodyAddCentralForce(self: *const Self, arg_body: *const godot.RID, arg_force: *const godot.Vector3) !void {
        if (mbind_body_add_central_force == null) {
            mbind_body_add_central_force = try api.createMethod("PhysicsServer", "body_add_central_force");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_force),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_central_force, base, cargs, result);
    }

    pub fn bodyAddCollisionException(self: *const Self, arg_body: *const godot.RID, arg_excepted_body: *const godot.RID) !void {
        if (mbind_body_add_collision_exception == null) {
            mbind_body_add_collision_exception = try api.createMethod("PhysicsServer", "body_add_collision_exception");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_excepted_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_collision_exception, base, cargs, result);
    }

    pub fn bodyAddForce(self: *const Self, arg_body: *const godot.RID, arg_force: *const godot.Vector3, arg_position: *const godot.Vector3) !void {
        if (mbind_body_add_force == null) {
            mbind_body_add_force = try api.createMethod("PhysicsServer", "body_add_force");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_force),
            @ptrCast(*const anyopaque, arg_position),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_force, base, cargs, result);
    }

    pub fn bodyAddShape(self: *const Self, arg_body: *const godot.RID, arg_shape: *const godot.RID, arg_transform: *const godot.Transform, arg_disabled: bool) !void {
        if (mbind_body_add_shape == null) {
            mbind_body_add_shape = try api.createMethod("PhysicsServer", "body_add_shape");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_transform),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_shape, base, cargs, result);
    }

    pub fn bodyAddTorque(self: *const Self, arg_body: *const godot.RID, arg_torque: *const godot.Vector3) !void {
        if (mbind_body_add_torque == null) {
            mbind_body_add_torque = try api.createMethod("PhysicsServer", "body_add_torque");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_torque),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_add_torque, base, cargs, result);
    }

    pub fn bodyApplyCentralImpulse(self: *const Self, arg_body: *const godot.RID, arg_impulse: *const godot.Vector3) !void {
        if (mbind_body_apply_central_impulse == null) {
            mbind_body_apply_central_impulse = try api.createMethod("PhysicsServer", "body_apply_central_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_central_impulse, base, cargs, result);
    }

    pub fn bodyApplyImpulse(self: *const Self, arg_body: *const godot.RID, arg_position: *const godot.Vector3, arg_impulse: *const godot.Vector3) !void {
        if (mbind_body_apply_impulse == null) {
            mbind_body_apply_impulse = try api.createMethod("PhysicsServer", "body_apply_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_impulse, base, cargs, result);
    }

    pub fn bodyApplyTorqueImpulse(self: *const Self, arg_body: *const godot.RID, arg_impulse: *const godot.Vector3) !void {
        if (mbind_body_apply_torque_impulse == null) {
            mbind_body_apply_torque_impulse = try api.createMethod("PhysicsServer", "body_apply_torque_impulse");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_impulse),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_apply_torque_impulse, base, cargs, result);
    }

    pub fn bodyAttachObjectInstanceId(self: *const Self, arg_body: *const godot.RID, arg_id: i32) !void {
        if (mbind_body_attach_object_instance_id == null) {
            mbind_body_attach_object_instance_id = try api.createMethod("PhysicsServer", "body_attach_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_id),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_attach_object_instance_id, base, cargs, result);
    }

    pub fn bodyClearShapes(self: *const Self, arg_body: *const godot.RID) !void {
        if (mbind_body_clear_shapes == null) {
            mbind_body_clear_shapes = try api.createMethod("PhysicsServer", "body_clear_shapes");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_clear_shapes, base, cargs, result);
    }

    pub fn bodyCreate(self: *const Self, arg_mode: i32, arg_init_sleeping: bool) !godot.RID {
        if (mbind_body_create == null) {
            mbind_body_create = try api.createMethod("PhysicsServer", "body_create");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_mode),
            @ptrCast(*const anyopaque, *arg_init_sleeping),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetCollisionLayer(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_collision_layer == null) {
            mbind_body_get_collision_layer = try api.createMethod("PhysicsServer", "body_get_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_collision_layer, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetCollisionMask(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_collision_mask == null) {
            mbind_body_get_collision_mask = try api.createMethod("PhysicsServer", "body_get_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_collision_mask, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetDirectState(self: *const Self, arg_body: *const godot.RID) !godot.PhysicsDirectBodyState {
        if (mbind_body_get_direct_state == null) {
            mbind_body_get_direct_state = try api.createMethod("PhysicsServer", "body_get_direct_state");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_direct_state, base, cargs, result);
        return @ptrCast(*godot.PhysicsDirectBodyState, @alignCast(@alignOf(&godot.PhysicsDirectBodyState), result)).*;
    }

    pub fn bodyGetKinematicSafeMargin(self: *const Self, arg_body: *const godot.RID) !f32 {
        if (mbind_body_get_kinematic_safe_margin == null) {
            mbind_body_get_kinematic_safe_margin = try api.createMethod("PhysicsServer", "body_get_kinematic_safe_margin");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_kinematic_safe_margin, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn bodyGetMaxContactsReported(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_max_contacts_reported == null) {
            mbind_body_get_max_contacts_reported = try api.createMethod("PhysicsServer", "body_get_max_contacts_reported");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_max_contacts_reported, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetMode(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_mode == null) {
            mbind_body_get_mode = try api.createMethod("PhysicsServer", "body_get_mode");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_mode, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetObjectInstanceId(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_object_instance_id == null) {
            mbind_body_get_object_instance_id = try api.createMethod("PhysicsServer", "body_get_object_instance_id");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_object_instance_id, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetParam(self: *const Self, arg_body: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_body_get_param == null) {
            mbind_body_get_param = try api.createMethod("PhysicsServer", "body_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn bodyGetShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !godot.RID {
        if (mbind_body_get_shape == null) {
            mbind_body_get_shape = try api.createMethod("PhysicsServer", "body_get_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetShapeCount(self: *const Self, arg_body: *const godot.RID) !i32 {
        if (mbind_body_get_shape_count == null) {
            mbind_body_get_shape_count = try api.createMethod("PhysicsServer", "body_get_shape_count");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape_count, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn bodyGetShapeTransform(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !godot.Transform {
        if (mbind_body_get_shape_transform == null) {
            mbind_body_get_shape_transform = try api.createMethod("PhysicsServer", "body_get_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_shape_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn bodyGetSpace(self: *const Self, arg_body: *const godot.RID) !godot.RID {
        if (mbind_body_get_space == null) {
            mbind_body_get_space = try api.createMethod("PhysicsServer", "body_get_space");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_space, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn bodyGetState(self: *const Self, arg_body: *const godot.RID, arg_state: i32) !godot.Variant {
        if (mbind_body_get_state == null) {
            mbind_body_get_state = try api.createMethod("PhysicsServer", "body_get_state");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_state),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_get_state, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn bodyIsAxisLocked(self: *const Self, arg_body: *const godot.RID, arg_axis: i32) !bool {
        if (mbind_body_is_axis_locked == null) {
            mbind_body_is_axis_locked = try api.createMethod("PhysicsServer", "body_is_axis_locked");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_axis),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_is_axis_locked, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn bodyIsContinuousCollisionDetectionEnabled(self: *const Self, arg_body: *const godot.RID) !bool {
        if (mbind_body_is_continuous_collision_detection_enabled == null) {
            mbind_body_is_continuous_collision_detection_enabled = try api.createMethod("PhysicsServer", "body_is_continuous_collision_detection_enabled");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_is_continuous_collision_detection_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn bodyIsOmittingForceIntegration(self: *const Self, arg_body: *const godot.RID) !bool {
        if (mbind_body_is_omitting_force_integration == null) {
            mbind_body_is_omitting_force_integration = try api.createMethod("PhysicsServer", "body_is_omitting_force_integration");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_is_omitting_force_integration, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn bodyIsRayPickable(self: *const Self, arg_body: *const godot.RID) !bool {
        if (mbind_body_is_ray_pickable == null) {
            mbind_body_is_ray_pickable = try api.createMethod("PhysicsServer", "body_is_ray_pickable");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_is_ray_pickable, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn bodyRemoveCollisionException(self: *const Self, arg_body: *const godot.RID, arg_excepted_body: *const godot.RID) !void {
        if (mbind_body_remove_collision_exception == null) {
            mbind_body_remove_collision_exception = try api.createMethod("PhysicsServer", "body_remove_collision_exception");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_excepted_body),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_remove_collision_exception, base, cargs, result);
    }

    pub fn bodyRemoveShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32) !void {
        if (mbind_body_remove_shape == null) {
            mbind_body_remove_shape = try api.createMethod("PhysicsServer", "body_remove_shape");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_remove_shape, base, cargs, result);
    }

    pub fn bodySetAxisLock(self: *const Self, arg_body: *const godot.RID, arg_axis: i32, arg_lock: bool) !void {
        if (mbind_body_set_axis_lock == null) {
            mbind_body_set_axis_lock = try api.createMethod("PhysicsServer", "body_set_axis_lock");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_axis),
            @ptrCast(*const anyopaque, *arg_lock),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_axis_lock, base, cargs, result);
    }

    pub fn bodySetAxisVelocity(self: *const Self, arg_body: *const godot.RID, arg_axis_velocity: *const godot.Vector3) !void {
        if (mbind_body_set_axis_velocity == null) {
            mbind_body_set_axis_velocity = try api.createMethod("PhysicsServer", "body_set_axis_velocity");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_axis_velocity),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_axis_velocity, base, cargs, result);
    }

    pub fn bodySetCollisionLayer(self: *const Self, arg_body: *const godot.RID, arg_layer: i32) !void {
        if (mbind_body_set_collision_layer == null) {
            mbind_body_set_collision_layer = try api.createMethod("PhysicsServer", "body_set_collision_layer");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_layer),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_collision_layer, base, cargs, result);
    }

    pub fn bodySetCollisionMask(self: *const Self, arg_body: *const godot.RID, arg_mask: i32) !void {
        if (mbind_body_set_collision_mask == null) {
            mbind_body_set_collision_mask = try api.createMethod("PhysicsServer", "body_set_collision_mask");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_mask),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_collision_mask, base, cargs, result);
    }

    pub fn bodySetEnableContinuousCollisionDetection(self: *const Self, arg_body: *const godot.RID, arg_enable: bool) !void {
        if (mbind_body_set_enable_continuous_collision_detection == null) {
            mbind_body_set_enable_continuous_collision_detection = try api.createMethod("PhysicsServer", "body_set_enable_continuous_collision_detection");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_enable_continuous_collision_detection, base, cargs, result);
    }

    pub fn bodySetForceIntegrationCallback(self: *const Self, arg_body: *const godot.RID, arg_receiver: *const godot.Object, arg_method: *const godot.String, arg_userdata: *const godot.Variant) !void {
        if (mbind_body_set_force_integration_callback == null) {
            mbind_body_set_force_integration_callback = try api.createMethod("PhysicsServer", "body_set_force_integration_callback");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_receiver),
            @ptrCast(*const anyopaque, arg_method),
            @ptrCast(*const anyopaque, arg_userdata),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_force_integration_callback, base, cargs, result);
    }

    pub fn bodySetKinematicSafeMargin(self: *const Self, arg_body: *const godot.RID, arg_margin: f32) !void {
        if (mbind_body_set_kinematic_safe_margin == null) {
            mbind_body_set_kinematic_safe_margin = try api.createMethod("PhysicsServer", "body_set_kinematic_safe_margin");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_margin),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_kinematic_safe_margin, base, cargs, result);
    }

    pub fn bodySetMaxContactsReported(self: *const Self, arg_body: *const godot.RID, arg_amount: i32) !void {
        if (mbind_body_set_max_contacts_reported == null) {
            mbind_body_set_max_contacts_reported = try api.createMethod("PhysicsServer", "body_set_max_contacts_reported");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_amount),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_max_contacts_reported, base, cargs, result);
    }

    pub fn bodySetMode(self: *const Self, arg_body: *const godot.RID, arg_mode: i32) !void {
        if (mbind_body_set_mode == null) {
            mbind_body_set_mode = try api.createMethod("PhysicsServer", "body_set_mode");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_mode),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_mode, base, cargs, result);
    }

    pub fn bodySetOmitForceIntegration(self: *const Self, arg_body: *const godot.RID, arg_enable: bool) !void {
        if (mbind_body_set_omit_force_integration == null) {
            mbind_body_set_omit_force_integration = try api.createMethod("PhysicsServer", "body_set_omit_force_integration");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_omit_force_integration, base, cargs, result);
    }

    pub fn bodySetParam(self: *const Self, arg_body: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_body_set_param == null) {
            mbind_body_set_param = try api.createMethod("PhysicsServer", "body_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_param, base, cargs, result);
    }

    pub fn bodySetRayPickable(self: *const Self, arg_body: *const godot.RID, arg_enable: bool) !void {
        if (mbind_body_set_ray_pickable == null) {
            mbind_body_set_ray_pickable = try api.createMethod("PhysicsServer", "body_set_ray_pickable");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_ray_pickable, base, cargs, result);
    }

    pub fn bodySetShape(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_shape: *const godot.RID) !void {
        if (mbind_body_set_shape == null) {
            mbind_body_set_shape = try api.createMethod("PhysicsServer", "body_set_shape");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape, base, cargs, result);
    }

    pub fn bodySetShapeDisabled(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_disabled: bool) !void {
        if (mbind_body_set_shape_disabled == null) {
            mbind_body_set_shape_disabled = try api.createMethod("PhysicsServer", "body_set_shape_disabled");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, *arg_disabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_disabled, base, cargs, result);
    }

    pub fn bodySetShapeTransform(self: *const Self, arg_body: *const godot.RID, arg_shape_idx: i32, arg_transform: *const godot.Transform) !void {
        if (mbind_body_set_shape_transform == null) {
            mbind_body_set_shape_transform = try api.createMethod("PhysicsServer", "body_set_shape_transform");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_shape_idx),
            @ptrCast(*const anyopaque, arg_transform),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_shape_transform, base, cargs, result);
    }

    pub fn bodySetSpace(self: *const Self, arg_body: *const godot.RID, arg_space: *const godot.RID) !void {
        if (mbind_body_set_space == null) {
            mbind_body_set_space = try api.createMethod("PhysicsServer", "body_set_space");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_space, base, cargs, result);
    }

    pub fn bodySetState(self: *const Self, arg_body: *const godot.RID, arg_state: i32, arg_value: *const godot.Variant) !void {
        if (mbind_body_set_state == null) {
            mbind_body_set_state = try api.createMethod("PhysicsServer", "body_set_state");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, *arg_state),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_set_state, base, cargs, result);
    }

    pub fn bodyTestMotion(self: *const Self, arg_body: *const godot.RID, arg_from: *const godot.Transform, arg_motion: *const godot.Vector3, arg_infinite_inertia: bool, arg_result: *const godot.PhysicsTestMotionResult, arg_exclude_raycast_shapes: bool, arg_exclude: *const godot.Array) !bool {
        if (mbind_body_test_motion == null) {
            mbind_body_test_motion = try api.createMethod("PhysicsServer", "body_test_motion");
        }

        var result: ?*anyopaque = null;
        var args: [7]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body),
            @ptrCast(*const anyopaque, arg_from),
            @ptrCast(*const anyopaque, arg_motion),
            @ptrCast(*const anyopaque, *arg_infinite_inertia),
            @ptrCast(*const anyopaque, arg_result),
            @ptrCast(*const anyopaque, *arg_exclude_raycast_shapes),
            @ptrCast(*const anyopaque, arg_exclude),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_body_test_motion, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn coneTwistJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_cone_twist_joint_get_param == null) {
            mbind_cone_twist_joint_get_param = try api.createMethod("PhysicsServer", "cone_twist_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cone_twist_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn coneTwistJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_cone_twist_joint_set_param == null) {
            mbind_cone_twist_joint_set_param = try api.createMethod("PhysicsServer", "cone_twist_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_cone_twist_joint_set_param, base, cargs, result);
    }

    pub fn freeRid(self: *const Self, arg_rid: *const godot.RID) !void {
        if (mbind_free_rid == null) {
            mbind_free_rid = try api.createMethod("PhysicsServer", "free_rid");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_rid),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_free_rid, base, cargs, result);
    }

    pub fn generic6dofJointGetFlag(self: *const Self, arg_joint: *const godot.RID, arg_axis: i32, arg_flag: i32) !bool {
        if (mbind_generic_6dof_joint_get_flag == null) {
            mbind_generic_6dof_joint_get_flag = try api.createMethod("PhysicsServer", "generic_6dof_joint_get_flag");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_axis),
            @ptrCast(*const anyopaque, *arg_flag),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generic_6dof_joint_get_flag, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn generic6dofJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_axis: i32, arg_param: i32) !f32 {
        if (mbind_generic_6dof_joint_get_param == null) {
            mbind_generic_6dof_joint_get_param = try api.createMethod("PhysicsServer", "generic_6dof_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_axis),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generic_6dof_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn generic6dofJointSetFlag(self: *const Self, arg_joint: *const godot.RID, arg_axis: i32, arg_flag: i32, arg_enable: bool) !void {
        if (mbind_generic_6dof_joint_set_flag == null) {
            mbind_generic_6dof_joint_set_flag = try api.createMethod("PhysicsServer", "generic_6dof_joint_set_flag");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_axis),
            @ptrCast(*const anyopaque, *arg_flag),
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generic_6dof_joint_set_flag, base, cargs, result);
    }

    pub fn generic6dofJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_axis: i32, arg_param: i32, arg_value: f32) !void {
        if (mbind_generic_6dof_joint_set_param == null) {
            mbind_generic_6dof_joint_set_param = try api.createMethod("PhysicsServer", "generic_6dof_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_axis),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_generic_6dof_joint_set_param, base, cargs, result);
    }

    pub fn getProcessInfo(self: *const Self, arg_process_info: i32) !i32 {
        if (mbind_get_process_info == null) {
            mbind_get_process_info = try api.createMethod("PhysicsServer", "get_process_info");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_process_info),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_process_info, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn hingeJointGetFlag(self: *const Self, arg_joint: *const godot.RID, arg_flag: i32) !bool {
        if (mbind_hinge_joint_get_flag == null) {
            mbind_hinge_joint_get_flag = try api.createMethod("PhysicsServer", "hinge_joint_get_flag");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_flag),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hinge_joint_get_flag, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hingeJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_hinge_joint_get_param == null) {
            mbind_hinge_joint_get_param = try api.createMethod("PhysicsServer", "hinge_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hinge_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn hingeJointSetFlag(self: *const Self, arg_joint: *const godot.RID, arg_flag: i32, arg_enabled: bool) !void {
        if (mbind_hinge_joint_set_flag == null) {
            mbind_hinge_joint_set_flag = try api.createMethod("PhysicsServer", "hinge_joint_set_flag");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_flag),
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hinge_joint_set_flag, base, cargs, result);
    }

    pub fn hingeJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_hinge_joint_set_param == null) {
            mbind_hinge_joint_set_param = try api.createMethod("PhysicsServer", "hinge_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hinge_joint_set_param, base, cargs, result);
    }

    pub fn jointCreateConeTwist(self: *const Self, arg_body_A: *const godot.RID, arg_local_ref_A: *const godot.Transform, arg_body_B: *const godot.RID, arg_local_ref_B: *const godot.Transform) !godot.RID {
        if (mbind_joint_create_cone_twist == null) {
            mbind_joint_create_cone_twist = try api.createMethod("PhysicsServer", "joint_create_cone_twist");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body_A),
            @ptrCast(*const anyopaque, arg_local_ref_A),
            @ptrCast(*const anyopaque, arg_body_B),
            @ptrCast(*const anyopaque, arg_local_ref_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_create_cone_twist, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointCreateGeneric6dof(self: *const Self, arg_body_A: *const godot.RID, arg_local_ref_A: *const godot.Transform, arg_body_B: *const godot.RID, arg_local_ref_B: *const godot.Transform) !godot.RID {
        if (mbind_joint_create_generic_6dof == null) {
            mbind_joint_create_generic_6dof = try api.createMethod("PhysicsServer", "joint_create_generic_6dof");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body_A),
            @ptrCast(*const anyopaque, arg_local_ref_A),
            @ptrCast(*const anyopaque, arg_body_B),
            @ptrCast(*const anyopaque, arg_local_ref_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_create_generic_6dof, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointCreateHinge(self: *const Self, arg_body_A: *const godot.RID, arg_hinge_A: *const godot.Transform, arg_body_B: *const godot.RID, arg_hinge_B: *const godot.Transform) !godot.RID {
        if (mbind_joint_create_hinge == null) {
            mbind_joint_create_hinge = try api.createMethod("PhysicsServer", "joint_create_hinge");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body_A),
            @ptrCast(*const anyopaque, arg_hinge_A),
            @ptrCast(*const anyopaque, arg_body_B),
            @ptrCast(*const anyopaque, arg_hinge_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_create_hinge, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointCreatePin(self: *const Self, arg_body_A: *const godot.RID, arg_local_A: *const godot.Vector3, arg_body_B: *const godot.RID, arg_local_B: *const godot.Vector3) !godot.RID {
        if (mbind_joint_create_pin == null) {
            mbind_joint_create_pin = try api.createMethod("PhysicsServer", "joint_create_pin");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body_A),
            @ptrCast(*const anyopaque, arg_local_A),
            @ptrCast(*const anyopaque, arg_body_B),
            @ptrCast(*const anyopaque, arg_local_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_create_pin, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointCreateSlider(self: *const Self, arg_body_A: *const godot.RID, arg_local_ref_A: *const godot.Transform, arg_body_B: *const godot.RID, arg_local_ref_B: *const godot.Transform) !godot.RID {
        if (mbind_joint_create_slider == null) {
            mbind_joint_create_slider = try api.createMethod("PhysicsServer", "joint_create_slider");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_body_A),
            @ptrCast(*const anyopaque, arg_local_ref_A),
            @ptrCast(*const anyopaque, arg_body_B),
            @ptrCast(*const anyopaque, arg_local_ref_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_create_slider, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn jointGetSolverPriority(self: *const Self, arg_joint: *const godot.RID) !i32 {
        if (mbind_joint_get_solver_priority == null) {
            mbind_joint_get_solver_priority = try api.createMethod("PhysicsServer", "joint_get_solver_priority");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_get_solver_priority, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn jointGetType(self: *const Self, arg_joint: *const godot.RID) !i32 {
        if (mbind_joint_get_type == null) {
            mbind_joint_get_type = try api.createMethod("PhysicsServer", "joint_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn jointSetSolverPriority(self: *const Self, arg_joint: *const godot.RID, arg_priority: i32) !void {
        if (mbind_joint_set_solver_priority == null) {
            mbind_joint_set_solver_priority = try api.createMethod("PhysicsServer", "joint_set_solver_priority");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_priority),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_joint_set_solver_priority, base, cargs, result);
    }

    pub fn pinJointGetLocalA(self: *const Self, arg_joint: *const godot.RID) !godot.Vector3 {
        if (mbind_pin_joint_get_local_a == null) {
            mbind_pin_joint_get_local_a = try api.createMethod("PhysicsServer", "pin_joint_get_local_a");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_get_local_a, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn pinJointGetLocalB(self: *const Self, arg_joint: *const godot.RID) !godot.Vector3 {
        if (mbind_pin_joint_get_local_b == null) {
            mbind_pin_joint_get_local_b = try api.createMethod("PhysicsServer", "pin_joint_get_local_b");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_get_local_b, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn pinJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_pin_joint_get_param == null) {
            mbind_pin_joint_get_param = try api.createMethod("PhysicsServer", "pin_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn pinJointSetLocalA(self: *const Self, arg_joint: *const godot.RID, arg_local_A: *const godot.Vector3) !void {
        if (mbind_pin_joint_set_local_a == null) {
            mbind_pin_joint_set_local_a = try api.createMethod("PhysicsServer", "pin_joint_set_local_a");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, arg_local_A),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_set_local_a, base, cargs, result);
    }

    pub fn pinJointSetLocalB(self: *const Self, arg_joint: *const godot.RID, arg_local_B: *const godot.Vector3) !void {
        if (mbind_pin_joint_set_local_b == null) {
            mbind_pin_joint_set_local_b = try api.createMethod("PhysicsServer", "pin_joint_set_local_b");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, arg_local_B),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_set_local_b, base, cargs, result);
    }

    pub fn pinJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_pin_joint_set_param == null) {
            mbind_pin_joint_set_param = try api.createMethod("PhysicsServer", "pin_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_pin_joint_set_param, base, cargs, result);
    }

    pub fn setActive(self: *const Self, arg_active: bool) !void {
        if (mbind_set_active == null) {
            mbind_set_active = try api.createMethod("PhysicsServer", "set_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_active, base, cargs, result);
    }

    pub fn setCollisionIterations(self: *const Self, arg_iterations: i32) !void {
        if (mbind_set_collision_iterations == null) {
            mbind_set_collision_iterations = try api.createMethod("PhysicsServer", "set_collision_iterations");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_iterations),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_collision_iterations, base, cargs, result);
    }

    pub fn shapeCreate(self: *const Self, arg_type: i32) !godot.RID {
        if (mbind_shape_create == null) {
            mbind_shape_create = try api.createMethod("PhysicsServer", "shape_create");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn shapeGetData(self: *const Self, arg_shape: *const godot.RID) !godot.Variant {
        if (mbind_shape_get_data == null) {
            mbind_shape_get_data = try api.createMethod("PhysicsServer", "shape_get_data");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_get_data, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn shapeGetType(self: *const Self, arg_shape: *const godot.RID) !i32 {
        if (mbind_shape_get_type == null) {
            mbind_shape_get_type = try api.createMethod("PhysicsServer", "shape_get_type");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_get_type, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn shapeSetData(self: *const Self, arg_shape: *const godot.RID, arg_data: *const godot.Variant) !void {
        if (mbind_shape_set_data == null) {
            mbind_shape_set_data = try api.createMethod("PhysicsServer", "shape_set_data");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_shape),
            @ptrCast(*const anyopaque, arg_data),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_shape_set_data, base, cargs, result);
    }

    pub fn sliderJointGetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_slider_joint_get_param == null) {
            mbind_slider_joint_get_param = try api.createMethod("PhysicsServer", "slider_joint_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_slider_joint_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn sliderJointSetParam(self: *const Self, arg_joint: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_slider_joint_set_param == null) {
            mbind_slider_joint_set_param = try api.createMethod("PhysicsServer", "slider_joint_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_joint),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_slider_joint_set_param, base, cargs, result);
    }

    pub fn spaceCreate(self: *const Self) !godot.RID {
        if (mbind_space_create == null) {
            mbind_space_create = try api.createMethod("PhysicsServer", "space_create");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_create, base, cargs, result);
        return @ptrCast(*godot.RID, @alignCast(@alignOf(&godot.RID), result)).*;
    }

    pub fn spaceGetDirectState(self: *const Self, arg_space: *const godot.RID) !godot.PhysicsDirectSpaceState {
        if (mbind_space_get_direct_state == null) {
            mbind_space_get_direct_state = try api.createMethod("PhysicsServer", "space_get_direct_state");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_get_direct_state, base, cargs, result);
        return @ptrCast(*godot.PhysicsDirectSpaceState, @alignCast(@alignOf(&godot.PhysicsDirectSpaceState), result)).*;
    }

    pub fn spaceGetParam(self: *const Self, arg_space: *const godot.RID, arg_param: i32) !f32 {
        if (mbind_space_get_param == null) {
            mbind_space_get_param = try api.createMethod("PhysicsServer", "space_get_param");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_param),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_get_param, base, cargs, result);
        return @ptrCast(*f32, @alignCast(@alignOf(&f32), result)).*;
    }

    pub fn spaceIsActive(self: *const Self, arg_space: *const godot.RID) !bool {
        if (mbind_space_is_active == null) {
            mbind_space_is_active = try api.createMethod("PhysicsServer", "space_is_active");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_is_active, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn spaceSetActive(self: *const Self, arg_space: *const godot.RID, arg_active: bool) !void {
        if (mbind_space_set_active == null) {
            mbind_space_set_active = try api.createMethod("PhysicsServer", "space_set_active");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_active),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_set_active, base, cargs, result);
    }

    pub fn spaceSetParam(self: *const Self, arg_space: *const godot.RID, arg_param: i32, arg_value: f32) !void {
        if (mbind_space_set_param == null) {
            mbind_space_set_param = try api.createMethod("PhysicsServer", "space_set_param");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_space),
            @ptrCast(*const anyopaque, *arg_param),
            @ptrCast(*const anyopaque, *arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_space_set_param, base, cargs, result);
    }
};