// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// method bindings
var mbind_clear: ?*c_api.godot_method_bind = null;
var mbind_clear_color: ?*c_api.godot_method_bind = null;
var mbind_clear_constant: ?*c_api.godot_method_bind = null;
var mbind_clear_font: ?*c_api.godot_method_bind = null;
var mbind_clear_icon: ?*c_api.godot_method_bind = null;
var mbind_clear_stylebox: ?*c_api.godot_method_bind = null;
var mbind_clear_theme_item: ?*c_api.godot_method_bind = null;
var mbind_copy_default_theme: ?*c_api.godot_method_bind = null;
var mbind_copy_theme: ?*c_api.godot_method_bind = null;
var mbind_get_color: ?*c_api.godot_method_bind = null;
var mbind_get_color_list: ?*c_api.godot_method_bind = null;
var mbind_get_color_types: ?*c_api.godot_method_bind = null;
var mbind_get_constant: ?*c_api.godot_method_bind = null;
var mbind_get_constant_list: ?*c_api.godot_method_bind = null;
var mbind_get_constant_types: ?*c_api.godot_method_bind = null;
var mbind_get_default_font: ?*c_api.godot_method_bind = null;
var mbind_get_font: ?*c_api.godot_method_bind = null;
var mbind_get_font_list: ?*c_api.godot_method_bind = null;
var mbind_get_font_types: ?*c_api.godot_method_bind = null;
var mbind_get_icon: ?*c_api.godot_method_bind = null;
var mbind_get_icon_list: ?*c_api.godot_method_bind = null;
var mbind_get_icon_types: ?*c_api.godot_method_bind = null;
var mbind_get_stylebox: ?*c_api.godot_method_bind = null;
var mbind_get_stylebox_list: ?*c_api.godot_method_bind = null;
var mbind_get_stylebox_types: ?*c_api.godot_method_bind = null;
var mbind_get_theme_item: ?*c_api.godot_method_bind = null;
var mbind_get_theme_item_list: ?*c_api.godot_method_bind = null;
var mbind_get_theme_item_types: ?*c_api.godot_method_bind = null;
var mbind_get_type_list: ?*c_api.godot_method_bind = null;
var mbind_has_color: ?*c_api.godot_method_bind = null;
var mbind_has_constant: ?*c_api.godot_method_bind = null;
var mbind_has_default_font: ?*c_api.godot_method_bind = null;
var mbind_has_font: ?*c_api.godot_method_bind = null;
var mbind_has_icon: ?*c_api.godot_method_bind = null;
var mbind_has_stylebox: ?*c_api.godot_method_bind = null;
var mbind_has_theme_item: ?*c_api.godot_method_bind = null;
var mbind_merge_with: ?*c_api.godot_method_bind = null;
var mbind_rename_color: ?*c_api.godot_method_bind = null;
var mbind_rename_constant: ?*c_api.godot_method_bind = null;
var mbind_rename_font: ?*c_api.godot_method_bind = null;
var mbind_rename_icon: ?*c_api.godot_method_bind = null;
var mbind_rename_stylebox: ?*c_api.godot_method_bind = null;
var mbind_rename_theme_item: ?*c_api.godot_method_bind = null;
var mbind_set_color: ?*c_api.godot_method_bind = null;
var mbind_set_constant: ?*c_api.godot_method_bind = null;
var mbind_set_default_font: ?*c_api.godot_method_bind = null;
var mbind_set_font: ?*c_api.godot_method_bind = null;
var mbind_set_icon: ?*c_api.godot_method_bind = null;
var mbind_set_stylebox: ?*c_api.godot_method_bind = null;
var mbind_set_theme_item: ?*c_api.godot_method_bind = null;
var mbind_theme_constructor: ?fn () ?*c_api.godot_object = null;

pub const Theme = struct {
    const Self = @This();
    pub const BaseClass = godot.Resource;

    // Pointers to zero-sized types are also zero-sized,
    // therefore we need to add some data to make it not zero-sized :)
    _data: u8,
    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_theme_constructor == null) {
            mbind_theme_constructor = try api.createConstructor("Theme");
        }
        return api.createObject(Self, mbind_theme_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn clear(self: *const Self) !void {
        if (mbind_clear == null) {
            mbind_clear = try api.createMethod("Theme", "clear");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear, base, cargs, result);
    }

    pub fn clearColor(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_color == null) {
            mbind_clear_color = try api.createMethod("Theme", "clear_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_color, base, cargs, result);
    }

    pub fn clearConstant(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_constant == null) {
            mbind_clear_constant = try api.createMethod("Theme", "clear_constant");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_constant, base, cargs, result);
    }

    pub fn clearFont(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_font == null) {
            mbind_clear_font = try api.createMethod("Theme", "clear_font");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_font, base, cargs, result);
    }

    pub fn clearIcon(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_icon == null) {
            mbind_clear_icon = try api.createMethod("Theme", "clear_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_icon, base, cargs, result);
    }

    pub fn clearStylebox(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_stylebox == null) {
            mbind_clear_stylebox = try api.createMethod("Theme", "clear_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_stylebox, base, cargs, result);
    }

    pub fn clearThemeItem(self: *const Self, arg_data_type: i32, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_clear_theme_item == null) {
            mbind_clear_theme_item = try api.createMethod("Theme", "clear_theme_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_clear_theme_item, base, cargs, result);
    }

    pub fn copyDefaultTheme(self: *const Self) !void {
        if (mbind_copy_default_theme == null) {
            mbind_copy_default_theme = try api.createMethod("Theme", "copy_default_theme");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_copy_default_theme, base, cargs, result);
    }

    pub fn copyTheme(self: *const Self, arg_other: *const godot.Theme) !void {
        if (mbind_copy_theme == null) {
            mbind_copy_theme = try api.createMethod("Theme", "copy_theme");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_other),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_copy_theme, base, cargs, result);
    }

    pub fn getColor(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !godot.Color {
        if (mbind_get_color == null) {
            mbind_get_color = try api.createMethod("Theme", "get_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_color, base, cargs, result);
        return @ptrCast(*godot.Color, @alignCast(@alignOf(&godot.Color), result)).*;
    }

    pub fn getColorList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_color_list == null) {
            mbind_get_color_list = try api.createMethod("Theme", "get_color_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_color_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getColorTypes(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_color_types == null) {
            mbind_get_color_types = try api.createMethod("Theme", "get_color_types");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_color_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getConstant(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !i32 {
        if (mbind_get_constant == null) {
            mbind_get_constant = try api.createMethod("Theme", "get_constant");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_constant, base, cargs, result);
        return @ptrCast(*i32, @alignCast(@alignOf(&i32), result)).*;
    }

    pub fn getConstantList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_constant_list == null) {
            mbind_get_constant_list = try api.createMethod("Theme", "get_constant_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_constant_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getConstantTypes(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_constant_types == null) {
            mbind_get_constant_types = try api.createMethod("Theme", "get_constant_types");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_constant_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getDefaultFont(self: *const Self) !godot.Font {
        if (mbind_get_default_font == null) {
            mbind_get_default_font = try api.createMethod("Theme", "get_default_font");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_default_font, base, cargs, result);
        return @ptrCast(*godot.Font, @alignCast(@alignOf(&godot.Font), result)).*;
    }

    pub fn getFont(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !godot.Font {
        if (mbind_get_font == null) {
            mbind_get_font = try api.createMethod("Theme", "get_font");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_font, base, cargs, result);
        return @ptrCast(*godot.Font, @alignCast(@alignOf(&godot.Font), result)).*;
    }

    pub fn getFontList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_font_list == null) {
            mbind_get_font_list = try api.createMethod("Theme", "get_font_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_font_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getFontTypes(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_font_types == null) {
            mbind_get_font_types = try api.createMethod("Theme", "get_font_types");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_font_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getIcon(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !godot.Texture {
        if (mbind_get_icon == null) {
            mbind_get_icon = try api.createMethod("Theme", "get_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon, base, cargs, result);
        return @ptrCast(*godot.Texture, @alignCast(@alignOf(&godot.Texture), result)).*;
    }

    pub fn getIconList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_icon_list == null) {
            mbind_get_icon_list = try api.createMethod("Theme", "get_icon_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getIconTypes(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_icon_types == null) {
            mbind_get_icon_types = try api.createMethod("Theme", "get_icon_types");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_icon_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getStylebox(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !godot.StyleBox {
        if (mbind_get_stylebox == null) {
            mbind_get_stylebox = try api.createMethod("Theme", "get_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stylebox, base, cargs, result);
        return @ptrCast(*godot.StyleBox, @alignCast(@alignOf(&godot.StyleBox), result)).*;
    }

    pub fn getStyleboxList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_stylebox_list == null) {
            mbind_get_stylebox_list = try api.createMethod("Theme", "get_stylebox_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stylebox_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getStyleboxTypes(self: *const Self) !godot.PoolStringArray {
        if (mbind_get_stylebox_types == null) {
            mbind_get_stylebox_types = try api.createMethod("Theme", "get_stylebox_types");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_stylebox_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getThemeItem(self: *const Self, arg_data_type: i32, arg_name: *const godot.String, arg_node_type: *const godot.String) !godot.Variant {
        if (mbind_get_theme_item == null) {
            mbind_get_theme_item = try api.createMethod("Theme", "get_theme_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_theme_item, base, cargs, result);
        return @ptrCast(*godot.Variant, @alignCast(@alignOf(&godot.Variant), result)).*;
    }

    pub fn getThemeItemList(self: *const Self, arg_data_type: i32, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_theme_item_list == null) {
            mbind_get_theme_item_list = try api.createMethod("Theme", "get_theme_item_list");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_theme_item_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getThemeItemTypes(self: *const Self, arg_data_type: i32) !godot.PoolStringArray {
        if (mbind_get_theme_item_types == null) {
            mbind_get_theme_item_types = try api.createMethod("Theme", "get_theme_item_types");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_theme_item_types, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn getTypeList(self: *const Self, arg_node_type: *const godot.String) !godot.PoolStringArray {
        if (mbind_get_type_list == null) {
            mbind_get_type_list = try api.createMethod("Theme", "get_type_list");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_type_list, base, cargs, result);
        return @ptrCast(*godot.PoolStringArray, @alignCast(@alignOf(&godot.PoolStringArray), result)).*;
    }

    pub fn hasColor(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_color == null) {
            mbind_has_color = try api.createMethod("Theme", "has_color");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_color, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasConstant(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_constant == null) {
            mbind_has_constant = try api.createMethod("Theme", "has_constant");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_constant, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasDefaultFont(self: *const Self) !bool {
        if (mbind_has_default_font == null) {
            mbind_has_default_font = try api.createMethod("Theme", "has_default_font");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_default_font, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasFont(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_font == null) {
            mbind_has_font = try api.createMethod("Theme", "has_font");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_font, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasIcon(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_icon == null) {
            mbind_has_icon = try api.createMethod("Theme", "has_icon");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_icon, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasStylebox(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_stylebox == null) {
            mbind_has_stylebox = try api.createMethod("Theme", "has_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_stylebox, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn hasThemeItem(self: *const Self, arg_data_type: i32, arg_name: *const godot.String, arg_node_type: *const godot.String) !bool {
        if (mbind_has_theme_item == null) {
            mbind_has_theme_item = try api.createMethod("Theme", "has_theme_item");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_has_theme_item, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn mergeWith(self: *const Self, arg_other: *const godot.Theme) !void {
        if (mbind_merge_with == null) {
            mbind_merge_with = try api.createMethod("Theme", "merge_with");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_other),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_merge_with, base, cargs, result);
    }

    pub fn renameColor(self: *const Self, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_color == null) {
            mbind_rename_color = try api.createMethod("Theme", "rename_color");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_color, base, cargs, result);
    }

    pub fn renameConstant(self: *const Self, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_constant == null) {
            mbind_rename_constant = try api.createMethod("Theme", "rename_constant");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_constant, base, cargs, result);
    }

    pub fn renameFont(self: *const Self, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_font == null) {
            mbind_rename_font = try api.createMethod("Theme", "rename_font");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_font, base, cargs, result);
    }

    pub fn renameIcon(self: *const Self, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_icon == null) {
            mbind_rename_icon = try api.createMethod("Theme", "rename_icon");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_icon, base, cargs, result);
    }

    pub fn renameStylebox(self: *const Self, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_stylebox == null) {
            mbind_rename_stylebox = try api.createMethod("Theme", "rename_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_stylebox, base, cargs, result);
    }

    pub fn renameThemeItem(self: *const Self, arg_data_type: i32, arg_old_name: *const godot.String, arg_name: *const godot.String, arg_node_type: *const godot.String) !void {
        if (mbind_rename_theme_item == null) {
            mbind_rename_theme_item = try api.createMethod("Theme", "rename_theme_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_old_name),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rename_theme_item, base, cargs, result);
    }

    pub fn setColor(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_color: *const godot.Color) !void {
        if (mbind_set_color == null) {
            mbind_set_color = try api.createMethod("Theme", "set_color");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, arg_color),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_color, base, cargs, result);
    }

    pub fn setConstant(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_constant: i32) !void {
        if (mbind_set_constant == null) {
            mbind_set_constant = try api.createMethod("Theme", "set_constant");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, *arg_constant),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_constant, base, cargs, result);
    }

    pub fn setDefaultFont(self: *const Self, arg_font: *const godot.Font) !void {
        if (mbind_set_default_font == null) {
            mbind_set_default_font = try api.createMethod("Theme", "set_default_font");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_font),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_default_font, base, cargs, result);
    }

    pub fn setFont(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_font: *const godot.Font) !void {
        if (mbind_set_font == null) {
            mbind_set_font = try api.createMethod("Theme", "set_font");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, arg_font),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_font, base, cargs, result);
    }

    pub fn setIcon(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_texture: *const godot.Texture) !void {
        if (mbind_set_icon == null) {
            mbind_set_icon = try api.createMethod("Theme", "set_icon");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_icon, base, cargs, result);
    }

    pub fn setStylebox(self: *const Self, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_texture: *const godot.StyleBox) !void {
        if (mbind_set_stylebox == null) {
            mbind_set_stylebox = try api.createMethod("Theme", "set_stylebox");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, arg_texture),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_stylebox, base, cargs, result);
    }

    pub fn setThemeItem(self: *const Self, arg_data_type: i32, arg_name: *const godot.String, arg_node_type: *const godot.String, arg_value: *const godot.Variant) !void {
        if (mbind_set_theme_item == null) {
            mbind_set_theme_item = try api.createMethod("Theme", "set_theme_item");
        }

        var result: ?*anyopaque = null;
        var args: [4]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_data_type),
            @ptrCast(*const anyopaque, arg_name),
            @ptrCast(*const anyopaque, arg_node_type),
            @ptrCast(*const anyopaque, arg_value),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_theme_item, base, cargs, result);
    }
};