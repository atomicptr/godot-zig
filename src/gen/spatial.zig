// This file was automatically generated by godot-zig, please do not edit it.
const godot = @import("__import.zig");
const api = @import("../api.zig");
const c_api = @import("../c_api.zig");

// base class
const Node = @import("node.zig").Node;

// method bindings
var mbind_force_update_transform: ?*c_api.godot_method_bind = null;
var mbind_get_gizmo: ?*c_api.godot_method_bind = null;
var mbind_get_global_transform: ?*c_api.godot_method_bind = null;
var mbind_get_parent_spatial: ?*c_api.godot_method_bind = null;
var mbind_get_rotation: ?*c_api.godot_method_bind = null;
var mbind_get_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_get_scale: ?*c_api.godot_method_bind = null;
var mbind_get_transform: ?*c_api.godot_method_bind = null;
var mbind_get_translation: ?*c_api.godot_method_bind = null;
var mbind_get_world: ?*c_api.godot_method_bind = null;
var mbind_global_rotate: ?*c_api.godot_method_bind = null;
var mbind_global_scale: ?*c_api.godot_method_bind = null;
var mbind_global_translate: ?*c_api.godot_method_bind = null;
var mbind_hide: ?*c_api.godot_method_bind = null;
var mbind_is_local_transform_notification_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_scale_disabled: ?*c_api.godot_method_bind = null;
var mbind_is_set_as_toplevel: ?*c_api.godot_method_bind = null;
var mbind_is_transform_notification_enabled: ?*c_api.godot_method_bind = null;
var mbind_is_visible: ?*c_api.godot_method_bind = null;
var mbind_is_visible_in_tree: ?*c_api.godot_method_bind = null;
var mbind_look_at: ?*c_api.godot_method_bind = null;
var mbind_look_at_from_position: ?*c_api.godot_method_bind = null;
var mbind_orthonormalize: ?*c_api.godot_method_bind = null;
var mbind_rotate: ?*c_api.godot_method_bind = null;
var mbind_rotate_object_local: ?*c_api.godot_method_bind = null;
var mbind_rotate_x: ?*c_api.godot_method_bind = null;
var mbind_rotate_y: ?*c_api.godot_method_bind = null;
var mbind_rotate_z: ?*c_api.godot_method_bind = null;
var mbind_scale_object_local: ?*c_api.godot_method_bind = null;
var mbind_set_as_toplevel: ?*c_api.godot_method_bind = null;
var mbind_set_disable_scale: ?*c_api.godot_method_bind = null;
var mbind_set_gizmo: ?*c_api.godot_method_bind = null;
var mbind_set_global_transform: ?*c_api.godot_method_bind = null;
var mbind_set_identity: ?*c_api.godot_method_bind = null;
var mbind_set_ignore_transform_notification: ?*c_api.godot_method_bind = null;
var mbind_set_notify_local_transform: ?*c_api.godot_method_bind = null;
var mbind_set_notify_transform: ?*c_api.godot_method_bind = null;
var mbind_set_rotation: ?*c_api.godot_method_bind = null;
var mbind_set_rotation_degrees: ?*c_api.godot_method_bind = null;
var mbind_set_scale: ?*c_api.godot_method_bind = null;
var mbind_set_transform: ?*c_api.godot_method_bind = null;
var mbind_set_translation: ?*c_api.godot_method_bind = null;
var mbind_set_visible: ?*c_api.godot_method_bind = null;
var mbind_show: ?*c_api.godot_method_bind = null;
var mbind_to_global: ?*c_api.godot_method_bind = null;
var mbind_to_local: ?*c_api.godot_method_bind = null;
var mbind_translate: ?*c_api.godot_method_bind = null;
var mbind_translate_object_local: ?*c_api.godot_method_bind = null;
var mbind_update_gizmo: ?*c_api.godot_method_bind = null;
var mbind_spatial_constructor: ?fn () ?*c_api.godot_object = null;

pub const Spatial = struct {
    const Self = @This();
    const BaseClass = Node;

    base: *BaseClass,

    pub fn init() !*Self {
        if (mbind_spatial_constructor == null) {
            mbind_spatial_constructor = try api.createConstructor("Spatial");
        }
        return api.createObject(Self, mbind_spatial_constructor.?);
    }

    pub fn deinit(self: *Self) void {
        _ = api.core.?.godot_object_destroy.?(@ptrCast(*c_api.godot_object, self));
    }

    pub fn forceUpdateTransform(self: *const Self) !void {
        if (mbind_force_update_transform == null) {
            mbind_force_update_transform = try api.createMethod("Spatial", "force_update_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_force_update_transform, base, cargs, result);
    }

    pub fn getGizmo(self: *const Self) !godot.SpatialGizmo {
        if (mbind_get_gizmo == null) {
            mbind_get_gizmo = try api.createMethod("Spatial", "get_gizmo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_gizmo, base, cargs, result);
        return @ptrCast(*godot.SpatialGizmo, @alignCast(@alignOf(&godot.SpatialGizmo), result)).*;
    }

    pub fn getGlobalTransform(self: *const Self) !godot.Transform {
        if (mbind_get_global_transform == null) {
            mbind_get_global_transform = try api.createMethod("Spatial", "get_global_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_global_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn getParentSpatial(self: *const Self) !godot.Spatial {
        if (mbind_get_parent_spatial == null) {
            mbind_get_parent_spatial = try api.createMethod("Spatial", "get_parent_spatial");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_parent_spatial, base, cargs, result);
        return @ptrCast(*godot.Spatial, @alignCast(@alignOf(&godot.Spatial), result)).*;
    }

    pub fn getRotation(self: *const Self) !godot.Vector3 {
        if (mbind_get_rotation == null) {
            mbind_get_rotation = try api.createMethod("Spatial", "get_rotation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rotation, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getRotationDegrees(self: *const Self) !godot.Vector3 {
        if (mbind_get_rotation_degrees == null) {
            mbind_get_rotation_degrees = try api.createMethod("Spatial", "get_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_rotation_degrees, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getScale(self: *const Self) !godot.Vector3 {
        if (mbind_get_scale == null) {
            mbind_get_scale = try api.createMethod("Spatial", "get_scale");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_scale, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getTransform(self: *const Self) !godot.Transform {
        if (mbind_get_transform == null) {
            mbind_get_transform = try api.createMethod("Spatial", "get_transform");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_transform, base, cargs, result);
        return @ptrCast(*godot.Transform, @alignCast(@alignOf(&godot.Transform), result)).*;
    }

    pub fn getTranslation(self: *const Self) !godot.Vector3 {
        if (mbind_get_translation == null) {
            mbind_get_translation = try api.createMethod("Spatial", "get_translation");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_translation, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn getWorld(self: *const Self) !godot.World {
        if (mbind_get_world == null) {
            mbind_get_world = try api.createMethod("Spatial", "get_world");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_get_world, base, cargs, result);
        return @ptrCast(*godot.World, @alignCast(@alignOf(&godot.World), result)).*;
    }

    pub fn globalRotate(self: *const Self, arg_axis: *const godot.Vector3, arg_angle: f32) !void {
        if (mbind_global_rotate == null) {
            mbind_global_rotate = try api.createMethod("Spatial", "global_rotate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_axis),
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_rotate, base, cargs, result);
    }

    pub fn globalScale(self: *const Self, arg_scale: *const godot.Vector3) !void {
        if (mbind_global_scale == null) {
            mbind_global_scale = try api.createMethod("Spatial", "global_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_scale, base, cargs, result);
    }

    pub fn globalTranslate(self: *const Self, arg_offset: *const godot.Vector3) !void {
        if (mbind_global_translate == null) {
            mbind_global_translate = try api.createMethod("Spatial", "global_translate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_global_translate, base, cargs, result);
    }

    pub fn hide(self: *const Self) !void {
        if (mbind_hide == null) {
            mbind_hide = try api.createMethod("Spatial", "hide");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_hide, base, cargs, result);
    }

    pub fn isLocalTransformNotificationEnabled(self: *const Self) !bool {
        if (mbind_is_local_transform_notification_enabled == null) {
            mbind_is_local_transform_notification_enabled = try api.createMethod("Spatial", "is_local_transform_notification_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_local_transform_notification_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isScaleDisabled(self: *const Self) !bool {
        if (mbind_is_scale_disabled == null) {
            mbind_is_scale_disabled = try api.createMethod("Spatial", "is_scale_disabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_scale_disabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isSetAsToplevel(self: *const Self) !bool {
        if (mbind_is_set_as_toplevel == null) {
            mbind_is_set_as_toplevel = try api.createMethod("Spatial", "is_set_as_toplevel");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_set_as_toplevel, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isTransformNotificationEnabled(self: *const Self) !bool {
        if (mbind_is_transform_notification_enabled == null) {
            mbind_is_transform_notification_enabled = try api.createMethod("Spatial", "is_transform_notification_enabled");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_transform_notification_enabled, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVisible(self: *const Self) !bool {
        if (mbind_is_visible == null) {
            mbind_is_visible = try api.createMethod("Spatial", "is_visible");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_visible, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn isVisibleInTree(self: *const Self) !bool {
        if (mbind_is_visible_in_tree == null) {
            mbind_is_visible_in_tree = try api.createMethod("Spatial", "is_visible_in_tree");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_is_visible_in_tree, base, cargs, result);
        return @ptrCast(*bool, @alignCast(@alignOf(&bool), result)).*;
    }

    pub fn lookAt(self: *const Self, arg_target: *const godot.Vector3, arg_up: *const godot.Vector3) !void {
        if (mbind_look_at == null) {
            mbind_look_at = try api.createMethod("Spatial", "look_at");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_target),
            @ptrCast(*const anyopaque, arg_up),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_look_at, base, cargs, result);
    }

    pub fn lookAtFromPosition(self: *const Self, arg_position: *const godot.Vector3, arg_target: *const godot.Vector3, arg_up: *const godot.Vector3) !void {
        if (mbind_look_at_from_position == null) {
            mbind_look_at_from_position = try api.createMethod("Spatial", "look_at_from_position");
        }

        var result: ?*anyopaque = null;
        var args: [3]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_position),
            @ptrCast(*const anyopaque, arg_target),
            @ptrCast(*const anyopaque, arg_up),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_look_at_from_position, base, cargs, result);
    }

    pub fn orthonormalize(self: *const Self) !void {
        if (mbind_orthonormalize == null) {
            mbind_orthonormalize = try api.createMethod("Spatial", "orthonormalize");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_orthonormalize, base, cargs, result);
    }

    pub fn rotate(self: *const Self, arg_axis: *const godot.Vector3, arg_angle: f32) !void {
        if (mbind_rotate == null) {
            mbind_rotate = try api.createMethod("Spatial", "rotate");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_axis),
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rotate, base, cargs, result);
    }

    pub fn rotateObjectLocal(self: *const Self, arg_axis: *const godot.Vector3, arg_angle: f32) !void {
        if (mbind_rotate_object_local == null) {
            mbind_rotate_object_local = try api.createMethod("Spatial", "rotate_object_local");
        }

        var result: ?*anyopaque = null;
        var args: [2]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_axis),
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rotate_object_local, base, cargs, result);
    }

    pub fn rotateX(self: *const Self, arg_angle: f32) !void {
        if (mbind_rotate_x == null) {
            mbind_rotate_x = try api.createMethod("Spatial", "rotate_x");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rotate_x, base, cargs, result);
    }

    pub fn rotateY(self: *const Self, arg_angle: f32) !void {
        if (mbind_rotate_y == null) {
            mbind_rotate_y = try api.createMethod("Spatial", "rotate_y");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rotate_y, base, cargs, result);
    }

    pub fn rotateZ(self: *const Self, arg_angle: f32) !void {
        if (mbind_rotate_z == null) {
            mbind_rotate_z = try api.createMethod("Spatial", "rotate_z");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_angle),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_rotate_z, base, cargs, result);
    }

    pub fn scaleObjectLocal(self: *const Self, arg_scale: *const godot.Vector3) !void {
        if (mbind_scale_object_local == null) {
            mbind_scale_object_local = try api.createMethod("Spatial", "scale_object_local");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_scale_object_local, base, cargs, result);
    }

    pub fn setAsToplevel(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_as_toplevel == null) {
            mbind_set_as_toplevel = try api.createMethod("Spatial", "set_as_toplevel");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_as_toplevel, base, cargs, result);
    }

    pub fn setDisableScale(self: *const Self, arg_disable: bool) !void {
        if (mbind_set_disable_scale == null) {
            mbind_set_disable_scale = try api.createMethod("Spatial", "set_disable_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_disable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_disable_scale, base, cargs, result);
    }

    pub fn setGizmo(self: *const Self, arg_gizmo: *const godot.SpatialGizmo) !void {
        if (mbind_set_gizmo == null) {
            mbind_set_gizmo = try api.createMethod("Spatial", "set_gizmo");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_gizmo),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_gizmo, base, cargs, result);
    }

    pub fn setGlobalTransform(self: *const Self, arg_global: *const godot.Transform) !void {
        if (mbind_set_global_transform == null) {
            mbind_set_global_transform = try api.createMethod("Spatial", "set_global_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_global),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_global_transform, base, cargs, result);
    }

    pub fn setIdentity(self: *const Self) !void {
        if (mbind_set_identity == null) {
            mbind_set_identity = try api.createMethod("Spatial", "set_identity");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_identity, base, cargs, result);
    }

    pub fn setIgnoreTransformNotification(self: *const Self, arg_enabled: bool) !void {
        if (mbind_set_ignore_transform_notification == null) {
            mbind_set_ignore_transform_notification = try api.createMethod("Spatial", "set_ignore_transform_notification");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enabled),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_ignore_transform_notification, base, cargs, result);
    }

    pub fn setNotifyLocalTransform(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_notify_local_transform == null) {
            mbind_set_notify_local_transform = try api.createMethod("Spatial", "set_notify_local_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_notify_local_transform, base, cargs, result);
    }

    pub fn setNotifyTransform(self: *const Self, arg_enable: bool) !void {
        if (mbind_set_notify_transform == null) {
            mbind_set_notify_transform = try api.createMethod("Spatial", "set_notify_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_enable),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_notify_transform, base, cargs, result);
    }

    pub fn setRotation(self: *const Self, arg_euler: *const godot.Vector3) !void {
        if (mbind_set_rotation == null) {
            mbind_set_rotation = try api.createMethod("Spatial", "set_rotation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_euler),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rotation, base, cargs, result);
    }

    pub fn setRotationDegrees(self: *const Self, arg_euler_degrees: *const godot.Vector3) !void {
        if (mbind_set_rotation_degrees == null) {
            mbind_set_rotation_degrees = try api.createMethod("Spatial", "set_rotation_degrees");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_euler_degrees),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_rotation_degrees, base, cargs, result);
    }

    pub fn setScale(self: *const Self, arg_scale: *const godot.Vector3) !void {
        if (mbind_set_scale == null) {
            mbind_set_scale = try api.createMethod("Spatial", "set_scale");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_scale),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_scale, base, cargs, result);
    }

    pub fn setTransform(self: *const Self, arg_local: *const godot.Transform) !void {
        if (mbind_set_transform == null) {
            mbind_set_transform = try api.createMethod("Spatial", "set_transform");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_local),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_transform, base, cargs, result);
    }

    pub fn setTranslation(self: *const Self, arg_translation: *const godot.Vector3) !void {
        if (mbind_set_translation == null) {
            mbind_set_translation = try api.createMethod("Spatial", "set_translation");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_translation),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_translation, base, cargs, result);
    }

    pub fn setVisible(self: *const Self, arg_visible: bool) !void {
        if (mbind_set_visible == null) {
            mbind_set_visible = try api.createMethod("Spatial", "set_visible");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, *arg_visible),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_set_visible, base, cargs, result);
    }

    pub fn show(self: *const Self) !void {
        if (mbind_show == null) {
            mbind_show = try api.createMethod("Spatial", "show");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_show, base, cargs, result);
    }

    pub fn toGlobal(self: *const Self, arg_local_point: *const godot.Vector3) !godot.Vector3 {
        if (mbind_to_global == null) {
            mbind_to_global = try api.createMethod("Spatial", "to_global");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_local_point),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_to_global, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn toLocal(self: *const Self, arg_global_point: *const godot.Vector3) !godot.Vector3 {
        if (mbind_to_local == null) {
            mbind_to_local = try api.createMethod("Spatial", "to_local");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_global_point),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_to_local, base, cargs, result);
        return @ptrCast(*godot.Vector3, @alignCast(@alignOf(&godot.Vector3), result)).*;
    }

    pub fn translate(self: *const Self, arg_offset: *const godot.Vector3) !void {
        if (mbind_translate == null) {
            mbind_translate = try api.createMethod("Spatial", "translate");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_translate, base, cargs, result);
    }

    pub fn translateObjectLocal(self: *const Self, arg_offset: *const godot.Vector3) !void {
        if (mbind_translate_object_local == null) {
            mbind_translate_object_local = try api.createMethod("Spatial", "translate_object_local");
        }

        var result: ?*anyopaque = null;
        var args: [1]?*const anyopaque = []?*const anyopaque {
            @ptrCast(*const anyopaque, arg_offset),
        };

        var cargs: ?*?*const anyopaque = &args[0];

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_translate_object_local, base, cargs, result);
    }

    pub fn updateGizmo(self: *const Self) !void {
        if (mbind_update_gizmo == null) {
            mbind_update_gizmo = try api.createMethod("Spatial", "update_gizmo");
        }

        var result: ?*anyopaque = null;
        var cargs: ?*?*const anyopaque = null;

        const base = @ptrCast(*c_api.godot_object, @alignCast(@alignOf(*c_api.godot_object), self.base));
        _ = api.core.?.godot_method_bind_ptrcall.?(mbind_update_gizmo, base, cargs, result);
    }
};